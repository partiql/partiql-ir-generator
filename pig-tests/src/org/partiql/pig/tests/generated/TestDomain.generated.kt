
/**
* This code was generated by the PartiQL I.R. Generator.
* Do not modify this file.  
*/
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*
class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = TestDomainBuilder
    
        fun <T: TestDomainNode> build(block: Builder.() -> T) =
            TestDomainBuilder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [TestDomain.BoolPair].
         */
        fun boolPair(
            first: Boolean,
            second: Boolean,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.BoolPair =
            TestDomain.BoolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.BoolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun boolPair_(
            first: org.partiql.pig.runtime.BoolPrimitive,
            second: org.partiql.pig.runtime.BoolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.BoolPair =
            TestDomain.BoolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         */
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         */
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonPair].
         */
        fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPair =
            TestDomain.IonPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         */
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         */
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         */
        fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonSymbolPair].
         */
        fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonSymbolPair =
            TestDomain.IonSymbolPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntPairPair].
         */
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPairPair].
         */
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonPairPair].
         */
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         */
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerPair].
         */
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         */
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         */
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         */
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         */
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            ints: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name?.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         */
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         */
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive? = null,
            second: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         */
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         */
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSumTriplet].
         */
        fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSumTriplet =
            TestDomain.TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.EntityPair].
         */
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Answer 
        /**
         * Creates an instance of [TestDomain.Answer.No].
         */
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.No =
            TestDomain.Answer.No(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Answer.Yes].
         */
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.Yes =
            TestDomain.Answer.Yes(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumWithRecord 
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         */
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: TestSum 
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         */
        fun one(
            a: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         */
        fun two(
            a: Long,
            b: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a,
                b = b,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         */
        fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                c = c.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a,
                b = b,
                c = c,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Entity 
        /**
         * Creates an instance of [TestDomain.Entity.Slug].
         */
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Slug =
            TestDomain.Entity.Slug(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         */
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         */
        fun human(
            firstName: String,
            middleNames: kotlin.collections.List<String> = emptyList(),
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                middleNames = middleNames.map { it.asPrimitive() },
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive> = emptyList(),
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName,
                middleNames = middleNames,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object TestDomainBuilder : Builder
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): TestDomainNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class BoolPair(
        val first: org.partiql.pig.runtime.BoolPrimitive,
        val second: org.partiql.pig.runtime.BoolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): BoolPair =
            BoolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): BoolPair =
            BoolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("bool_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.BoolPrimitive = this.first,
            second: org.partiql.pig.runtime.BoolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            BoolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != BoolPair::class.java) return false
    
            other as BoolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IntPair = this.first,
            second: IntPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: SymbolPair = this.first,
            second: SymbolPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IonPair = this.first,
            second: IonPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: RecursivePair? = this.second,
            metas: MetaContainer = this.metas
        ) =
            RecursivePair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin0(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin1(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            ElementVariadic(
                name,
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): Optional1 =
            Optional1(
                value = value,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive? = this.value,
            metas: MetaContainer = this.metas
        ) =
            Optional1(
                value,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: org.partiql.pig.runtime.LongPrimitive?,
        val second: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive? = this.first,
            second: org.partiql.pig.runtime.LongPrimitive? = this.second,
            metas: MetaContainer = this.metas
        ) =
            Optional2(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: org.partiql.pig.runtime.LongPrimitive,
        val anotherField: org.partiql.pig.runtime.SymbolPrimitive,
        val optionalField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            someField: org.partiql.pig.runtime.LongPrimitive = this.someField,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive = this.anotherField,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = this.optionalField,
            metas: MetaContainer = this.metas
        ) =
            DomainLevelRecord(
                someField,
                anotherField,
                optionalField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: org.partiql.pig.runtime.LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive = this.value,
            dlr: DomainLevelRecord = this.dlr,
            metas: MetaContainer = this.metas
        ) =
            ProductWithRecord(
                value,
                dlr,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class TestSumTriplet(
        val a: TestSum,
        val b: TestSum,
        val c: TestSum,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("test_sum_triplet"),
                a.toIonElement(),
                b.toIonElement(),
                c.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            a: TestSum = this.a,
            b: TestSum = this.b,
            c: TestSum = this.c,
            metas: MetaContainer = this.metas
        ) =
            TestSumTriplet(
                a,
                b,
                c,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TestSumTriplet::class.java) return false
    
            other as TestSumTriplet
            if (a != other.a) return false
            if (b != other.b) return false
            if (c != other.c) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = a.hashCode()
            hc = 31 * hc + b.hashCode()
            hc = 31 * hc + c.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Entity = this.first,
            second: Entity = this.second,
            metas: MetaContainer = this.metas
        ) =
            EntityPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): Answer =
            when (this) {
                is No -> copy(metas = metas)
                is Yes -> copy(metas = metas)
            }
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copy(metas: MetaContainer): No =
                No(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copy(metas: MetaContainer): Yes =
                Yes(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        /** Converts instances of [TestDomain.Answer] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.Answer): T = when(node) {
                is TestDomain.Answer.No -> convertNo(node)
                is TestDomain.Answer.Yes -> convertYes(node)
            }
    
            fun convertNo(node: TestDomain.Answer.No): T
            fun convertYes(node: TestDomain.Answer.Yes): T
        }
    }
    
    sealed class SumWithRecord(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): SumWithRecord =
            when (this) {
                is VariantWithRecord -> copy(metas = metas)
            }
    
        class VariantWithRecord(
            val value: org.partiql.pig.runtime.LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun copy(metas: MetaContainer): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                dlr: DomainLevelRecord = this.dlr,
                metas: MetaContainer = this.metas
            ) =
                VariantWithRecord(
                    value,
                    dlr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.SumWithRecord] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.SumWithRecord): T = when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> convertVariantWithRecord(node)
            }
    
            fun convertVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): T
        }
    }
    
    sealed class TestSum(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): TestSum =
            when (this) {
                is One -> copy(metas = metas)
                is Two -> copy(metas = metas)
                is Three -> copy(metas = metas)
            }
    
        class One(
            val a: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): One =
                One(
                    a = a,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): One =
                One(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("one"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                metas: MetaContainer = this.metas
            ) =
                One(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != One::class.java) return false
        
                other as One
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Two(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("two"),
                    a.toIonElement(),
                    b.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                metas: MetaContainer = this.metas
            ) =
                Two(
                    a,
                    b,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Two::class.java) return false
        
                other as Two
                if (a != other.a) return false
                if (b != other.b) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Three(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            val c: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("three"),
                    a.toIonElement(),
                    b.toIonElement(),
                    c.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                c: org.partiql.pig.runtime.LongPrimitive = this.c,
                metas: MetaContainer = this.metas
            ) =
                Three(
                    a,
                    b,
                    c,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Three::class.java) return false
        
                other as Three
                if (a != other.a) return false
                if (b != other.b) return false
                if (c != other.c) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc = 31 * hc + c.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.TestSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.TestSum): T = when(node) {
                is TestDomain.TestSum.One -> convertOne(node)
                is TestDomain.TestSum.Two -> convertTwo(node)
                is TestDomain.TestSum.Three -> convertThree(node)
            }
    
            fun convertOne(node: TestDomain.TestSum.One): T
            fun convertTwo(node: TestDomain.TestSum.Two): T
            fun convertThree(node: TestDomain.TestSum.Three): T
        }
    }
    
    sealed class Entity(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): Entity =
            when (this) {
                is Slug -> copy(metas = metas)
                is Android -> copy(metas = metas)
                is Human -> copy(metas = metas)
            }
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Slug =
                Slug(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class Android(
            val id: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Android =
                Android(
                    id = id,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                id: org.partiql.pig.runtime.LongPrimitive = this.id,
                metas: MetaContainer = this.metas
            ) =
                Android(
                    id,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: org.partiql.pig.runtime.SymbolPrimitive,
            val middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive>,
            val lastName: org.partiql.pig.runtime.SymbolPrimitive,
            val title: org.partiql.pig.runtime.SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Human =
                Human(
                    firstName = firstName,
                    middleNames = middleNames,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    middleNames = middleNames,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    if(middleNames.any()) { ionSexpOf(ionSymbol("middle_names"), *middleNames.map { it.toIonElement() }.toTypedArray()) } else { null },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                firstName: org.partiql.pig.runtime.SymbolPrimitive = this.firstName,
                middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive> = this.middleNames,
                lastName: org.partiql.pig.runtime.SymbolPrimitive = this.lastName,
                title: org.partiql.pig.runtime.SymbolPrimitive? = this.title,
                parent: Entity? = this.parent,
                metas: MetaContainer = this.metas
            ) =
                Human(
                    firstName,
                    middleNames,
                    lastName,
                    title,
                    parent,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (middleNames != other.middleNames) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = firstName.hashCode()
                hc = 31 * hc + middleNames.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.Entity] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.Entity): T = when(node) {
                is TestDomain.Entity.Slug -> convertSlug(node)
                is TestDomain.Entity.Android -> convertAndroid(node)
                is TestDomain.Entity.Human -> convertHuman(node)
            }
    
            fun convertSlug(node: TestDomain.Entity.Slug): T
            fun convertAndroid(node: TestDomain.Entity.Android): T
            fun convertHuman(node: TestDomain.Entity.Human): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "bool_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toBoolPrimitive()
                    val second = sexp.getRequired(1).toBoolPrimitive()
                    TestDomain.BoolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "test_sum_triplet" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).transformExpect<TestSum>()
                    val b = sexp.getRequired(1).transformExpect<TestSum>()
                    val c = sexp.getRequired(2).transformExpect<TestSum>()
                    TestDomain.TestSumTriplet(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'TestSum'
                //////////////////////////////////////
                "one" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.TestSum.One(
                        a,
                        metas = sexp.metas)
                }
                "two" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.TestSum.Two(
                        a,
                        b,
                        metas = sexp.metas)
                }
                "three" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    val c = sexp.getRequired(2).toLongPrimitive()
                    TestDomain.TestSum.Three(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val middleNames = ir.processVariadicField("middle_names", 0) { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, middleNames, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitBoolPair(node: TestDomain.BoolPair) { }
        open fun visitIntPair(node: TestDomain.IntPair) { }
        open fun visitSymbolPair(node: TestDomain.SymbolPair) { }
        open fun visitIonPair(node: TestDomain.IonPair) { }
        open fun visitIntSymbolPair(node: TestDomain.IntSymbolPair) { }
        open fun visitSymbolIntPair(node: TestDomain.SymbolIntPair) { }
        open fun visitIonIntPair(node: TestDomain.IonIntPair) { }
        open fun visitIonSymbolPair(node: TestDomain.IonSymbolPair) { }
        open fun visitIntPairPair(node: TestDomain.IntPairPair) { }
        open fun visitSymbolPairPair(node: TestDomain.SymbolPairPair) { }
        open fun visitIonPairPair(node: TestDomain.IonPairPair) { }
        open fun visitRecursivePair(node: TestDomain.RecursivePair) { }
        open fun visitAnswerPair(node: TestDomain.AnswerPair) { }
        open fun visitAnswerIntPair(node: TestDomain.AnswerIntPair) { }
        open fun visitIntAnswerPair(node: TestDomain.IntAnswerPair) { }
        open fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) { }
        open fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) { }
        open fun visitVariadicMin0(node: TestDomain.VariadicMin0) { }
        open fun visitVariadicMin1(node: TestDomain.VariadicMin1) { }
        open fun visitElementVariadic(node: TestDomain.ElementVariadic) { }
        open fun visitOptional1(node: TestDomain.Optional1) { }
        open fun visitOptional2(node: TestDomain.Optional2) { }
        open fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord) { }
        open fun visitProductWithRecord(node: TestDomain.ProductWithRecord) { }
        open fun visitTestSumTriplet(node: TestDomain.TestSumTriplet) { }
        open fun visitEntityPair(node: TestDomain.EntityPair) { }
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        protected open fun visitAnswer(node: TestDomain.Answer) { }
        protected open fun visitAnswerNo(node: TestDomain.Answer.No) { }
        protected open fun visitAnswerYes(node: TestDomain.Answer.Yes) { }
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        protected open fun visitSumWithRecord(node: TestDomain.SumWithRecord) { }
        protected open fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) { }
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        protected open fun visitTestSum(node: TestDomain.TestSum) { }
        protected open fun visitTestSumOne(node: TestDomain.TestSum.One) { }
        protected open fun visitTestSumTwo(node: TestDomain.TestSum.Two) { }
        protected open fun visitTestSumThree(node: TestDomain.TestSum.Three) { }
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        protected open fun visitEntity(node: TestDomain.Entity) { }
        protected open fun visitEntitySlug(node: TestDomain.Entity.Slug) { }
        protected open fun visitEntityAndroid(node: TestDomain.Entity.Android) { }
        protected open fun visitEntityHuman(node: TestDomain.Entity.Human) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkBoolPair(node: TestDomain.BoolPair) {
            visitBoolPair(node)
            walkBoolPrimitive(node.first)
            walkBoolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPair(node: TestDomain.IntPair) {
            visitIntPair(node)
            walkLongPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair) {
            visitSymbolPair(node)
            walkSymbolPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPair(node: TestDomain.IonPair) {
            visitIonPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair) {
            visitIntSymbolPair(node)
            walkLongPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair) {
            visitSymbolIntPair(node)
            walkSymbolPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair) {
            visitIonIntPair(node)
            walkAnyElement(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair) {
            visitIonSymbolPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair) {
            visitIntPairPair(node)
            walkIntPair(node.first)
            walkIntPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair) {
            visitSymbolPairPair(node)
            walkSymbolPair(node.first)
            walkSymbolPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair) {
            visitIonPairPair(node)
            walkIonPair(node.first)
            walkIonPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair) {
            visitRecursivePair(node)
            walkLongPrimitive(node.first)
            node.second?.let { walkRecursivePair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair) {
            visitAnswerPair(node)
            walkAnswer(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair) {
            visitAnswerIntPair(node)
            walkAnswer(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair) {
            visitIntAnswerPair(node)
            walkLongPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) {
            visitSymbolAnswerPair(node)
            walkSymbolPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) {
            visitAnswerSymbolPair(node)
            walkAnswer(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0) {
            visitVariadicMin0(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1) {
            visitVariadicMin1(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic) {
            visitElementVariadic(node)
            walkSymbolPrimitive(node.name)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional1(node: TestDomain.Optional1) {
            visitOptional1(node)
            node.value?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional2(node: TestDomain.Optional2) {
            visitOptional2(node)
            node.first?.let { walkLongPrimitive(it) }
            node.second?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord) {
            visitDomainLevelRecord(node)
            walkLongPrimitive(node.someField)
            walkSymbolPrimitive(node.anotherField)
            node.optionalField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord) {
            visitProductWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet) {
            visitTestSumTriplet(node)
            walkTestSum(node.a)
            walkTestSum(node.b)
            walkTestSum(node.c)
            walkMetas(node.metas)
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair) {
            visitEntityPair(node)
            walkEntity(node.first)
            walkEntity(node.second)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer) {
            visitAnswer(node)
            when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node)
                is TestDomain.Answer.Yes -> walkAnswerYes(node)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No) {
            visitAnswerNo(node)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes) {
            visitAnswerYes(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord) {
            visitSumWithRecord(node)
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) {
            visitSumWithRecordVariantWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum) {
            visitTestSum(node)
            when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node)
                is TestDomain.TestSum.Three -> walkTestSumThree(node)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One) {
            visitTestSumOne(node)
            walkLongPrimitive(node.a)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two) {
            visitTestSumTwo(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three) {
            visitTestSumThree(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkLongPrimitive(node.c)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity) {
            visitEntity(node)
            when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node)
                is TestDomain.Entity.Android -> walkEntityAndroid(node)
                is TestDomain.Entity.Human -> walkEntityHuman(node)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug) {
            visitEntitySlug(node)
            walkMetas(node.metas)
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android) {
            visitEntityAndroid(node)
            walkLongPrimitive(node.id)
            walkMetas(node.metas)
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human) {
            visitEntityHuman(node)
            walkSymbolPrimitive(node.firstName)
            node.middleNames.map { walkSymbolPrimitive(it) }
            walkSymbolPrimitive(node.lastName)
            node.title?.let { walkSymbolPrimitive(it) }
            node.parent?.let { walkEntity(it) }
            walkMetas(node.metas)
        }
    
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitBoolPair(node: TestDomain.BoolPair, accumulator: T): T = accumulator
        open protected fun visitIntPair(node: TestDomain.IntPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T = accumulator
        open protected fun visitIonPair(node: TestDomain.IonPair, accumulator: T): T = accumulator
        open protected fun visitIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T = accumulator
        open protected fun visitSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T = accumulator
        open protected fun visitIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T = accumulator
        open protected fun visitIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T = accumulator
        open protected fun visitIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T = accumulator
        open protected fun visitIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T = accumulator
        open protected fun visitRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T = accumulator
        open protected fun visitAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T = accumulator
        open protected fun visitIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T = accumulator
        open protected fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T = accumulator
        open protected fun visitVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T = accumulator
        open protected fun visitVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T = accumulator
        open protected fun visitElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T = accumulator
        open protected fun visitOptional1(node: TestDomain.Optional1, accumulator: T): T = accumulator
        open protected fun visitOptional2(node: TestDomain.Optional2, accumulator: T): T = accumulator
        open protected fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T = accumulator
        open protected fun visitProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T = accumulator
        open protected fun visitTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T = accumulator
        open protected fun visitEntityPair(node: TestDomain.EntityPair, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open protected fun visitAnswer(node: TestDomain.Answer, accumulator: T): T = accumulator
        open protected fun visitAnswerNo(node: TestDomain.Answer.No, accumulator: T): T = accumulator
        open protected fun visitAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open protected fun visitSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T = accumulator
        open protected fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open protected fun visitTestSum(node: TestDomain.TestSum, accumulator: T): T = accumulator
        open protected fun visitTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T = accumulator
        open protected fun visitTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T = accumulator
        open protected fun visitTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open protected fun visitEntity(node: TestDomain.Entity, accumulator: T): T = accumulator
        open protected fun visitEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T = accumulator
        open protected fun visitEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T = accumulator
        open protected fun visitEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkBoolPair(node: TestDomain.BoolPair, accumulator: T): T {
            var current = accumulator
            current = visitBoolPair(node, current)
            current = walkBoolPrimitive(node.first, current)
            current = walkBoolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPair(node: TestDomain.IntPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPair(node: TestDomain.IonPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIntSymbolPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolIntPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T {
            var current = accumulator
            current = visitIonIntPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIonSymbolPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPairPair(node, current)
            current = walkIntPair(node.first, current)
            current = walkIntPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPairPair(node, current)
            current = walkSymbolPair(node.first, current)
            current = walkSymbolPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPairPair(node, current)
            current = walkIonPair(node.first, current)
            current = walkIonPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T {
            var current = accumulator
            current = visitRecursivePair(node, current)
            current = walkLongPrimitive(node.first, current)
            node.second?.let { current = walkRecursivePair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerIntPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitIntAnswerPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolAnswerPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerSymbolPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin0(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin1(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T {
            var current = accumulator
            current = visitElementVariadic(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional1(node: TestDomain.Optional1, accumulator: T): T {
            var current = accumulator
            current = visitOptional1(node, current)
            node.value?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional2(node: TestDomain.Optional2, accumulator: T): T {
            var current = accumulator
            current = visitOptional2(node, current)
            node.first?.let { current = walkLongPrimitive(it, current) }
            node.second?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T {
            var current = accumulator
            current = visitDomainLevelRecord(node, current)
            current = walkLongPrimitive(node.someField, current)
            current = walkSymbolPrimitive(node.anotherField, current)
            node.optionalField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitProductWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTriplet(node, current)
            current = walkTestSum(node.a, current)
            current = walkTestSum(node.b, current)
            current = walkTestSum(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair, accumulator: T): T {
            var current = accumulator
            current = visitEntityPair(node, current)
            current = walkEntity(node.first, current)
            current = walkEntity(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer, accumulator: T): T {
            val current = visitAnswer(node, accumulator)
            return when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node, current)
                is TestDomain.Answer.Yes -> walkAnswerYes(node, current)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No, accumulator: T): T {
            var current = accumulator
            current = visitAnswerNo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T {
            var current = accumulator
            current = visitAnswerYes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T {
            val current = visitSumWithRecord(node, accumulator)
            return when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node, current)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitSumWithRecordVariantWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum, accumulator: T): T {
            val current = visitTestSum(node, accumulator)
            return when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node, current)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node, current)
                is TestDomain.TestSum.Three -> walkTestSumThree(node, current)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T {
            var current = accumulator
            current = visitTestSumOne(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTwo(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T {
            var current = accumulator
            current = visitTestSumThree(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkLongPrimitive(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity, accumulator: T): T {
            val current = visitEntity(node, accumulator)
            return when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node, current)
                is TestDomain.Entity.Android -> walkEntityAndroid(node, current)
                is TestDomain.Entity.Human -> walkEntityHuman(node, current)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T {
            var current = accumulator
            current = visitEntitySlug(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T {
            var current = accumulator
            current = visitEntityAndroid(node, current)
            current = walkLongPrimitive(node.id, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T {
            var current = accumulator
            current = visitEntityHuman(node, current)
            current = walkSymbolPrimitive(node.firstName, current)
            node.middleNames.map { current = walkSymbolPrimitive(it, current) }
            current = walkSymbolPrimitive(node.lastName, current)
            node.title?.let { current = walkSymbolPrimitive(it, current) }
            node.parent?.let { current = walkEntity(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple BoolPair
        open fun transformBoolPair(node: TestDomain.BoolPair): TestDomain.BoolPair {
            val new_first = transformBoolPair_first(node)
            val new_second = transformBoolPair_second(node)
            val new_metas = transformBoolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.BoolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformBoolPair_first(node: TestDomain.BoolPair) =
            transformBoolPrimitive(node.first)
        open fun transformBoolPair_second(node: TestDomain.BoolPair) =
            transformBoolPrimitive(node.second)
        open fun transformBoolPair_metas(node: TestDomain.BoolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPair
        open fun transformIntPair(node: TestDomain.IntPair): TestDomain.IntPair {
            val new_first = transformIntPair_first(node)
            val new_second = transformIntPair_second(node)
            val new_metas = transformIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntPair_first(node: TestDomain.IntPair) =
            transformLongPrimitive(node.first)
        open fun transformIntPair_second(node: TestDomain.IntPair) =
            transformLongPrimitive(node.second)
        open fun transformIntPair_metas(node: TestDomain.IntPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPair
        open fun transformSymbolPair(node: TestDomain.SymbolPair): TestDomain.SymbolPair {
            val new_first = transformSymbolPair_first(node)
            val new_second = transformSymbolPair_second(node)
            val new_metas = transformSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolPair_first(node: TestDomain.SymbolPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolPair_second(node: TestDomain.SymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformSymbolPair_metas(node: TestDomain.SymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IonPair
        open fun transformIonPair(node: TestDomain.IonPair): TestDomain.IonPair {
            val new_first = transformIonPair_first(node)
            val new_second = transformIonPair_second(node)
            val new_metas = transformIonPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonPair_first(node: TestDomain.IonPair) =
            transformAnyElement(node.first)
        open fun transformIonPair_second(node: TestDomain.IonPair) =
            transformAnyElement(node.second)
        open fun transformIonPair_metas(node: TestDomain.IonPair) =
            transformMetas(node.metas)
    
        // Tuple IntSymbolPair
        open fun transformIntSymbolPair(node: TestDomain.IntSymbolPair): TestDomain.IntSymbolPair {
            val new_first = transformIntSymbolPair_first(node)
            val new_second = transformIntSymbolPair_second(node)
            val new_metas = transformIntSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntSymbolPair_first(node: TestDomain.IntSymbolPair) =
            transformLongPrimitive(node.first)
        open fun transformIntSymbolPair_second(node: TestDomain.IntSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformIntSymbolPair_metas(node: TestDomain.IntSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolIntPair
        open fun transformSymbolIntPair(node: TestDomain.SymbolIntPair): TestDomain.SymbolIntPair {
            val new_first = transformSymbolIntPair_first(node)
            val new_second = transformSymbolIntPair_second(node)
            val new_metas = transformSymbolIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolIntPair_first(node: TestDomain.SymbolIntPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolIntPair_second(node: TestDomain.SymbolIntPair) =
            transformLongPrimitive(node.second)
        open fun transformSymbolIntPair_metas(node: TestDomain.SymbolIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonIntPair
        open fun transformIonIntPair(node: TestDomain.IonIntPair): TestDomain.IonIntPair {
            val new_first = transformIonIntPair_first(node)
            val new_second = transformIonIntPair_second(node)
            val new_metas = transformIonIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonIntPair_first(node: TestDomain.IonIntPair) =
            transformAnyElement(node.first)
        open fun transformIonIntPair_second(node: TestDomain.IonIntPair) =
            transformLongPrimitive(node.second)
        open fun transformIonIntPair_metas(node: TestDomain.IonIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonSymbolPair
        open fun transformIonSymbolPair(node: TestDomain.IonSymbolPair): TestDomain.IonSymbolPair {
            val new_first = transformIonSymbolPair_first(node)
            val new_second = transformIonSymbolPair_second(node)
            val new_metas = transformIonSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonSymbolPair_first(node: TestDomain.IonSymbolPair) =
            transformAnyElement(node.first)
        open fun transformIonSymbolPair_second(node: TestDomain.IonSymbolPair) =
            transformAnyElement(node.second)
        open fun transformIonSymbolPair_metas(node: TestDomain.IonSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPairPair
        open fun transformIntPairPair(node: TestDomain.IntPairPair): TestDomain.IntPairPair {
            val new_first = transformIntPairPair_first(node)
            val new_second = transformIntPairPair_second(node)
            val new_metas = transformIntPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntPairPair_first(node: TestDomain.IntPairPair) =
            transformIntPair(node.first)
        open fun transformIntPairPair_second(node: TestDomain.IntPairPair) =
            transformIntPair(node.second)
        open fun transformIntPairPair_metas(node: TestDomain.IntPairPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPairPair
        open fun transformSymbolPairPair(node: TestDomain.SymbolPairPair): TestDomain.SymbolPairPair {
            val new_first = transformSymbolPairPair_first(node)
            val new_second = transformSymbolPairPair_second(node)
            val new_metas = transformSymbolPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolPairPair_first(node: TestDomain.SymbolPairPair) =
            transformSymbolPair(node.first)
        open fun transformSymbolPairPair_second(node: TestDomain.SymbolPairPair) =
            transformSymbolPair(node.second)
        open fun transformSymbolPairPair_metas(node: TestDomain.SymbolPairPair) =
            transformMetas(node.metas)
    
        // Tuple IonPairPair
        open fun transformIonPairPair(node: TestDomain.IonPairPair): TestDomain.IonPairPair {
            val new_first = transformIonPairPair_first(node)
            val new_second = transformIonPairPair_second(node)
            val new_metas = transformIonPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonPairPair_first(node: TestDomain.IonPairPair) =
            transformIonPair(node.first)
        open fun transformIonPairPair_second(node: TestDomain.IonPairPair) =
            transformIonPair(node.second)
        open fun transformIonPairPair_metas(node: TestDomain.IonPairPair) =
            transformMetas(node.metas)
    
        // Tuple RecursivePair
        open fun transformRecursivePair(node: TestDomain.RecursivePair): TestDomain.RecursivePair {
            val new_first = transformRecursivePair_first(node)
            val new_second = transformRecursivePair_second(node)
            val new_metas = transformRecursivePair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.RecursivePair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecursivePair_first(node: TestDomain.RecursivePair) =
            transformLongPrimitive(node.first)
        open fun transformRecursivePair_second(node: TestDomain.RecursivePair) =
            node.second?.let { transformRecursivePair(it) }
        open fun transformRecursivePair_metas(node: TestDomain.RecursivePair) =
            transformMetas(node.metas)
    
        // Tuple AnswerPair
        open fun transformAnswerPair(node: TestDomain.AnswerPair): TestDomain.AnswerPair {
            val new_first = transformAnswerPair_first(node)
            val new_second = transformAnswerPair_second(node)
            val new_metas = transformAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerPair_first(node: TestDomain.AnswerPair) =
            transformAnswer(node.first)
        open fun transformAnswerPair_second(node: TestDomain.AnswerPair) =
            transformAnswer(node.second)
        open fun transformAnswerPair_metas(node: TestDomain.AnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerIntPair
        open fun transformAnswerIntPair(node: TestDomain.AnswerIntPair): TestDomain.AnswerIntPair {
            val new_first = transformAnswerIntPair_first(node)
            val new_second = transformAnswerIntPair_second(node)
            val new_metas = transformAnswerIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerIntPair_first(node: TestDomain.AnswerIntPair) =
            transformAnswer(node.first)
        open fun transformAnswerIntPair_second(node: TestDomain.AnswerIntPair) =
            transformLongPrimitive(node.second)
        open fun transformAnswerIntPair_metas(node: TestDomain.AnswerIntPair) =
            transformMetas(node.metas)
    
        // Tuple IntAnswerPair
        open fun transformIntAnswerPair(node: TestDomain.IntAnswerPair): TestDomain.IntAnswerPair {
            val new_first = transformIntAnswerPair_first(node)
            val new_second = transformIntAnswerPair_second(node)
            val new_metas = transformIntAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntAnswerPair_first(node: TestDomain.IntAnswerPair) =
            transformLongPrimitive(node.first)
        open fun transformIntAnswerPair_second(node: TestDomain.IntAnswerPair) =
            transformAnswer(node.second)
        open fun transformIntAnswerPair_metas(node: TestDomain.IntAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolAnswerPair
        open fun transformSymbolAnswerPair(node: TestDomain.SymbolAnswerPair): TestDomain.SymbolAnswerPair {
            val new_first = transformSymbolAnswerPair_first(node)
            val new_second = transformSymbolAnswerPair_second(node)
            val new_metas = transformSymbolAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolAnswerPair_first(node: TestDomain.SymbolAnswerPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolAnswerPair_second(node: TestDomain.SymbolAnswerPair) =
            transformAnswer(node.second)
        open fun transformSymbolAnswerPair_metas(node: TestDomain.SymbolAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerSymbolPair
        open fun transformAnswerSymbolPair(node: TestDomain.AnswerSymbolPair): TestDomain.AnswerSymbolPair {
            val new_first = transformAnswerSymbolPair_first(node)
            val new_second = transformAnswerSymbolPair_second(node)
            val new_metas = transformAnswerSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerSymbolPair_first(node: TestDomain.AnswerSymbolPair) =
            transformAnswer(node.first)
        open fun transformAnswerSymbolPair_second(node: TestDomain.AnswerSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformAnswerSymbolPair_metas(node: TestDomain.AnswerSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin0
        open fun transformVariadicMin0(node: TestDomain.VariadicMin0): TestDomain.VariadicMin0 {
            val new_ints = transformVariadicMin0_ints(node)
            val new_metas = transformVariadicMin0_metas(node)
            return if (
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.VariadicMin0(
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformVariadicMin0_ints(node: TestDomain.VariadicMin0) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin0_metas(node: TestDomain.VariadicMin0) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin1
        open fun transformVariadicMin1(node: TestDomain.VariadicMin1): TestDomain.VariadicMin1 {
            val new_ints = transformVariadicMin1_ints(node)
            val new_metas = transformVariadicMin1_metas(node)
            return if (
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.VariadicMin1(
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformVariadicMin1_ints(node: TestDomain.VariadicMin1) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin1_metas(node: TestDomain.VariadicMin1) =
            transformMetas(node.metas)
    
        // Tuple ElementVariadic
        open fun transformElementVariadic(node: TestDomain.ElementVariadic): TestDomain.ElementVariadic {
            val new_name = transformElementVariadic_name(node)
            val new_ints = transformElementVariadic_ints(node)
            val new_metas = transformElementVariadic_metas(node)
            return if (
                node.name !== new_name ||
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.ElementVariadic(
                    name = new_name,
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformElementVariadic_name(node: TestDomain.ElementVariadic) =
            transformSymbolPrimitive(node.name)
        open fun transformElementVariadic_ints(node: TestDomain.ElementVariadic) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformElementVariadic_metas(node: TestDomain.ElementVariadic) =
            transformMetas(node.metas)
    
        // Tuple Optional1
        open fun transformOptional1(node: TestDomain.Optional1): TestDomain.Optional1 {
            val new_value = transformOptional1_value(node)
            val new_metas = transformOptional1_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                TestDomain.Optional1(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOptional1_value(node: TestDomain.Optional1) =
            node.value?.let { transformLongPrimitive(it) }
        open fun transformOptional1_metas(node: TestDomain.Optional1) =
            transformMetas(node.metas)
    
        // Tuple Optional2
        open fun transformOptional2(node: TestDomain.Optional2): TestDomain.Optional2 {
            val new_first = transformOptional2_first(node)
            val new_second = transformOptional2_second(node)
            val new_metas = transformOptional2_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.Optional2(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOptional2_first(node: TestDomain.Optional2) =
            node.first?.let { transformLongPrimitive(it) }
        open fun transformOptional2_second(node: TestDomain.Optional2) =
            node.second?.let { transformLongPrimitive(it) }
        open fun transformOptional2_metas(node: TestDomain.Optional2) =
            transformMetas(node.metas)
    
        // Tuple DomainLevelRecord
        open fun transformDomainLevelRecord(node: TestDomain.DomainLevelRecord): TestDomain.DomainLevelRecord {
            val new_someField = transformDomainLevelRecord_someField(node)
            val new_anotherField = transformDomainLevelRecord_anotherField(node)
            val new_optionalField = transformDomainLevelRecord_optionalField(node)
            val new_metas = transformDomainLevelRecord_metas(node)
            return if (
                node.someField !== new_someField ||
                node.anotherField !== new_anotherField ||
                node.optionalField !== new_optionalField ||
                node.metas !== new_metas
            ) {
                TestDomain.DomainLevelRecord(
                    someField = new_someField,
                    anotherField = new_anotherField,
                    optionalField = new_optionalField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDomainLevelRecord_someField(node: TestDomain.DomainLevelRecord) =
            transformLongPrimitive(node.someField)
        open fun transformDomainLevelRecord_anotherField(node: TestDomain.DomainLevelRecord) =
            transformSymbolPrimitive(node.anotherField)
        open fun transformDomainLevelRecord_optionalField(node: TestDomain.DomainLevelRecord) =
            node.optionalField?.let { transformLongPrimitive(it) }
        open fun transformDomainLevelRecord_metas(node: TestDomain.DomainLevelRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductWithRecord
        open fun transformProductWithRecord(node: TestDomain.ProductWithRecord): TestDomain.ProductWithRecord {
            val new_value = transformProductWithRecord_value(node)
            val new_dlr = transformProductWithRecord_dlr(node)
            val new_metas = transformProductWithRecord_metas(node)
            return if (
                node.value !== new_value ||
                node.dlr !== new_dlr ||
                node.metas !== new_metas
            ) {
                TestDomain.ProductWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductWithRecord_value(node: TestDomain.ProductWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformProductWithRecord_dlr(node: TestDomain.ProductWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformProductWithRecord_metas(node: TestDomain.ProductWithRecord) =
            transformMetas(node.metas)
    
        // Tuple TestSumTriplet
        open fun transformTestSumTriplet(node: TestDomain.TestSumTriplet): TestDomain.TestSumTriplet {
            val new_a = transformTestSumTriplet_a(node)
            val new_b = transformTestSumTriplet_b(node)
            val new_c = transformTestSumTriplet_c(node)
            val new_metas = transformTestSumTriplet_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.c !== new_c ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSumTriplet(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumTriplet_a(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.a)
        open fun transformTestSumTriplet_b(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.b)
        open fun transformTestSumTriplet_c(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.c)
        open fun transformTestSumTriplet_metas(node: TestDomain.TestSumTriplet) =
            transformMetas(node.metas)
    
        // Tuple EntityPair
        open fun transformEntityPair(node: TestDomain.EntityPair): TestDomain.EntityPair {
            val new_first = transformEntityPair_first(node)
            val new_second = transformEntityPair_second(node)
            val new_metas = transformEntityPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.EntityPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityPair_first(node: TestDomain.EntityPair) =
            transformEntity(node.first)
        open fun transformEntityPair_second(node: TestDomain.EntityPair) =
            transformEntity(node.second)
        open fun transformEntityPair_metas(node: TestDomain.EntityPair) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun transformAnswer(node: TestDomain.Answer): TestDomain.Answer =
            when(node) {
                is TestDomain.Answer.No -> transformAnswerNo(node)
                is TestDomain.Answer.Yes -> transformAnswerYes(node)
            }
        // Variant AnswerNo
        open fun transformAnswerNo(node: TestDomain.Answer.No): TestDomain.Answer  {
            val new_metas = transformAnswerNo_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Answer.No(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerNo_metas(node: TestDomain.Answer.No) =
            transformMetas(node.metas)
    
        // Variant AnswerYes
        open fun transformAnswerYes(node: TestDomain.Answer.Yes): TestDomain.Answer  {
            val new_metas = transformAnswerYes_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Answer.Yes(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerYes_metas(node: TestDomain.Answer.Yes) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun transformSumWithRecord(node: TestDomain.SumWithRecord): TestDomain.SumWithRecord =
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> transformSumWithRecordVariantWithRecord(node)
            }
        // Variant SumWithRecordVariantWithRecord
        open fun transformSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): TestDomain.SumWithRecord  {
            val new_value = transformSumWithRecordVariantWithRecord_value(node)
            val new_dlr = transformSumWithRecordVariantWithRecord_dlr(node)
            val new_metas = transformSumWithRecordVariantWithRecord_metas(node)
            return if (
                node.value !== new_value ||
                node.dlr !== new_dlr ||
                node.metas !== new_metas
            ) {
                TestDomain.SumWithRecord.VariantWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumWithRecordVariantWithRecord_value(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformSumWithRecordVariantWithRecord_dlr(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformSumWithRecordVariantWithRecord_metas(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun transformTestSum(node: TestDomain.TestSum): TestDomain.TestSum =
            when(node) {
                is TestDomain.TestSum.One -> transformTestSumOne(node)
                is TestDomain.TestSum.Two -> transformTestSumTwo(node)
                is TestDomain.TestSum.Three -> transformTestSumThree(node)
            }
        // Variant TestSumOne
        open fun transformTestSumOne(node: TestDomain.TestSum.One): TestDomain.TestSum  {
            val new_a = transformTestSumOne_a(node)
            val new_metas = transformTestSumOne_metas(node)
            return if (
                node.a !== new_a ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.One(
                    a = new_a,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumOne_a(node: TestDomain.TestSum.One) =
            transformLongPrimitive(node.a)
        open fun transformTestSumOne_metas(node: TestDomain.TestSum.One) =
            transformMetas(node.metas)
    
        // Variant TestSumTwo
        open fun transformTestSumTwo(node: TestDomain.TestSum.Two): TestDomain.TestSum  {
            val new_a = transformTestSumTwo_a(node)
            val new_b = transformTestSumTwo_b(node)
            val new_metas = transformTestSumTwo_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.Two(
                    a = new_a,
                    b = new_b,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumTwo_a(node: TestDomain.TestSum.Two) =
            transformLongPrimitive(node.a)
        open fun transformTestSumTwo_b(node: TestDomain.TestSum.Two) =
            transformLongPrimitive(node.b)
        open fun transformTestSumTwo_metas(node: TestDomain.TestSum.Two) =
            transformMetas(node.metas)
    
        // Variant TestSumThree
        open fun transformTestSumThree(node: TestDomain.TestSum.Three): TestDomain.TestSum  {
            val new_a = transformTestSumThree_a(node)
            val new_b = transformTestSumThree_b(node)
            val new_c = transformTestSumThree_c(node)
            val new_metas = transformTestSumThree_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.c !== new_c ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.Three(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumThree_a(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.a)
        open fun transformTestSumThree_b(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.b)
        open fun transformTestSumThree_c(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.c)
        open fun transformTestSumThree_metas(node: TestDomain.TestSum.Three) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun transformEntity(node: TestDomain.Entity): TestDomain.Entity =
            when(node) {
                is TestDomain.Entity.Slug -> transformEntitySlug(node)
                is TestDomain.Entity.Android -> transformEntityAndroid(node)
                is TestDomain.Entity.Human -> transformEntityHuman(node)
            }
        // Variant EntitySlug
        open fun transformEntitySlug(node: TestDomain.Entity.Slug): TestDomain.Entity  {
            val new_metas = transformEntitySlug_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Slug(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntitySlug_metas(node: TestDomain.Entity.Slug) =
            transformMetas(node.metas)
    
        // Variant EntityAndroid
        open fun transformEntityAndroid(node: TestDomain.Entity.Android): TestDomain.Entity  {
            val new_id = transformEntityAndroid_id(node)
            val new_metas = transformEntityAndroid_metas(node)
            return if (
                node.id !== new_id ||
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Android(
                    id = new_id,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityAndroid_id(node: TestDomain.Entity.Android) =
            transformLongPrimitive(node.id)
        open fun transformEntityAndroid_metas(node: TestDomain.Entity.Android) =
            transformMetas(node.metas)
    
        // Variant EntityHuman
        open fun transformEntityHuman(node: TestDomain.Entity.Human): TestDomain.Entity  {
            val new_firstName = transformEntityHuman_firstName(node)
            val new_middleNames = transformEntityHuman_middleNames(node)
            val new_lastName = transformEntityHuman_lastName(node)
            val new_title = transformEntityHuman_title(node)
            val new_parent = transformEntityHuman_parent(node)
            val new_metas = transformEntityHuman_metas(node)
            return if (
                node.firstName !== new_firstName ||
                node.middleNames !== new_middleNames ||
                node.lastName !== new_lastName ||
                node.title !== new_title ||
                node.parent !== new_parent ||
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Human(
                    firstName = new_firstName,
                    middleNames = new_middleNames,
                    lastName = new_lastName,
                    title = new_title,
                    parent = new_parent,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityHuman_firstName(node: TestDomain.Entity.Human) =
            transformSymbolPrimitive(node.firstName)
        open fun transformEntityHuman_middleNames(node: TestDomain.Entity.Human) =
            node.middleNames.map { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_lastName(node: TestDomain.Entity.Human) =
            transformSymbolPrimitive(node.lastName)
        open fun transformEntityHuman_title(node: TestDomain.Entity.Human) =
            node.title?.let { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_parent(node: TestDomain.Entity.Human) =
            node.parent?.let { transformEntity(it) }
        open fun transformEntityHuman_metas(node: TestDomain.Entity.Human) =
            transformMetas(node.metas)
    
    }
}

