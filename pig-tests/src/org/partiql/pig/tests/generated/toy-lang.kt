/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
    "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
    "USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class ToyLang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = ToyLangBuilder
    
        fun <T: ToyLangNode> build(block: Builder.() -> T) =
            ToyLangBuilder.block()
    
        fun transform(element: AnyElement): ToyLangNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [ToyLang.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Lit
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Variable].
         */
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable
        
        /**
         * Creates an instance of [ToyLang.Expr.Variable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Not
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus
        
        /**
         * Creates an instance of [ToyLang.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus
        
        /**
         * Creates an instance of [ToyLang.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times
        
        /**
         * Creates an instance of [ToyLang.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide
        
        /**
         * Creates an instance of [ToyLang.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo
        
        /**
         * Creates an instance of [ToyLang.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Call].
         */
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call
        
        /**
         * Creates an instance of [ToyLang.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Let].
         */
        fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let
        
        /**
         * Creates an instance of [ToyLang.Expr.Let].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Function].
         */
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function
        
        /**
         * Creates an instance of [ToyLang.Expr.Function].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function
    }
    
    private object ToyLangBuilder : Builder {
        // Variants for Sum: Expr 
        override fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer
        ): ToyLang.Expr.Lit =
            ToyLang.Expr.Lit(
                value = value.asAnyElement(),
                metas = metas)
        
        
        override fun variable(
            name: String,
            metas: MetaContainer
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name.asPrimitive(),
                metas = metas)
        
        override fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name,
                metas = metas)
        
        
        override fun not(
            expr: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Not =
            ToyLang.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        override fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = operands,
                metas = metas)
        
        override fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = operands,
                metas = metas)
        
        override fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = operands,
                metas = metas)
        
        override fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = operands,
                metas = metas)
        
        override fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        override fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        override fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        override fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        override fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name,
                value = value,
                body = body,
                metas = metas)
        
        
        override fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        override fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLang types. */
    abstract class ToyLangNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): ToyLangNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : ToyLangNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Lit -> copy(metas = metas)
                is Variable -> copy(metas = metas)
                is Not -> copy(metas = metas)
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
                is Call -> copy(metas = metas)
                is Let -> copy(metas = metas)
                is Function -> copy(metas = metas)
            }
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Variable =
                Variable(
                    name = name,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                metas: MetaContainer = this.metas
            ) =
                Variable(
                    name,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Not =
                Not(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                argument: Expr = this.argument,
                metas: MetaContainer = this.metas
            ) =
                Call(
                    name,
                    argument,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                value: Expr = this.value,
                body: Expr = this.body,
                metas: MetaContainer = this.metas
            ) =
                Let(
                    name,
                    value,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                varName: org.partiql.pig.runtime.SymbolPrimitive = this.varName,
                body: Expr = this.body,
                metas: MetaContainer = this.metas
            ) =
                Function(
                    varName,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<ToyLangNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLang.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    ToyLang.Expr.Variable(
                        name,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLang.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLang.Expr.Let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: ToyLang.Expr) { }
        protected open fun visitExprLit(node: ToyLang.Expr.Lit) { }
        protected open fun visitExprVariable(node: ToyLang.Expr.Variable) { }
        protected open fun visitExprNot(node: ToyLang.Expr.Not) { }
        protected open fun visitExprPlus(node: ToyLang.Expr.Plus) { }
        protected open fun visitExprMinus(node: ToyLang.Expr.Minus) { }
        protected open fun visitExprTimes(node: ToyLang.Expr.Times) { }
        protected open fun visitExprDivide(node: ToyLang.Expr.Divide) { }
        protected open fun visitExprModulo(node: ToyLang.Expr.Modulo) { }
        protected open fun visitExprCall(node: ToyLang.Expr.Call) { }
        protected open fun visitExprLet(node: ToyLang.Expr.Let) { }
        protected open fun visitExprFunction(node: ToyLang.Expr.Function) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLang.Expr) {
            visitExpr(node)
            when(node) {
                is ToyLang.Expr.Lit -> walkExprLit(node)
                is ToyLang.Expr.Variable -> walkExprVariable(node)
                is ToyLang.Expr.Not -> walkExprNot(node)
                is ToyLang.Expr.Plus -> walkExprPlus(node)
                is ToyLang.Expr.Minus -> walkExprMinus(node)
                is ToyLang.Expr.Times -> walkExprTimes(node)
                is ToyLang.Expr.Divide -> walkExprDivide(node)
                is ToyLang.Expr.Modulo -> walkExprModulo(node)
                is ToyLang.Expr.Call -> walkExprCall(node)
                is ToyLang.Expr.Let -> walkExprLet(node)
                is ToyLang.Expr.Function -> walkExprFunction(node)
            }
        }
    
        open fun walkExprLit(node: ToyLang.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLang.Expr.Variable) {
            visitExprVariable(node)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLang.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLang.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLang.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLang.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLang.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLang.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLang.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLang.Expr.Let) {
            visitExprLet(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLang.Expr.Function) {
            visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: ToyLang.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: ToyLang.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprVariable(node: ToyLang.Expr.Variable, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: ToyLang.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: ToyLang.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: ToyLang.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: ToyLang.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: ToyLang.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: ToyLang.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: ToyLang.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprLet(node: ToyLang.Expr.Let, accumulator: T): T = accumulator
        open protected fun visitExprFunction(node: ToyLang.Expr.Function, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLang.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is ToyLang.Expr.Lit -> walkExprLit(node, current)
                is ToyLang.Expr.Variable -> walkExprVariable(node, current)
                is ToyLang.Expr.Not -> walkExprNot(node, current)
                is ToyLang.Expr.Plus -> walkExprPlus(node, current)
                is ToyLang.Expr.Minus -> walkExprMinus(node, current)
                is ToyLang.Expr.Times -> walkExprTimes(node, current)
                is ToyLang.Expr.Divide -> walkExprDivide(node, current)
                is ToyLang.Expr.Modulo -> walkExprModulo(node, current)
                is ToyLang.Expr.Call -> walkExprCall(node, current)
                is ToyLang.Expr.Let -> walkExprLet(node, current)
                is ToyLang.Expr.Function -> walkExprFunction(node, current)
            }
        }
    
        open fun walkExprLit(node: ToyLang.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprVariable(node: ToyLang.Expr.Variable, accumulator: T): T {
            var current = accumulator
            current = visitExprVariable(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: ToyLang.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: ToyLang.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: ToyLang.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: ToyLang.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: ToyLang.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: ToyLang.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: ToyLang.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.argument, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLet(node: ToyLang.Expr.Let, accumulator: T): T {
            var current = accumulator
            current = visitExprLet(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprFunction(node: ToyLang.Expr.Function, accumulator: T): T {
            var current = accumulator
            current = visitExprFunction(node, current)
            current = walkSymbolPrimitive(node.varName, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: ToyLang.Expr): ToyLang.Expr =
            when(node) {
                is ToyLang.Expr.Lit -> transformExprLit(node)
                is ToyLang.Expr.Variable -> transformExprVariable(node)
                is ToyLang.Expr.Not -> transformExprNot(node)
                is ToyLang.Expr.Plus -> transformExprPlus(node)
                is ToyLang.Expr.Minus -> transformExprMinus(node)
                is ToyLang.Expr.Times -> transformExprTimes(node)
                is ToyLang.Expr.Divide -> transformExprDivide(node)
                is ToyLang.Expr.Modulo -> transformExprModulo(node)
                is ToyLang.Expr.Call -> transformExprCall(node)
                is ToyLang.Expr.Let -> transformExprLet(node)
                is ToyLang.Expr.Function -> transformExprFunction(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: ToyLang.Expr.Lit): ToyLang.Expr  {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: ToyLang.Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: ToyLang.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprVariable
        open fun transformExprVariable(node: ToyLang.Expr.Variable): ToyLang.Expr  {
            val new_name = transformExprVariable_name(node)
            val new_metas = transformExprVariable_metas(node)
            return if (
                node.name !== new_name ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Variable(
                    name = new_name,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprVariable_name(node: ToyLang.Expr.Variable) =
            transformSymbolPrimitive(node.name)
        open fun transformExprVariable_metas(node: ToyLang.Expr.Variable) =
            transformMetas(node.metas)
    
        // Variant ExprNot
        open fun transformExprNot(node: ToyLang.Expr.Not): ToyLang.Expr  {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNot_expr(node: ToyLang.Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: ToyLang.Expr.Not) =
            transformMetas(node.metas)
    
        // Variant ExprPlus
        open fun transformExprPlus(node: ToyLang.Expr.Plus): ToyLang.Expr  {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPlus_operands(node: ToyLang.Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: ToyLang.Expr.Plus) =
            transformMetas(node.metas)
    
        // Variant ExprMinus
        open fun transformExprMinus(node: ToyLang.Expr.Minus): ToyLang.Expr  {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprMinus_operands(node: ToyLang.Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: ToyLang.Expr.Minus) =
            transformMetas(node.metas)
    
        // Variant ExprTimes
        open fun transformExprTimes(node: ToyLang.Expr.Times): ToyLang.Expr  {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprTimes_operands(node: ToyLang.Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: ToyLang.Expr.Times) =
            transformMetas(node.metas)
    
        // Variant ExprDivide
        open fun transformExprDivide(node: ToyLang.Expr.Divide): ToyLang.Expr  {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprDivide_operands(node: ToyLang.Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: ToyLang.Expr.Divide) =
            transformMetas(node.metas)
    
        // Variant ExprModulo
        open fun transformExprModulo(node: ToyLang.Expr.Modulo): ToyLang.Expr  {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprModulo_operands(node: ToyLang.Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: ToyLang.Expr.Modulo) =
            transformMetas(node.metas)
    
        // Variant ExprCall
        open fun transformExprCall(node: ToyLang.Expr.Call): ToyLang.Expr  {
            val new_name = transformExprCall_name(node)
            val new_argument = transformExprCall_argument(node)
            val new_metas = transformExprCall_metas(node)
            return if (
                node.name !== new_name ||
                node.argument !== new_argument ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Call(
                    name = new_name,
                    argument = new_argument,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCall_name(node: ToyLang.Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_argument(node: ToyLang.Expr.Call) =
            transformExpr(node.argument)
        open fun transformExprCall_metas(node: ToyLang.Expr.Call) =
            transformMetas(node.metas)
    
        // Variant ExprLet
        open fun transformExprLet(node: ToyLang.Expr.Let): ToyLang.Expr  {
            val new_name = transformExprLet_name(node)
            val new_value = transformExprLet_value(node)
            val new_body = transformExprLet_body(node)
            val new_metas = transformExprLet_metas(node)
            return if (
                node.name !== new_name ||
                node.value !== new_value ||
                node.body !== new_body ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Let(
                    name = new_name,
                    value = new_value,
                    body = new_body,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLet_name(node: ToyLang.Expr.Let) =
            transformSymbolPrimitive(node.name)
        open fun transformExprLet_value(node: ToyLang.Expr.Let) =
            transformExpr(node.value)
        open fun transformExprLet_body(node: ToyLang.Expr.Let) =
            transformExpr(node.body)
        open fun transformExprLet_metas(node: ToyLang.Expr.Let) =
            transformMetas(node.metas)
    
        // Variant ExprFunction
        open fun transformExprFunction(node: ToyLang.Expr.Function): ToyLang.Expr  {
            val new_varName = transformExprFunction_varName(node)
            val new_body = transformExprFunction_body(node)
            val new_metas = transformExprFunction_metas(node)
            return if (
                node.varName !== new_varName ||
                node.body !== new_body ||
                node.metas !== new_metas
            ) {
                ToyLang.Expr.Function(
                    varName = new_varName,
                    body = new_body,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprFunction_varName(node: ToyLang.Expr.Function) =
            transformSymbolPrimitive(node.varName)
        open fun transformExprFunction_body(node: ToyLang.Expr.Function) =
            transformExpr(node.body)
        open fun transformExprFunction_metas(node: ToyLang.Expr.Function) =
            transformMetas(node.metas)
    
    }
}


class ToyLangIndexed private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = ToyLangIndexedBuilder
    
        fun <T: ToyLangIndexedNode> build(block: Builder.() -> T) =
            ToyLangIndexedBuilder.block()
    
        fun transform(element: AnyElement): ToyLangIndexedNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangIndexedNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Lit
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Not
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Plus
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Plus
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Minus
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Minus
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Times
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Times
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Divide
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Divide
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Modulo
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Modulo
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Call].
         */
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Call
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Call
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Function].
         */
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Function
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Function].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Function
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Variable].
         */
        fun variable(
            name: String,
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Variable
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Variable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Variable
        
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Let].
         */
        fun let(
            name: String,
            index: Long,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Let
        
        /**
         * Creates an instance of [ToyLangIndexed.Expr.Let].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            index: org.partiql.pig.runtime.LongPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangIndexed.Expr.Let
    }
    
    private object ToyLangIndexedBuilder : Builder {
        // Variants for Sum: Expr 
        override fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Lit =
            ToyLangIndexed.Expr.Lit(
                value = value.asAnyElement(),
                metas = metas)
        
        
        override fun not(
            expr: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Not =
            ToyLangIndexed.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        override fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Plus =
            ToyLangIndexed.Expr.Plus(
                operands = operands,
                metas = metas)
        
        override fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Plus =
            ToyLangIndexed.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Minus =
            ToyLangIndexed.Expr.Minus(
                operands = operands,
                metas = metas)
        
        override fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Minus =
            ToyLangIndexed.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Times =
            ToyLangIndexed.Expr.Times(
                operands = operands,
                metas = metas)
        
        override fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Times =
            ToyLangIndexed.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Divide =
            ToyLangIndexed.Expr.Divide(
                operands = operands,
                metas = metas)
        
        override fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Divide =
            ToyLangIndexed.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Modulo =
            ToyLangIndexed.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        override fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Modulo =
            ToyLangIndexed.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        override fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Call =
            ToyLangIndexed.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        override fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Call =
            ToyLangIndexed.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        override fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Function =
            ToyLangIndexed.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        override fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Function =
            ToyLangIndexed.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
        
        
        override fun variable(
            name: String,
            index: Long,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Variable =
            ToyLangIndexed.Expr.Variable(
                name = name.asPrimitive(),
                index = index.asPrimitive(),
                metas = metas)
        
        override fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Variable =
            ToyLangIndexed.Expr.Variable(
                name = name,
                index = index,
                metas = metas)
        
        
        override fun let(
            name: String,
            index: Long,
            value: Expr,
            body: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Let =
            ToyLangIndexed.Expr.Let(
                name = name.asPrimitive(),
                index = index.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        override fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            index: org.partiql.pig.runtime.LongPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer
        ): ToyLangIndexed.Expr.Let =
            ToyLangIndexed.Expr.Let(
                name = name,
                index = index,
                value = value,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLangIndexed types. */
    abstract class ToyLangIndexedNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): ToyLangIndexedNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangIndexedNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : ToyLangIndexedNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Lit -> copy(metas = metas)
                is Not -> copy(metas = metas)
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
                is Call -> copy(metas = metas)
                is Function -> copy(metas = metas)
                is Variable -> copy(metas = metas)
                is Let -> copy(metas = metas)
            }
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Not =
                Not(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                argument: Expr = this.argument,
                metas: MetaContainer = this.metas
            ) =
                Call(
                    name,
                    argument,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                varName: org.partiql.pig.runtime.SymbolPrimitive = this.varName,
                body: Expr = this.body,
                metas: MetaContainer = this.metas
            ) =
                Function(
                    varName,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Variable =
                Variable(
                    name = name,
                    index = index,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                metas: MetaContainer = this.metas
            ) =
                Variable(
                    name,
                    index,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val index: org.partiql.pig.runtime.LongPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Let =
                Let(
                    name = name,
                    index = index,
                    value = value,
                    body = body,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    index = index,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    index.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                value: Expr = this.value,
                body: Expr = this.body,
                metas: MetaContainer = this.metas
            ) =
                Let(
                    name,
                    index,
                    value,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (index != other.index) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + index.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<ToyLangIndexedNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangIndexedNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLangIndexed.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLangIndexed.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangIndexed.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangIndexed.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangIndexed.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangIndexed.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangIndexed.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangIndexed.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangIndexed.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val index = sexp.getRequired(1).toLongPrimitive()
                    ToyLangIndexed.Expr.Variable(
                        name,
                        index,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(4, 4))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val index = sexp.getRequired(1).toLongPrimitive()
                    val value = sexp.getRequired(2).transformExpect<Expr>()
                    val body = sexp.getRequired(3).transformExpect<Expr>()
                    ToyLangIndexed.Expr.Let(
                        name,
                        index,
                        value,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_indexed'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: ToyLangIndexed.Expr) { }
        protected open fun visitExprLit(node: ToyLangIndexed.Expr.Lit) { }
        protected open fun visitExprNot(node: ToyLangIndexed.Expr.Not) { }
        protected open fun visitExprPlus(node: ToyLangIndexed.Expr.Plus) { }
        protected open fun visitExprMinus(node: ToyLangIndexed.Expr.Minus) { }
        protected open fun visitExprTimes(node: ToyLangIndexed.Expr.Times) { }
        protected open fun visitExprDivide(node: ToyLangIndexed.Expr.Divide) { }
        protected open fun visitExprModulo(node: ToyLangIndexed.Expr.Modulo) { }
        protected open fun visitExprCall(node: ToyLangIndexed.Expr.Call) { }
        protected open fun visitExprFunction(node: ToyLangIndexed.Expr.Function) { }
        protected open fun visitExprVariable(node: ToyLangIndexed.Expr.Variable) { }
        protected open fun visitExprLet(node: ToyLangIndexed.Expr.Let) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLangIndexed.Expr) {
            visitExpr(node)
            when(node) {
                is ToyLangIndexed.Expr.Lit -> walkExprLit(node)
                is ToyLangIndexed.Expr.Not -> walkExprNot(node)
                is ToyLangIndexed.Expr.Plus -> walkExprPlus(node)
                is ToyLangIndexed.Expr.Minus -> walkExprMinus(node)
                is ToyLangIndexed.Expr.Times -> walkExprTimes(node)
                is ToyLangIndexed.Expr.Divide -> walkExprDivide(node)
                is ToyLangIndexed.Expr.Modulo -> walkExprModulo(node)
                is ToyLangIndexed.Expr.Call -> walkExprCall(node)
                is ToyLangIndexed.Expr.Function -> walkExprFunction(node)
                is ToyLangIndexed.Expr.Variable -> walkExprVariable(node)
                is ToyLangIndexed.Expr.Let -> walkExprLet(node)
            }
        }
    
        open fun walkExprLit(node: ToyLangIndexed.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLangIndexed.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLangIndexed.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLangIndexed.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLangIndexed.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLangIndexed.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLangIndexed.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLangIndexed.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLangIndexed.Expr.Function) {
            visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLangIndexed.Expr.Variable) {
            visitExprVariable(node)
            walkSymbolPrimitive(node.name)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLangIndexed.Expr.Let) {
            visitExprLet(node)
            walkSymbolPrimitive(node.name)
            walkLongPrimitive(node.index)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: ToyLangIndexed.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: ToyLangIndexed.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: ToyLangIndexed.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: ToyLangIndexed.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: ToyLangIndexed.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: ToyLangIndexed.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: ToyLangIndexed.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: ToyLangIndexed.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: ToyLangIndexed.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprFunction(node: ToyLangIndexed.Expr.Function, accumulator: T): T = accumulator
        open protected fun visitExprVariable(node: ToyLangIndexed.Expr.Variable, accumulator: T): T = accumulator
        open protected fun visitExprLet(node: ToyLangIndexed.Expr.Let, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLangIndexed.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is ToyLangIndexed.Expr.Lit -> walkExprLit(node, current)
                is ToyLangIndexed.Expr.Not -> walkExprNot(node, current)
                is ToyLangIndexed.Expr.Plus -> walkExprPlus(node, current)
                is ToyLangIndexed.Expr.Minus -> walkExprMinus(node, current)
                is ToyLangIndexed.Expr.Times -> walkExprTimes(node, current)
                is ToyLangIndexed.Expr.Divide -> walkExprDivide(node, current)
                is ToyLangIndexed.Expr.Modulo -> walkExprModulo(node, current)
                is ToyLangIndexed.Expr.Call -> walkExprCall(node, current)
                is ToyLangIndexed.Expr.Function -> walkExprFunction(node, current)
                is ToyLangIndexed.Expr.Variable -> walkExprVariable(node, current)
                is ToyLangIndexed.Expr.Let -> walkExprLet(node, current)
            }
        }
    
        open fun walkExprLit(node: ToyLangIndexed.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: ToyLangIndexed.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: ToyLangIndexed.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: ToyLangIndexed.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: ToyLangIndexed.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: ToyLangIndexed.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: ToyLangIndexed.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: ToyLangIndexed.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.argument, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprFunction(node: ToyLangIndexed.Expr.Function, accumulator: T): T {
            var current = accumulator
            current = visitExprFunction(node, current)
            current = walkSymbolPrimitive(node.varName, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprVariable(node: ToyLangIndexed.Expr.Variable, accumulator: T): T {
            var current = accumulator
            current = visitExprVariable(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkLongPrimitive(node.index, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLet(node: ToyLangIndexed.Expr.Let, accumulator: T): T {
            var current = accumulator
            current = visitExprLet(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkLongPrimitive(node.index, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: ToyLangIndexed.Expr): ToyLangIndexed.Expr =
            when(node) {
                is ToyLangIndexed.Expr.Lit -> transformExprLit(node)
                is ToyLangIndexed.Expr.Not -> transformExprNot(node)
                is ToyLangIndexed.Expr.Plus -> transformExprPlus(node)
                is ToyLangIndexed.Expr.Minus -> transformExprMinus(node)
                is ToyLangIndexed.Expr.Times -> transformExprTimes(node)
                is ToyLangIndexed.Expr.Divide -> transformExprDivide(node)
                is ToyLangIndexed.Expr.Modulo -> transformExprModulo(node)
                is ToyLangIndexed.Expr.Call -> transformExprCall(node)
                is ToyLangIndexed.Expr.Function -> transformExprFunction(node)
                is ToyLangIndexed.Expr.Variable -> transformExprVariable(node)
                is ToyLangIndexed.Expr.Let -> transformExprLet(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: ToyLangIndexed.Expr.Lit): ToyLangIndexed.Expr  {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: ToyLangIndexed.Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: ToyLangIndexed.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprNot
        open fun transformExprNot(node: ToyLangIndexed.Expr.Not): ToyLangIndexed.Expr  {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNot_expr(node: ToyLangIndexed.Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: ToyLangIndexed.Expr.Not) =
            transformMetas(node.metas)
    
        // Variant ExprPlus
        open fun transformExprPlus(node: ToyLangIndexed.Expr.Plus): ToyLangIndexed.Expr  {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPlus_operands(node: ToyLangIndexed.Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: ToyLangIndexed.Expr.Plus) =
            transformMetas(node.metas)
    
        // Variant ExprMinus
        open fun transformExprMinus(node: ToyLangIndexed.Expr.Minus): ToyLangIndexed.Expr  {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprMinus_operands(node: ToyLangIndexed.Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: ToyLangIndexed.Expr.Minus) =
            transformMetas(node.metas)
    
        // Variant ExprTimes
        open fun transformExprTimes(node: ToyLangIndexed.Expr.Times): ToyLangIndexed.Expr  {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprTimes_operands(node: ToyLangIndexed.Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: ToyLangIndexed.Expr.Times) =
            transformMetas(node.metas)
    
        // Variant ExprDivide
        open fun transformExprDivide(node: ToyLangIndexed.Expr.Divide): ToyLangIndexed.Expr  {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprDivide_operands(node: ToyLangIndexed.Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: ToyLangIndexed.Expr.Divide) =
            transformMetas(node.metas)
    
        // Variant ExprModulo
        open fun transformExprModulo(node: ToyLangIndexed.Expr.Modulo): ToyLangIndexed.Expr  {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprModulo_operands(node: ToyLangIndexed.Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: ToyLangIndexed.Expr.Modulo) =
            transformMetas(node.metas)
    
        // Variant ExprCall
        open fun transformExprCall(node: ToyLangIndexed.Expr.Call): ToyLangIndexed.Expr  {
            val new_name = transformExprCall_name(node)
            val new_argument = transformExprCall_argument(node)
            val new_metas = transformExprCall_metas(node)
            return if (
                node.name !== new_name ||
                node.argument !== new_argument ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Call(
                    name = new_name,
                    argument = new_argument,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCall_name(node: ToyLangIndexed.Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_argument(node: ToyLangIndexed.Expr.Call) =
            transformExpr(node.argument)
        open fun transformExprCall_metas(node: ToyLangIndexed.Expr.Call) =
            transformMetas(node.metas)
    
        // Variant ExprFunction
        open fun transformExprFunction(node: ToyLangIndexed.Expr.Function): ToyLangIndexed.Expr  {
            val new_varName = transformExprFunction_varName(node)
            val new_body = transformExprFunction_body(node)
            val new_metas = transformExprFunction_metas(node)
            return if (
                node.varName !== new_varName ||
                node.body !== new_body ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Function(
                    varName = new_varName,
                    body = new_body,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprFunction_varName(node: ToyLangIndexed.Expr.Function) =
            transformSymbolPrimitive(node.varName)
        open fun transformExprFunction_body(node: ToyLangIndexed.Expr.Function) =
            transformExpr(node.body)
        open fun transformExprFunction_metas(node: ToyLangIndexed.Expr.Function) =
            transformMetas(node.metas)
    
        // Variant ExprVariable
        open fun transformExprVariable(node: ToyLangIndexed.Expr.Variable): ToyLangIndexed.Expr  {
            val new_name = transformExprVariable_name(node)
            val new_index = transformExprVariable_index(node)
            val new_metas = transformExprVariable_metas(node)
            return if (
                node.name !== new_name ||
                node.index !== new_index ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Variable(
                    name = new_name,
                    index = new_index,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprVariable_name(node: ToyLangIndexed.Expr.Variable) =
            transformSymbolPrimitive(node.name)
        open fun transformExprVariable_index(node: ToyLangIndexed.Expr.Variable) =
            transformLongPrimitive(node.index)
        open fun transformExprVariable_metas(node: ToyLangIndexed.Expr.Variable) =
            transformMetas(node.metas)
    
        // Variant ExprLet
        open fun transformExprLet(node: ToyLangIndexed.Expr.Let): ToyLangIndexed.Expr  {
            val new_name = transformExprLet_name(node)
            val new_index = transformExprLet_index(node)
            val new_value = transformExprLet_value(node)
            val new_body = transformExprLet_body(node)
            val new_metas = transformExprLet_metas(node)
            return if (
                node.name !== new_name ||
                node.index !== new_index ||
                node.value !== new_value ||
                node.body !== new_body ||
                node.metas !== new_metas
            ) {
                ToyLangIndexed.Expr.Let(
                    name = new_name,
                    index = new_index,
                    value = new_value,
                    body = new_body,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLet_name(node: ToyLangIndexed.Expr.Let) =
            transformSymbolPrimitive(node.name)
        open fun transformExprLet_index(node: ToyLangIndexed.Expr.Let) =
            transformLongPrimitive(node.index)
        open fun transformExprLet_value(node: ToyLangIndexed.Expr.Let) =
            transformExpr(node.value)
        open fun transformExprLet_body(node: ToyLangIndexed.Expr.Let) =
            transformExpr(node.body)
        open fun transformExprLet_metas(node: ToyLangIndexed.Expr.Let) =
            transformMetas(node.metas)
    
    }
}



//////////////////////////////////////
// Cross domain transforms
//////////////////////////////////////

abstract class ToyLangToToyLangIndexedVisitorTransform : DomainVisitorTransformBase() {
    //////////////////////////////////////
    // Sum Type: Expr
    //////////////////////////////////////
    open fun transformExpr(node: ToyLang.Expr): ToyLangIndexed.Expr =
        when(node) {
            is ToyLang.Expr.Lit -> transformExprLit(node)
            is ToyLang.Expr.Variable -> transformExprVariable(node)
            is ToyLang.Expr.Not -> transformExprNot(node)
            is ToyLang.Expr.Plus -> transformExprPlus(node)
            is ToyLang.Expr.Minus -> transformExprMinus(node)
            is ToyLang.Expr.Times -> transformExprTimes(node)
            is ToyLang.Expr.Divide -> transformExprDivide(node)
            is ToyLang.Expr.Modulo -> transformExprModulo(node)
            is ToyLang.Expr.Call -> transformExprCall(node)
            is ToyLang.Expr.Let -> transformExprLet(node)
            is ToyLang.Expr.Function -> transformExprFunction(node)
        }
    // Variant ExprLit
    open fun transformExprLit(node: ToyLang.Expr.Lit): ToyLangIndexed.Expr  {
        val new_value = transformExprLit_value(node)
        val new_metas = transformExprLit_metas(node)
        return             ToyLangIndexed.Expr.Lit(
                value = new_value,
                metas = new_metas
            )
    }
    open fun transformExprLit_value(node: ToyLang.Expr.Lit) =
        transformAnyElement(node.value)
    open fun transformExprLit_metas(node: ToyLang.Expr.Lit) =
        transformMetas(node.metas)

    // Variant ExprVariable
    abstract fun transformExprVariable(node: ToyLang.Expr.Variable): ToyLangIndexed.Expr
    // Variant ExprNot
    open fun transformExprNot(node: ToyLang.Expr.Not): ToyLangIndexed.Expr  {
        val new_expr = transformExprNot_expr(node)
        val new_metas = transformExprNot_metas(node)
        return             ToyLangIndexed.Expr.Not(
                expr = new_expr,
                metas = new_metas
            )
    }
    open fun transformExprNot_expr(node: ToyLang.Expr.Not) =
        transformExpr(node.expr)
    open fun transformExprNot_metas(node: ToyLang.Expr.Not) =
        transformMetas(node.metas)

    // Variant ExprPlus
    open fun transformExprPlus(node: ToyLang.Expr.Plus): ToyLangIndexed.Expr  {
        val new_operands = transformExprPlus_operands(node)
        val new_metas = transformExprPlus_metas(node)
        return             ToyLangIndexed.Expr.Plus(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprPlus_operands(node: ToyLang.Expr.Plus) =
        node.operands.map { transformExpr(it) }
    open fun transformExprPlus_metas(node: ToyLang.Expr.Plus) =
        transformMetas(node.metas)

    // Variant ExprMinus
    open fun transformExprMinus(node: ToyLang.Expr.Minus): ToyLangIndexed.Expr  {
        val new_operands = transformExprMinus_operands(node)
        val new_metas = transformExprMinus_metas(node)
        return             ToyLangIndexed.Expr.Minus(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprMinus_operands(node: ToyLang.Expr.Minus) =
        node.operands.map { transformExpr(it) }
    open fun transformExprMinus_metas(node: ToyLang.Expr.Minus) =
        transformMetas(node.metas)

    // Variant ExprTimes
    open fun transformExprTimes(node: ToyLang.Expr.Times): ToyLangIndexed.Expr  {
        val new_operands = transformExprTimes_operands(node)
        val new_metas = transformExprTimes_metas(node)
        return             ToyLangIndexed.Expr.Times(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprTimes_operands(node: ToyLang.Expr.Times) =
        node.operands.map { transformExpr(it) }
    open fun transformExprTimes_metas(node: ToyLang.Expr.Times) =
        transformMetas(node.metas)

    // Variant ExprDivide
    open fun transformExprDivide(node: ToyLang.Expr.Divide): ToyLangIndexed.Expr  {
        val new_operands = transformExprDivide_operands(node)
        val new_metas = transformExprDivide_metas(node)
        return             ToyLangIndexed.Expr.Divide(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprDivide_operands(node: ToyLang.Expr.Divide) =
        node.operands.map { transformExpr(it) }
    open fun transformExprDivide_metas(node: ToyLang.Expr.Divide) =
        transformMetas(node.metas)

    // Variant ExprModulo
    open fun transformExprModulo(node: ToyLang.Expr.Modulo): ToyLangIndexed.Expr  {
        val new_operands = transformExprModulo_operands(node)
        val new_metas = transformExprModulo_metas(node)
        return             ToyLangIndexed.Expr.Modulo(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprModulo_operands(node: ToyLang.Expr.Modulo) =
        node.operands.map { transformExpr(it) }
    open fun transformExprModulo_metas(node: ToyLang.Expr.Modulo) =
        transformMetas(node.metas)

    // Variant ExprCall
    open fun transformExprCall(node: ToyLang.Expr.Call): ToyLangIndexed.Expr  {
        val new_name = transformExprCall_name(node)
        val new_argument = transformExprCall_argument(node)
        val new_metas = transformExprCall_metas(node)
        return             ToyLangIndexed.Expr.Call(
                name = new_name,
                argument = new_argument,
                metas = new_metas
            )
    }
    open fun transformExprCall_name(node: ToyLang.Expr.Call) =
        transformSymbolPrimitive(node.name)
    open fun transformExprCall_argument(node: ToyLang.Expr.Call) =
        transformExpr(node.argument)
    open fun transformExprCall_metas(node: ToyLang.Expr.Call) =
        transformMetas(node.metas)

    // Variant ExprLet
    abstract fun transformExprLet(node: ToyLang.Expr.Let): ToyLangIndexed.Expr
    // Variant ExprFunction
    open fun transformExprFunction(node: ToyLang.Expr.Function): ToyLangIndexed.Expr  {
        val new_varName = transformExprFunction_varName(node)
        val new_body = transformExprFunction_body(node)
        val new_metas = transformExprFunction_metas(node)
        return             ToyLangIndexed.Expr.Function(
                varName = new_varName,
                body = new_body,
                metas = new_metas
            )
    }
    open fun transformExprFunction_varName(node: ToyLang.Expr.Function) =
        transformSymbolPrimitive(node.varName)
    open fun transformExprFunction_body(node: ToyLang.Expr.Function) =
        transformExpr(node.body)
    open fun transformExprFunction_metas(node: ToyLang.Expr.Function) =
        transformMetas(node.metas)

}
abstract class ToyLangIndexedToToyLangVisitorTransform : DomainVisitorTransformBase() {
    //////////////////////////////////////
    // Sum Type: Expr
    //////////////////////////////////////
    open fun transformExpr(node: ToyLangIndexed.Expr): ToyLang.Expr =
        when(node) {
            is ToyLangIndexed.Expr.Lit -> transformExprLit(node)
            is ToyLangIndexed.Expr.Not -> transformExprNot(node)
            is ToyLangIndexed.Expr.Plus -> transformExprPlus(node)
            is ToyLangIndexed.Expr.Minus -> transformExprMinus(node)
            is ToyLangIndexed.Expr.Times -> transformExprTimes(node)
            is ToyLangIndexed.Expr.Divide -> transformExprDivide(node)
            is ToyLangIndexed.Expr.Modulo -> transformExprModulo(node)
            is ToyLangIndexed.Expr.Call -> transformExprCall(node)
            is ToyLangIndexed.Expr.Function -> transformExprFunction(node)
            is ToyLangIndexed.Expr.Variable -> transformExprVariable(node)
            is ToyLangIndexed.Expr.Let -> transformExprLet(node)
        }
    // Variant ExprLit
    open fun transformExprLit(node: ToyLangIndexed.Expr.Lit): ToyLang.Expr  {
        val new_value = transformExprLit_value(node)
        val new_metas = transformExprLit_metas(node)
        return             ToyLang.Expr.Lit(
                value = new_value,
                metas = new_metas
            )
    }
    open fun transformExprLit_value(node: ToyLangIndexed.Expr.Lit) =
        transformAnyElement(node.value)
    open fun transformExprLit_metas(node: ToyLangIndexed.Expr.Lit) =
        transformMetas(node.metas)

    // Variant ExprNot
    open fun transformExprNot(node: ToyLangIndexed.Expr.Not): ToyLang.Expr  {
        val new_expr = transformExprNot_expr(node)
        val new_metas = transformExprNot_metas(node)
        return             ToyLang.Expr.Not(
                expr = new_expr,
                metas = new_metas
            )
    }
    open fun transformExprNot_expr(node: ToyLangIndexed.Expr.Not) =
        transformExpr(node.expr)
    open fun transformExprNot_metas(node: ToyLangIndexed.Expr.Not) =
        transformMetas(node.metas)

    // Variant ExprPlus
    open fun transformExprPlus(node: ToyLangIndexed.Expr.Plus): ToyLang.Expr  {
        val new_operands = transformExprPlus_operands(node)
        val new_metas = transformExprPlus_metas(node)
        return             ToyLang.Expr.Plus(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprPlus_operands(node: ToyLangIndexed.Expr.Plus) =
        node.operands.map { transformExpr(it) }
    open fun transformExprPlus_metas(node: ToyLangIndexed.Expr.Plus) =
        transformMetas(node.metas)

    // Variant ExprMinus
    open fun transformExprMinus(node: ToyLangIndexed.Expr.Minus): ToyLang.Expr  {
        val new_operands = transformExprMinus_operands(node)
        val new_metas = transformExprMinus_metas(node)
        return             ToyLang.Expr.Minus(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprMinus_operands(node: ToyLangIndexed.Expr.Minus) =
        node.operands.map { transformExpr(it) }
    open fun transformExprMinus_metas(node: ToyLangIndexed.Expr.Minus) =
        transformMetas(node.metas)

    // Variant ExprTimes
    open fun transformExprTimes(node: ToyLangIndexed.Expr.Times): ToyLang.Expr  {
        val new_operands = transformExprTimes_operands(node)
        val new_metas = transformExprTimes_metas(node)
        return             ToyLang.Expr.Times(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprTimes_operands(node: ToyLangIndexed.Expr.Times) =
        node.operands.map { transformExpr(it) }
    open fun transformExprTimes_metas(node: ToyLangIndexed.Expr.Times) =
        transformMetas(node.metas)

    // Variant ExprDivide
    open fun transformExprDivide(node: ToyLangIndexed.Expr.Divide): ToyLang.Expr  {
        val new_operands = transformExprDivide_operands(node)
        val new_metas = transformExprDivide_metas(node)
        return             ToyLang.Expr.Divide(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprDivide_operands(node: ToyLangIndexed.Expr.Divide) =
        node.operands.map { transformExpr(it) }
    open fun transformExprDivide_metas(node: ToyLangIndexed.Expr.Divide) =
        transformMetas(node.metas)

    // Variant ExprModulo
    open fun transformExprModulo(node: ToyLangIndexed.Expr.Modulo): ToyLang.Expr  {
        val new_operands = transformExprModulo_operands(node)
        val new_metas = transformExprModulo_metas(node)
        return             ToyLang.Expr.Modulo(
                operands = new_operands,
                metas = new_metas
            )
    }
    open fun transformExprModulo_operands(node: ToyLangIndexed.Expr.Modulo) =
        node.operands.map { transformExpr(it) }
    open fun transformExprModulo_metas(node: ToyLangIndexed.Expr.Modulo) =
        transformMetas(node.metas)

    // Variant ExprCall
    open fun transformExprCall(node: ToyLangIndexed.Expr.Call): ToyLang.Expr  {
        val new_name = transformExprCall_name(node)
        val new_argument = transformExprCall_argument(node)
        val new_metas = transformExprCall_metas(node)
        return             ToyLang.Expr.Call(
                name = new_name,
                argument = new_argument,
                metas = new_metas
            )
    }
    open fun transformExprCall_name(node: ToyLangIndexed.Expr.Call) =
        transformSymbolPrimitive(node.name)
    open fun transformExprCall_argument(node: ToyLangIndexed.Expr.Call) =
        transformExpr(node.argument)
    open fun transformExprCall_metas(node: ToyLangIndexed.Expr.Call) =
        transformMetas(node.metas)

    // Variant ExprFunction
    open fun transformExprFunction(node: ToyLangIndexed.Expr.Function): ToyLang.Expr  {
        val new_varName = transformExprFunction_varName(node)
        val new_body = transformExprFunction_body(node)
        val new_metas = transformExprFunction_metas(node)
        return             ToyLang.Expr.Function(
                varName = new_varName,
                body = new_body,
                metas = new_metas
            )
    }
    open fun transformExprFunction_varName(node: ToyLangIndexed.Expr.Function) =
        transformSymbolPrimitive(node.varName)
    open fun transformExprFunction_body(node: ToyLangIndexed.Expr.Function) =
        transformExpr(node.body)
    open fun transformExprFunction_metas(node: ToyLangIndexed.Expr.Function) =
        transformMetas(node.metas)

    // Variant ExprVariable
    abstract fun transformExprVariable(node: ToyLangIndexed.Expr.Variable): ToyLang.Expr
    // Variant ExprLet
    abstract fun transformExprLet(node: ToyLangIndexed.Expr.Let): ToyLang.Expr
}
