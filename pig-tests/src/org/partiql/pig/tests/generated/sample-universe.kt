/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",  "USELESS_ELVIS")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class ToyLang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): ToyLangNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNode =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: Expr 
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Lit =
            ToyLang.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name.asPrimitive(),
                metas = metas)
        
        fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Not =
            ToyLang.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name,
                value = value,
                body = body,
                metas = metas)
        
        
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLang types. */
    abstract class ToyLangNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNode() {
    
        class Lit(
            val value: com.amazon.ionelement.api.IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLang.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    ToyLang.Expr.Variable(
                        name,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLang.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLang.Expr.Let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
    
    
    
    open class InspectingVisitor : InspectingDomainVisitorBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun visitExpr(node: ToyLang.Expr) { }
        open fun visitExprLit(node: ToyLang.Expr.Lit) { }
        open fun visitExprVariable(node: ToyLang.Expr.Variable) { }
        open fun visitExprNot(node: ToyLang.Expr.Not) { }
        open fun visitExprPlus(node: ToyLang.Expr.Plus) { }
        open fun visitExprMinus(node: ToyLang.Expr.Minus) { }
        open fun visitExprTimes(node: ToyLang.Expr.Times) { }
        open fun visitExprDivide(node: ToyLang.Expr.Divide) { }
        open fun visitExprModulo(node: ToyLang.Expr.Modulo) { }
        open fun visitExprCall(node: ToyLang.Expr.Call) { }
        open fun visitExprLet(node: ToyLang.Expr.Let) { }
        open fun visitExprFunction(node: ToyLang.Expr.Function) { }
    }
    
    open class InspectingWalker(
        visitor: ToyLang.InspectingVisitor
    ) : InspectingDomainWalkerBase<InspectingVisitor>(visitor) {
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLang.Expr) {
            visitor.visitExpr(node)
            when(node) {
                is ToyLang.Expr.Lit -> walkExprLit(node)
                is ToyLang.Expr.Variable -> walkExprVariable(node)
                is ToyLang.Expr.Not -> walkExprNot(node)
                is ToyLang.Expr.Plus -> walkExprPlus(node)
                is ToyLang.Expr.Minus -> walkExprMinus(node)
                is ToyLang.Expr.Times -> walkExprTimes(node)
                is ToyLang.Expr.Divide -> walkExprDivide(node)
                is ToyLang.Expr.Modulo -> walkExprModulo(node)
                is ToyLang.Expr.Call -> walkExprCall(node)
                is ToyLang.Expr.Let -> walkExprLet(node)
                is ToyLang.Expr.Function -> walkExprFunction(node)
            }
        }
    
        open fun walkExprLit(node: ToyLang.Expr.Lit) {
            visitor.visitExprLit(node)
            walkIonElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLang.Expr.Variable) {
            visitor.visitExprVariable(node)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLang.Expr.Not) {
            visitor.visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLang.Expr.Plus) {
            visitor.visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLang.Expr.Minus) {
            visitor.visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLang.Expr.Times) {
            visitor.visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLang.Expr.Divide) {
            visitor.visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLang.Expr.Modulo) {
            visitor.visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLang.Expr.Call) {
            visitor.visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLang.Expr.Let) {
            visitor.visitExprLet(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLang.Expr.Function) {
            visitor.visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
}

class ToyLangNameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNamelessNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): ToyLangNamelessNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNamelessNode =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: Expr 
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Lit =
            ToyLangNameless.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Not =
            ToyLangNameless.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Plus =
            ToyLangNameless.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Plus =
            ToyLangNameless.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Minus =
            ToyLangNameless.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Minus =
            ToyLangNameless.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Times =
            ToyLangNameless.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Times =
            ToyLangNameless.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Divide =
            ToyLangNameless.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Divide =
            ToyLangNameless.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Modulo =
            ToyLangNameless.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Modulo =
            ToyLangNameless.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Call =
            ToyLangNameless.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Call =
            ToyLangNameless.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Function =
            ToyLangNameless.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Function =
            ToyLangNameless.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
        
        
        fun variable(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Variable =
            ToyLangNameless.Expr.Variable(
                index = index.asPrimitive(),
                metas = metas)
        
        fun variable_(
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Variable =
            ToyLangNameless.Expr.Variable(
                index = index,
                metas = metas)
        
        
        fun let(
            index: Long,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Let =
            ToyLangNameless.Expr.Let(
                index = index.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            index: org.partiql.pig.runtime.LongPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Let =
            ToyLangNameless.Expr.Let(
                index = index,
                value = value,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLangNameless types. */
    abstract class ToyLangNamelessNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNamelessNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNamelessNode() {
    
        class Lit(
            val value: com.amazon.ionelement.api.IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val index: org.partiql.pig.runtime.LongPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    index = index,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    index.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (index != other.index) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNamelessNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNamelessNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLangNameless.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLangNameless.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    ToyLangNameless.Expr.Variable(
                        index,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLangNameless.Expr.Let(
                        index,
                        value,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_nameless'")
            }
        }
    }
    
    
    
    open class InspectingVisitor : InspectingDomainVisitorBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun visitExpr(node: ToyLangNameless.Expr) { }
        open fun visitExprLit(node: ToyLangNameless.Expr.Lit) { }
        open fun visitExprNot(node: ToyLangNameless.Expr.Not) { }
        open fun visitExprPlus(node: ToyLangNameless.Expr.Plus) { }
        open fun visitExprMinus(node: ToyLangNameless.Expr.Minus) { }
        open fun visitExprTimes(node: ToyLangNameless.Expr.Times) { }
        open fun visitExprDivide(node: ToyLangNameless.Expr.Divide) { }
        open fun visitExprModulo(node: ToyLangNameless.Expr.Modulo) { }
        open fun visitExprCall(node: ToyLangNameless.Expr.Call) { }
        open fun visitExprFunction(node: ToyLangNameless.Expr.Function) { }
        open fun visitExprVariable(node: ToyLangNameless.Expr.Variable) { }
        open fun visitExprLet(node: ToyLangNameless.Expr.Let) { }
    }
    
    open class InspectingWalker(
        visitor: ToyLangNameless.InspectingVisitor
    ) : InspectingDomainWalkerBase<InspectingVisitor>(visitor) {
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLangNameless.Expr) {
            visitor.visitExpr(node)
            when(node) {
                is ToyLangNameless.Expr.Lit -> walkExprLit(node)
                is ToyLangNameless.Expr.Not -> walkExprNot(node)
                is ToyLangNameless.Expr.Plus -> walkExprPlus(node)
                is ToyLangNameless.Expr.Minus -> walkExprMinus(node)
                is ToyLangNameless.Expr.Times -> walkExprTimes(node)
                is ToyLangNameless.Expr.Divide -> walkExprDivide(node)
                is ToyLangNameless.Expr.Modulo -> walkExprModulo(node)
                is ToyLangNameless.Expr.Call -> walkExprCall(node)
                is ToyLangNameless.Expr.Function -> walkExprFunction(node)
                is ToyLangNameless.Expr.Variable -> walkExprVariable(node)
                is ToyLangNameless.Expr.Let -> walkExprLet(node)
            }
        }
    
        open fun walkExprLit(node: ToyLangNameless.Expr.Lit) {
            visitor.visitExprLit(node)
            walkIonElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLangNameless.Expr.Not) {
            visitor.visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLangNameless.Expr.Plus) {
            visitor.visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLangNameless.Expr.Minus) {
            visitor.visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLangNameless.Expr.Times) {
            visitor.visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLangNameless.Expr.Divide) {
            visitor.visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLangNameless.Expr.Modulo) {
            visitor.visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLangNameless.Expr.Call) {
            visitor.visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLangNameless.Expr.Function) {
            visitor.visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLangNameless.Expr.Variable) {
            visitor.visitExprVariable(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLangNameless.Expr.Let) {
            visitor.visitExprLet(node)
            walkLongPrimitive(node.index)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
}

class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: TestDomainNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPair =
            TestDomain.IonPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonSymbolPair =
            TestDomain.IonSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun variadicMin0(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = metas)
        
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = metas)
        
        
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = metas)
        
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = metas)
        
        
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
        
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = metas)
        
        
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = metas)
        
        fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = metas)
        
        
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = metas)
        
        fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive? = null,
            second: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = metas)
        
        
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = metas)
        
        fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
        
        
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSumTriplet =
            TestDomain.TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = metas)
        
        
        // Variants for Sum: Answer 
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.No =
            TestDomain.Answer.No(
                metas = metas)
        
        
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.Yes =
            TestDomain.Answer.Yes(
                metas = metas)
        
        
        // Variants for Sum: SumWithRecord 
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        // Variants for Sum: TestSum 
        fun one(
            a: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a.asPrimitive(),
                metas = metas)
        
        fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a,
                metas = metas)
        
        
        fun two(
            a: Long,
            b: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                metas = metas)
        
        fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a,
                b = b,
                metas = metas)
        
        
        fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                c = c.asPrimitive(),
                metas = metas)
        
        fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        // Variants for Sum: Entity 
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Slug =
            TestDomain.Entity.Slug(
                metas = metas)
        
        
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = metas)
        
        fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id,
                metas = metas)
        
        
        fun human(
            firstName: String,
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class IntPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: com.amazon.ionelement.api.IonElement,
        val second: com.amazon.ionelement.api.IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val first: com.amazon.ionelement.api.IonElement,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val first: com.amazon.ionelement.api.IonElement,
        val second: com.amazon.ionelement.api.IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: org.partiql.pig.runtime.LongPrimitive?,
        val second: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: org.partiql.pig.runtime.LongPrimitive,
        val anotherField: org.partiql.pig.runtime.SymbolPrimitive,
        val optionalField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: org.partiql.pig.runtime.LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class TestSumTriplet(
        val a: TestSum,
        val b: TestSum,
        val c: TestSum,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("test_sum_triplet"),
                a.toIonElement(),
                b.toIonElement(),
                c.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TestSumTriplet::class.java) return false
    
            other as TestSumTriplet
            if (a != other.a) return false
            if (b != other.b) return false
            if (c != other.c) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = a.hashCode()
            hc = 31 * hc + b.hashCode()
            hc = 31 * hc + c.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer : TestDomainNode() {
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class SumWithRecord : TestDomainNode() {
    
        class VariantWithRecord(
            val value: org.partiql.pig.runtime.LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class TestSum : TestDomainNode() {
    
        class One(
            val a: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): One =
                One(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("one"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != One::class.java) return false
        
                other as One
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Two(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("two"),
                    a.toIonElement(),
                    b.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Two::class.java) return false
        
                other as Two
                if (a != other.a) return false
                if (b != other.b) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Three(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            val c: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("three"),
                    a.toIonElement(),
                    b.toIonElement(),
                    c.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Three::class.java) return false
        
                other as Three
                if (a != other.a) return false
                if (b != other.b) return false
                if (c != other.c) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc = 31 * hc + c.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class Entity : TestDomainNode() {
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class Android(
            val id: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: org.partiql.pig.runtime.SymbolPrimitive,
            val lastName: org.partiql.pig.runtime.SymbolPrimitive,
            val title: org.partiql.pig.runtime.SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = firstName.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "test_sum_triplet" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).transformExpect<TestSum>()
                    val b = sexp.getRequired(1).transformExpect<TestSum>()
                    val c = sexp.getRequired(2).transformExpect<TestSum>()
                    TestDomain.TestSumTriplet(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'TestSum'
                //////////////////////////////////////
                "one" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.TestSum.One(
                        a,
                        metas = sexp.metas)
                }
                "two" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.TestSum.Two(
                        a,
                        b,
                        metas = sexp.metas)
                }
                "three" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    val c = sexp.getRequired(2).toLongPrimitive()
                    TestDomain.TestSum.Three(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
    
    
    
    open class InspectingVisitor : InspectingDomainVisitorBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitIntPair(node: TestDomain.IntPair) { }
        open fun visitSymbolPair(node: TestDomain.SymbolPair) { }
        open fun visitIonPair(node: TestDomain.IonPair) { }
        open fun visitIntSymbolPair(node: TestDomain.IntSymbolPair) { }
        open fun visitSymbolIntPair(node: TestDomain.SymbolIntPair) { }
        open fun visitIonIntPair(node: TestDomain.IonIntPair) { }
        open fun visitIonSymbolPair(node: TestDomain.IonSymbolPair) { }
        open fun visitIntPairPair(node: TestDomain.IntPairPair) { }
        open fun visitSymbolPairPair(node: TestDomain.SymbolPairPair) { }
        open fun visitIonPairPair(node: TestDomain.IonPairPair) { }
        open fun visitRecursivePair(node: TestDomain.RecursivePair) { }
        open fun visitAnswerPair(node: TestDomain.AnswerPair) { }
        open fun visitAnswerIntPair(node: TestDomain.AnswerIntPair) { }
        open fun visitIntAnswerPair(node: TestDomain.IntAnswerPair) { }
        open fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) { }
        open fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) { }
        open fun visitVariadicMin0(node: TestDomain.VariadicMin0) { }
        open fun visitVariadicMin1(node: TestDomain.VariadicMin1) { }
        open fun visitElementVariadic(node: TestDomain.ElementVariadic) { }
        open fun visitOptional1(node: TestDomain.Optional1) { }
        open fun visitOptional2(node: TestDomain.Optional2) { }
        open fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord) { }
        open fun visitProductWithRecord(node: TestDomain.ProductWithRecord) { }
        open fun visitTestSumTriplet(node: TestDomain.TestSumTriplet) { }
        open fun visitEntityPair(node: TestDomain.EntityPair) { }
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun visitAnswer(node: TestDomain.Answer) { }
        open fun visitAnswerNo(node: TestDomain.Answer.No) { }
        open fun visitAnswerYes(node: TestDomain.Answer.Yes) { }
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun visitSumWithRecord(node: TestDomain.SumWithRecord) { }
        open fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) { }
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun visitTestSum(node: TestDomain.TestSum) { }
        open fun visitTestSumOne(node: TestDomain.TestSum.One) { }
        open fun visitTestSumTwo(node: TestDomain.TestSum.Two) { }
        open fun visitTestSumThree(node: TestDomain.TestSum.Three) { }
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun visitEntity(node: TestDomain.Entity) { }
        open fun visitEntitySlug(node: TestDomain.Entity.Slug) { }
        open fun visitEntityAndroid(node: TestDomain.Entity.Android) { }
        open fun visitEntityHuman(node: TestDomain.Entity.Human) { }
    }
    
    open class InspectingWalker(
        visitor: TestDomain.InspectingVisitor
    ) : InspectingDomainWalkerBase<InspectingVisitor>(visitor) {
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkIntPair(node: TestDomain.IntPair) {
            visitor.visitIntPair(node)
            walkLongPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair) {
            visitor.visitSymbolPair(node)
            walkSymbolPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPair(node: TestDomain.IonPair) {
            visitor.visitIonPair(node)
            walkIonElement(node.first)
            walkIonElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair) {
            visitor.visitIntSymbolPair(node)
            walkLongPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair) {
            visitor.visitSymbolIntPair(node)
            walkSymbolPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair) {
            visitor.visitIonIntPair(node)
            walkIonElement(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair) {
            visitor.visitIonSymbolPair(node)
            walkIonElement(node.first)
            walkIonElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair) {
            visitor.visitIntPairPair(node)
            walkIntPair(node.first)
            walkIntPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair) {
            visitor.visitSymbolPairPair(node)
            walkSymbolPair(node.first)
            walkSymbolPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair) {
            visitor.visitIonPairPair(node)
            walkIonPair(node.first)
            walkIonPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair) {
            visitor.visitRecursivePair(node)
            walkLongPrimitive(node.first)
            node.second?.let { walkRecursivePair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair) {
            visitor.visitAnswerPair(node)
            walkAnswer(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair) {
            visitor.visitAnswerIntPair(node)
            walkAnswer(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair) {
            visitor.visitIntAnswerPair(node)
            walkLongPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) {
            visitor.visitSymbolAnswerPair(node)
            walkSymbolPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) {
            visitor.visitAnswerSymbolPair(node)
            walkAnswer(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0) {
            visitor.visitVariadicMin0(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1) {
            visitor.visitVariadicMin1(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic) {
            visitor.visitElementVariadic(node)
            walkSymbolPrimitive(node.name)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional1(node: TestDomain.Optional1) {
            visitor.visitOptional1(node)
            node.value?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional2(node: TestDomain.Optional2) {
            visitor.visitOptional2(node)
            node.first?.let { walkLongPrimitive(it) }
            node.second?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord) {
            visitor.visitDomainLevelRecord(node)
            walkLongPrimitive(node.someField)
            walkSymbolPrimitive(node.anotherField)
            node.optionalField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord) {
            visitor.visitProductWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet) {
            visitor.visitTestSumTriplet(node)
            walkTestSum(node.a)
            walkTestSum(node.b)
            walkTestSum(node.c)
            walkMetas(node.metas)
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair) {
            visitor.visitEntityPair(node)
            walkEntity(node.first)
            walkEntity(node.second)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer) {
            visitor.visitAnswer(node)
            when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node)
                is TestDomain.Answer.Yes -> walkAnswerYes(node)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No) {
            visitor.visitAnswerNo(node)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes) {
            visitor.visitAnswerYes(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord) {
            visitor.visitSumWithRecord(node)
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) {
            visitor.visitSumWithRecordVariantWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum) {
            visitor.visitTestSum(node)
            when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node)
                is TestDomain.TestSum.Three -> walkTestSumThree(node)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One) {
            visitor.visitTestSumOne(node)
            walkLongPrimitive(node.a)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two) {
            visitor.visitTestSumTwo(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three) {
            visitor.visitTestSumThree(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkLongPrimitive(node.c)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity) {
            visitor.visitEntity(node)
            when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node)
                is TestDomain.Entity.Android -> walkEntityAndroid(node)
                is TestDomain.Entity.Human -> walkEntityHuman(node)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug) {
            visitor.visitEntitySlug(node)
            walkMetas(node.metas)
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android) {
            visitor.visitEntityAndroid(node)
            walkLongPrimitive(node.id)
            walkMetas(node.metas)
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human) {
            visitor.visitEntityHuman(node)
            walkSymbolPrimitive(node.firstName)
            walkSymbolPrimitive(node.lastName)
            node.title?.let { walkSymbolPrimitive(it) }
            node.parent?.let { walkEntity(it) }
            walkMetas(node.metas)
        }
    
    }
}

class MultiWordDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: MultiWordDomainNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): MultiWordDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): MultiWordDomainNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun aaaAaa(
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAaa =
            MultiWordDomain.AaaAaa(
                metas = metas)
        
        
        fun aaaAab(
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField?.asPrimitive(),
                metas = metas)
        
        fun aaaAab_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField,
                metas = metas)
        
        
        fun aaaAac(
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        fun aaaAac_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        fun aaaAad(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAad_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField,
                metas = metas)
        
        fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAad_(
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.toList(),
                metas = metas)
        
        
        fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAae_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField,
                metas = metas)
        
        fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAae_(
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                metas = metas)
        
        fun aabAaa_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField,
                cField = cField,
                metas = metas)
        
        
        fun aabAab(
            bField: Long,
            cField: String,
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                metas = metas)
        
        fun aabAab_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        
        fun aabAac(
            bField: Long,
            cField: String,
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        fun aabAac_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField.toList(),
                metas = metas)
        
        
        fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        fun rrr(
            aField: Long,
            bbbField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField.asPrimitive(),
                bbbField = bbbField.asPrimitive(),
                metas = metas)
        
        fun rrr_(
            aField: org.partiql.pig.runtime.LongPrimitive,
            bbbField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas)
        
        
        // Variants for Sum: SssTtt 
        fun lll(
            uField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField.asPrimitive(),
                metas = metas)
        
        fun lll_(
            uField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField,
                metas = metas)
        
        
        fun mmm(
            vField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField.asPrimitive(),
                metas = metas)
        
        fun mmm_(
            vField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField,
                metas = metas)
    }
    
    /** Base class for all MultiWordDomain types. */
    abstract class MultiWordDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): MultiWordDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class AaaAaa(
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAaa =
            AaaAaa(
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aaa"),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAaa::class.java) return false
    
            return true
        }
    
        override fun hashCode(): Int = 0
    }
    
    class AaaAab(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aab"),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAab::class.java) return false
    
            other as AaaAab
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAac(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aac"),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAac::class.java) return false
    
            other as AaaAac
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAad(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aad"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAad::class.java) return false
    
            other as AaaAad
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAae(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aae"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAae::class.java) return false
    
            other as AaaAae
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAaa(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aaa"),
                bField.toIonElement(),
                cField.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAaa::class.java) return false
    
            other as AabAaa
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAab(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aab"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAab::class.java) return false
    
            other as AabAab
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAac(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aac"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAac::class.java) return false
    
            other as AabAac
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAad(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aad"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAad::class.java) return false
    
            other as AabAad
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAae(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aae"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAae::class.java) return false
    
            other as AabAae
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Rrr(
        val aField: org.partiql.pig.runtime.LongPrimitive,
        val bbbField: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("rrr"),
                aField?.let { ionSexpOf(ionSymbol("a_field"), it.toIonElement()) },
                bbbField?.let { ionSexpOf(ionSymbol("b_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Rrr::class.java) return false
    
            other as Rrr
            if (aField != other.aField) return false
            if (bbbField != other.bbbField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = aField.hashCode()
            hc = 31 * hc + bbbField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SssTtt : MultiWordDomainNode() {
    
        class Lll(
            val uField: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lll =
                Lll(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lll"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lll::class.java) return false
        
                other as Lll
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Mmm(
            val vField: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("mmm"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Mmm::class.java) return false
        
                other as Mmm
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<MultiWordDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): MultiWordDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "aaa_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    MultiWordDomain.AaaAaa(
                        metas = sexp.metas)
                }
                "aaa_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    MultiWordDomain.AaaAab(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    val eField = sexp.getOptional(1)?.toSymbolPrimitive()
                    MultiWordDomain.AaaAac(
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aaa_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAad(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAae(
                        dField,
                        metas = sexp.metas)
                }
                "aab_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    MultiWordDomain.AabAaa(
                        bField,
                        cField,
                        metas = sexp.metas)
                }
                "aab_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    MultiWordDomain.AabAab(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    val eField = sexp.getOptional(3)?.toSymbolPrimitive()
                    MultiWordDomain.AabAac(
                        bField,
                        cField,
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aab_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAad(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAae(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "rrr" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val aField = ir.processRequiredField("a_field") { it.toLongPrimitive() }
                    val bbbField = ir.processRequiredField("bbb_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Rrr(aField, bbbField, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtt'
                //////////////////////////////////////
                "lll" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).toLongPrimitive()
                    MultiWordDomain.SssTtt.Lll(
                        uField,
                        metas = sexp.metas)
                }
                "mmm" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).toSymbolPrimitive()
                    MultiWordDomain.SssTtt.Mmm(
                        vField,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'multi_word_domain'")
            }
        }
    }
    
    
    
    open class InspectingVisitor : InspectingDomainVisitorBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitAaaAaa(node: MultiWordDomain.AaaAaa) { }
        open fun visitAaaAab(node: MultiWordDomain.AaaAab) { }
        open fun visitAaaAac(node: MultiWordDomain.AaaAac) { }
        open fun visitAaaAad(node: MultiWordDomain.AaaAad) { }
        open fun visitAaaAae(node: MultiWordDomain.AaaAae) { }
        open fun visitAabAaa(node: MultiWordDomain.AabAaa) { }
        open fun visitAabAab(node: MultiWordDomain.AabAab) { }
        open fun visitAabAac(node: MultiWordDomain.AabAac) { }
        open fun visitAabAad(node: MultiWordDomain.AabAad) { }
        open fun visitAabAae(node: MultiWordDomain.AabAae) { }
        open fun visitRrr(node: MultiWordDomain.Rrr) { }
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun visitSssTtt(node: MultiWordDomain.SssTtt) { }
        open fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll) { }
        open fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) { }
    }
    
    open class InspectingWalker(
        visitor: MultiWordDomain.InspectingVisitor
    ) : InspectingDomainWalkerBase<InspectingVisitor>(visitor) {
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa) {
            visitor.visitAaaAaa(node)
            walkMetas(node.metas)
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab) {
            visitor.visitAaaAab(node)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac) {
            visitor.visitAaaAac(node)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad) {
            visitor.visitAaaAad(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae) {
            visitor.visitAaaAae(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa) {
            visitor.visitAabAaa(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            walkMetas(node.metas)
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab) {
            visitor.visitAabAab(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac) {
            visitor.visitAabAac(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad) {
            visitor.visitAabAad(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae) {
            visitor.visitAabAae(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr) {
            visitor.visitRrr(node)
            walkLongPrimitive(node.aField)
            walkLongPrimitive(node.bbbField)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt) {
            visitor.visitSssTtt(node)
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll) {
            visitor.visitSssTttLll(node)
            walkLongPrimitive(node.uField)
            walkMetas(node.metas)
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) {
            visitor.visitSssTttMmm(node)
            walkSymbolPrimitive(node.vField)
            walkMetas(node.metas)
        }
    
    }
}

class PartiqlBasic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: PartiqlBasicNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): PartiqlBasicNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): PartiqlBasicNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun exprPair(
            first: Expr,
            second: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ExprPair =
            PartiqlBasic.ExprPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun groupByItem(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        fun groupByItem_(
            value: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        fun groupByList(
            items: kotlin.collections.List<GroupByItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = items,
                metas = metas)
        
        fun groupByList(
            items0: GroupByItem,
            vararg items: GroupByItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        fun groupBy(
            items: GroupByList,
            groupAsAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias?.asPrimitive(),
                metas = metas)
        
        fun groupBy_(
            items: GroupByList,
            groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas)
        
        
        // Variants for Sum: Projection 
        fun projectList(
            items: kotlin.collections.List<ProjectItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = items,
                metas = metas)
        
        fun projectList(
            items0: ProjectItem,
            vararg items: ProjectItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        fun projectValue(
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectValue =
            PartiqlBasic.Projection.ProjectValue(
                value = value,
                metas = metas)
        
        
        // Variants for Sum: ProjectItem 
        fun projectAll(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectAll =
            PartiqlBasic.ProjectItem.ProjectAll(
                metas = metas)
        
        
        fun projectExpr(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        fun projectExpr_(
            value: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        // Variants for Sum: JoinType 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Inner =
            PartiqlBasic.JoinType.Inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Left =
            PartiqlBasic.JoinType.Left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Right =
            PartiqlBasic.JoinType.Right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Outer =
            PartiqlBasic.JoinType.Outer(
                metas = metas)
        
        
        // Variants for Sum: FromSource 
        fun scan(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            atAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            byAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = metas)
        
        
        fun join(
            type: JoinType,
            left: FromSource,
            right: FromSource,
            predicate: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Join =
            PartiqlBasic.FromSource.Join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = metas)
        
        
        // Variants for Sum: CaseSensitivity 
        fun caseSensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseSensitive =
            PartiqlBasic.CaseSensitivity.CaseSensitive(
                metas = metas)
        
        
        fun caseInsensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseInsensitive =
            PartiqlBasic.CaseSensitivity.CaseInsensitive(
                metas = metas)
        
        
        // Variants for Sum: ScopeQualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Unqualified =
            PartiqlBasic.ScopeQualifier.Unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Qualified =
            PartiqlBasic.ScopeQualifier.Qualified(
                metas = metas)
        
        
        // Variants for Sum: SetQuantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.All =
            PartiqlBasic.SetQuantifier.All(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.Distinct =
            PartiqlBasic.SetQuantifier.Distinct(
                metas = metas)
        
        
        // Variants for Sum: PathElement 
        fun pathExpr(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathExpr =
            PartiqlBasic.PathElement.PathExpr(
                expr = expr,
                metas = metas)
        
        
        fun pathWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathWildcard =
            PartiqlBasic.PathElement.PathWildcard(
                metas = metas)
        
        
        fun pathUnpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathUnpivot =
            PartiqlBasic.PathElement.PathUnpivot(
                metas = metas)
        
        
        // Variants for Sum: Expr 
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Lit =
            PartiqlBasic.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun id(
            name: String,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name.asPrimitive(),
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        fun id_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name,
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Not =
            PartiqlBasic.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun concat(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = operands,
                metas = metas)
        
        fun concat(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun like(
            left: Expr,
            right: Expr,
            escape: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Like =
            PartiqlBasic.Expr.Like(
                left = left,
                right = right,
                escape = escape,
                metas = metas)
        
        
        fun between(
            value: Expr,
            from: Expr,
            to: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Between =
            PartiqlBasic.Expr.Between(
                value = value,
                from = from,
                to = to,
                metas = metas)
        
        
        fun path(
            root: Expr,
            elements: kotlin.collections.List<PathElement>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = elements,
                metas = metas)
        
        fun path(
            root: Expr,
            elements0: PathElement,
            vararg elements: PathElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = listOf(elements0) + elements.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = args,
                metas = metas)
        
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = args,
                metas = metas)
        
        fun call(
            name: String,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        
        fun callAgg(
            name: String,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name.asPrimitive(),
                setQuantifier = setQuantifier,
                arg = arg,
                metas = metas)
        
        fun callAgg_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name,
                setQuantifier = setQuantifier,
                arg = arg,
                metas = metas)
        
        
        fun simpleCase(
            value: Expr,
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = branches,
                metas = metas)
        
        fun simpleCase(
            value: Expr,
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        fun searchedCase(
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = branches,
                metas = metas)
        
        fun searchedCase(
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        fun struct(
            fields: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields,
                metas = metas)
        
        fun struct(
            vararg fields: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields.toList(),
                metas = metas)
        
        
        fun bag(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values,
                metas = metas)
        
        fun bag(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values.toList(),
                metas = metas)
        
        
        fun list(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values,
                metas = metas)
        
        fun list(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values.toList(),
                metas = metas)
        
        
        fun select(
            setq: SetQuantifier? = null,
            project: Projection,
            from: FromSource,
            where: Expr? = null,
            group: GroupBy? = null,
            having: Expr? = null,
            limit: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Select =
            PartiqlBasic.Expr.Select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = metas)
    }
    
    /** Base class for all PartiqlBasic types. */
    abstract class PartiqlBasicNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): PartiqlBasicNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ExprPair(
        val first: Expr,
        val second: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPair::class.java) return false
    
            other as ExprPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByItem(
        val value: Expr,
        val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByItem =
            GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                value.toIonElement(),
                asAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByItem::class.java) return false
    
            other as GroupByItem
            if (value != other.value) return false
            if (asAlias != other.asAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + asAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByList(
        val items: kotlin.collections.List<GroupByItem>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByList =
            GroupByList(
                items = items,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *items.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByList::class.java) return false
    
            other as GroupByList
            if (items != other.items) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupBy(
        val items: GroupByList,
        val groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupBy =
            GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                items.toIonElement(),
                groupAsAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupBy::class.java) return false
    
            other as GroupBy
            if (items != other.items) return false
            if (groupAsAlias != other.groupAsAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc = 31 * hc + groupAsAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Projection : PartiqlBasicNode() {
    
        class ProjectList(
            val items: kotlin.collections.List<ProjectItem>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectList =
                ProjectList(
                    items = items,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *items.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectList::class.java) return false
        
                other as ProjectList
                if (items != other.items) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = items.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectValue(
            val value: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectValue::class.java) return false
        
                other as ProjectValue
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class ProjectItem : PartiqlBasicNode() {
    
        class ProjectAll(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectAll =
                ProjectAll(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectAll::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class ProjectExpr(
            val value: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectExpr =
                ProjectExpr(
                    value = value,
                    asAlias = asAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    value.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectExpr::class.java) return false
        
                other as ProjectExpr
                if (value != other.value) return false
                if (asAlias != other.asAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class JoinType : PartiqlBasicNode() {
    
        class Inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Inner =
                Inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Left =
                Left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class Right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Right =
                Right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class Outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Outer =
                Outer(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
    }
    
    sealed class FromSource : PartiqlBasicNode() {
    
        class Scan(
            val expr: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val atAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val byAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Scan::class.java) return false
        
                other as Scan
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Join(
            val type: JoinType,
            val left: FromSource,
            val right: FromSource,
            val predicate: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Join::class.java) return false
        
                other as Join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class CaseSensitivity : PartiqlBasicNode() {
    
        class CaseSensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseSensitive =
                CaseSensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseSensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class CaseInsensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseInsensitive =
                CaseInsensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseInsensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class ScopeQualifier : PartiqlBasicNode() {
    
        class Unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Unqualified =
                Unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class Qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Qualified =
                Qualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
    }
    
    sealed class SetQuantifier : PartiqlBasicNode() {
    
        class All(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): All =
                All(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != All::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class Distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Distinct =
                Distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
    }
    
    sealed class PathElement : PartiqlBasicNode() {
    
        class PathExpr(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathExpr =
                PathExpr(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathExpr::class.java) return false
        
                other as PathExpr
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class PathWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathWildcard =
                PathWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class PathUnpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathUnpivot =
                PathUnpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathUnpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
    }
    
    sealed class Expr : PartiqlBasicNode() {
    
        class Lit(
            val value: com.amazon.ionelement.api.IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Id(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val case: CaseSensitivity,
            val scopeQualifier: ScopeQualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Id =
                Id(
                    name = name,
                    case = case,
                    scopeQualifier = scopeQualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    scopeQualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Id::class.java) return false
        
                other as Id
                if (name != other.name) return false
                if (case != other.case) return false
                if (scopeQualifier != other.scopeQualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + scopeQualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Parameter(
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Parameter =
                Parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Parameter::class.java) return false
        
                other as Parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Concat(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Concat =
                Concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Concat::class.java) return false
        
                other as Concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Like(
            val left: Expr,
            val right: Expr,
            val escape: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Like =
                Like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    left.toIonElement(),
                    right.toIonElement(),
                    escape.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Like::class.java) return false
        
                other as Like
                if (left != other.left) return false
                if (right != other.right) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Between(
            val value: Expr,
            val from: Expr,
            val to: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Between::class.java) return false
        
                other as Between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Path(
            val root: Expr,
            val elements: kotlin.collections.List<PathElement>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Path =
                Path(
                    root = root,
                    elements = elements,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *elements.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Path::class.java) return false
        
                other as Path
                if (root != other.root) return false
                if (elements != other.elements) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = root.hashCode()
                hc = 31 * hc + elements.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CallAgg(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val setQuantifier: SetQuantifier,
            val arg: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CallAgg =
                CallAgg(
                    name = name,
                    setQuantifier = setQuantifier,
                    arg = arg,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    name.toIonElement(),
                    setQuantifier.toIonElement(),
                    arg.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CallAgg::class.java) return false
        
                other as CallAgg
                if (name != other.name) return false
                if (setQuantifier != other.setQuantifier) return false
                if (arg != other.arg) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + setQuantifier.hashCode()
                hc = 31 * hc + arg.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SimpleCase(
            val value: Expr,
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SimpleCase =
                SimpleCase(
                    value = value,
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    value.toIonElement(),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SimpleCase::class.java) return false
        
                other as SimpleCase
                if (value != other.value) return false
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SearchedCase(
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SearchedCase =
                SearchedCase(
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SearchedCase::class.java) return false
        
                other as SearchedCase
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Struct(
            val fields: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Struct =
                Struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Struct::class.java) return false
        
                other as Struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Bag(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Bag =
                Bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Bag::class.java) return false
        
                other as Bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class List(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): List =
                List(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != List::class.java) return false
        
                other as List
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Select(
            val setq: SetQuantifier?,
            val project: Projection,
            val from: FromSource,
            val where: Expr?,
            val group: GroupBy?,
            val having: Expr?,
            val limit: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Select::class.java) return false
        
                other as Select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<PartiqlBasicNode>() {
    
        override fun innerTransform(sexp: SexpElement): PartiqlBasicNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Expr>()
                    val second = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlBasic.ExprPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupByItem(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<GroupByItem>() }
                    PartiqlBasic.GroupByList(
                        items,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val items = sexp.getRequired(0).transformExpect<GroupByList>()
                    val groupAsAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupBy(
                        items,
                        groupAsAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<ProjectItem>() }
                    PartiqlBasic.Projection.ProjectList(
                        items,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Projection.ProjectValue(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ProjectItem'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ProjectItem.ProjectAll(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.ProjectItem.ProjectExpr(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'JoinType'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'FromSource'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlBasic.FromSource.Scan(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<JoinType>()
                    val left = sexp.getRequired(1).transformExpect<FromSource>()
                    val right = sexp.getRequired(2).transformExpect<FromSource>()
                    val predicate = sexp.getOptional(3)?.transformExpect<Expr>()
                    PartiqlBasic.FromSource.Join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'CaseSensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseSensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseInsensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ScopeQualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SetQuantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.All(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.Distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'PathElement'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.PathElement.PathExpr(
                        expr,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathWildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathUnpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    PartiqlBasic.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    val scopeQualifier = sexp.getRequired(2).transformExpect<ScopeQualifier>()
                    PartiqlBasic.Expr.Id(
                        name,
                        case,
                        scopeQualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    PartiqlBasic.Expr.Parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Concat(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val left = sexp.getRequired(0).transformExpect<Expr>()
                    val right = sexp.getRequired(1).transformExpect<Expr>()
                    val escape = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Like(
                        left,
                        right,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val from = sexp.getRequired(1).transformExpect<Expr>()
                    val to = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<Expr>()
                    val elements = sexp.values.drop(2).map { it.transformExpect<PathElement>() }
                    PartiqlBasic.Expr.Path(
                        root,
                        elements,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Call(
                        name,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val setQuantifier = sexp.getRequired(1).transformExpect<SetQuantifier>()
                    val arg = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.CallAgg(
                        name,
                        setQuantifier,
                        arg,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val branches = sexp.values.drop(2).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SimpleCase(
                        value,
                        branches,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val branches = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SearchedCase(
                        branches,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.Struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.List(
                        values,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<SetQuantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<Projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<FromSource>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<GroupBy>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<Expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<Expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Expr.Select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
    
    
    
    open class InspectingVisitor : InspectingDomainVisitorBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitExprPair(node: PartiqlBasic.ExprPair) { }
        open fun visitGroupByItem(node: PartiqlBasic.GroupByItem) { }
        open fun visitGroupByList(node: PartiqlBasic.GroupByList) { }
        open fun visitGroupBy(node: PartiqlBasic.GroupBy) { }
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun visitProjection(node: PartiqlBasic.Projection) { }
        open fun visitProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) { }
        open fun visitProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) { }
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun visitProjectItem(node: PartiqlBasic.ProjectItem) { }
        open fun visitProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) { }
        open fun visitProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) { }
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun visitJoinType(node: PartiqlBasic.JoinType) { }
        open fun visitJoinTypeInner(node: PartiqlBasic.JoinType.Inner) { }
        open fun visitJoinTypeLeft(node: PartiqlBasic.JoinType.Left) { }
        open fun visitJoinTypeRight(node: PartiqlBasic.JoinType.Right) { }
        open fun visitJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) { }
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun visitFromSource(node: PartiqlBasic.FromSource) { }
        open fun visitFromSourceScan(node: PartiqlBasic.FromSource.Scan) { }
        open fun visitFromSourceJoin(node: PartiqlBasic.FromSource.Join) { }
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun visitCaseSensitivity(node: PartiqlBasic.CaseSensitivity) { }
        open fun visitCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) { }
        open fun visitCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) { }
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun visitScopeQualifier(node: PartiqlBasic.ScopeQualifier) { }
        open fun visitScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) { }
        open fun visitScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) { }
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun visitSetQuantifier(node: PartiqlBasic.SetQuantifier) { }
        open fun visitSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) { }
        open fun visitSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) { }
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun visitPathElement(node: PartiqlBasic.PathElement) { }
        open fun visitPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) { }
        open fun visitPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) { }
        open fun visitPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) { }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun visitExpr(node: PartiqlBasic.Expr) { }
        open fun visitExprLit(node: PartiqlBasic.Expr.Lit) { }
        open fun visitExprId(node: PartiqlBasic.Expr.Id) { }
        open fun visitExprParameter(node: PartiqlBasic.Expr.Parameter) { }
        open fun visitExprNot(node: PartiqlBasic.Expr.Not) { }
        open fun visitExprPlus(node: PartiqlBasic.Expr.Plus) { }
        open fun visitExprMinus(node: PartiqlBasic.Expr.Minus) { }
        open fun visitExprTimes(node: PartiqlBasic.Expr.Times) { }
        open fun visitExprDivide(node: PartiqlBasic.Expr.Divide) { }
        open fun visitExprModulo(node: PartiqlBasic.Expr.Modulo) { }
        open fun visitExprConcat(node: PartiqlBasic.Expr.Concat) { }
        open fun visitExprLike(node: PartiqlBasic.Expr.Like) { }
        open fun visitExprBetween(node: PartiqlBasic.Expr.Between) { }
        open fun visitExprPath(node: PartiqlBasic.Expr.Path) { }
        open fun visitExprCall(node: PartiqlBasic.Expr.Call) { }
        open fun visitExprCallAgg(node: PartiqlBasic.Expr.CallAgg) { }
        open fun visitExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) { }
        open fun visitExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) { }
        open fun visitExprStruct(node: PartiqlBasic.Expr.Struct) { }
        open fun visitExprBag(node: PartiqlBasic.Expr.Bag) { }
        open fun visitExprList(node: PartiqlBasic.Expr.List) { }
        open fun visitExprSelect(node: PartiqlBasic.Expr.Select) { }
    }
    
    open class InspectingWalker(
        visitor: PartiqlBasic.InspectingVisitor
    ) : InspectingDomainWalkerBase<InspectingVisitor>(visitor) {
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkExprPair(node: PartiqlBasic.ExprPair) {
            visitor.visitExprPair(node)
            walkExpr(node.first)
            walkExpr(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkGroupByItem(node: PartiqlBasic.GroupByItem) {
            visitor.visitGroupByItem(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupByList(node: PartiqlBasic.GroupByList) {
            visitor.visitGroupByList(node)
            node.items.map { walkGroupByItem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupBy(node: PartiqlBasic.GroupBy) {
            visitor.visitGroupBy(node)
            walkGroupByList(node.items)
            node.groupAsAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlBasic.Projection) {
            visitor.visitProjection(node)
            when(node) {
                is PartiqlBasic.Projection.ProjectList -> walkProjectionProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> walkProjectionProjectValue(node)
            }
        }
    
        open fun walkProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) {
            visitor.visitProjectionProjectList(node)
            node.items.map { walkProjectItem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) {
            visitor.visitProjectionProjectValue(node)
            walkExpr(node.value)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlBasic.ProjectItem) {
            visitor.visitProjectItem(node)
            when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) {
            visitor.visitProjectItemProjectAll(node)
            walkMetas(node.metas)
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) {
            visitor.visitProjectItemProjectExpr(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlBasic.JoinType) {
            visitor.visitJoinType(node)
            when(node) {
                is PartiqlBasic.JoinType.Inner -> walkJoinTypeInner(node)
                is PartiqlBasic.JoinType.Left -> walkJoinTypeLeft(node)
                is PartiqlBasic.JoinType.Right -> walkJoinTypeRight(node)
                is PartiqlBasic.JoinType.Outer -> walkJoinTypeOuter(node)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlBasic.JoinType.Inner) {
            visitor.visitJoinTypeInner(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeLeft(node: PartiqlBasic.JoinType.Left) {
            visitor.visitJoinTypeLeft(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeRight(node: PartiqlBasic.JoinType.Right) {
            visitor.visitJoinTypeRight(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) {
            visitor.visitJoinTypeOuter(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlBasic.FromSource) {
            visitor.visitFromSource(node)
            when(node) {
                is PartiqlBasic.FromSource.Scan -> walkFromSourceScan(node)
                is PartiqlBasic.FromSource.Join -> walkFromSourceJoin(node)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlBasic.FromSource.Scan) {
            visitor.visitFromSourceScan(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            node.atAlias?.let { walkSymbolPrimitive(it) }
            node.byAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkFromSourceJoin(node: PartiqlBasic.FromSource.Join) {
            visitor.visitFromSourceJoin(node)
            walkJoinType(node.type)
            walkFromSource(node.left)
            walkFromSource(node.right)
            node.predicate?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlBasic.CaseSensitivity) {
            visitor.visitCaseSensitivity(node)
            when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) {
            visitor.visitCaseSensitivityCaseSensitive(node)
            walkMetas(node.metas)
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) {
            visitor.visitCaseSensitivityCaseInsensitive(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlBasic.ScopeQualifier) {
            visitor.visitScopeQualifier(node)
            when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> walkScopeQualifierQualified(node)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) {
            visitor.visitScopeQualifierUnqualified(node)
            walkMetas(node.metas)
        }
    
        open fun walkScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) {
            visitor.visitScopeQualifierQualified(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlBasic.SetQuantifier) {
            visitor.visitSetQuantifier(node)
            when(node) {
                is PartiqlBasic.SetQuantifier.All -> walkSetQuantifierAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) {
            visitor.visitSetQuantifierAll(node)
            walkMetas(node.metas)
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) {
            visitor.visitSetQuantifierDistinct(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun walkPathElement(node: PartiqlBasic.PathElement) {
            visitor.visitPathElement(node)
            when(node) {
                is PartiqlBasic.PathElement.PathExpr -> walkPathElementPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> walkPathElementPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> walkPathElementPathUnpivot(node)
            }
        }
    
        open fun walkPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) {
            visitor.visitPathElementPathExpr(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) {
            visitor.visitPathElementPathWildcard(node)
            walkMetas(node.metas)
        }
    
        open fun walkPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) {
            visitor.visitPathElementPathUnpivot(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlBasic.Expr) {
            visitor.visitExpr(node)
            when(node) {
                is PartiqlBasic.Expr.Lit -> walkExprLit(node)
                is PartiqlBasic.Expr.Id -> walkExprId(node)
                is PartiqlBasic.Expr.Parameter -> walkExprParameter(node)
                is PartiqlBasic.Expr.Not -> walkExprNot(node)
                is PartiqlBasic.Expr.Plus -> walkExprPlus(node)
                is PartiqlBasic.Expr.Minus -> walkExprMinus(node)
                is PartiqlBasic.Expr.Times -> walkExprTimes(node)
                is PartiqlBasic.Expr.Divide -> walkExprDivide(node)
                is PartiqlBasic.Expr.Modulo -> walkExprModulo(node)
                is PartiqlBasic.Expr.Concat -> walkExprConcat(node)
                is PartiqlBasic.Expr.Like -> walkExprLike(node)
                is PartiqlBasic.Expr.Between -> walkExprBetween(node)
                is PartiqlBasic.Expr.Path -> walkExprPath(node)
                is PartiqlBasic.Expr.Call -> walkExprCall(node)
                is PartiqlBasic.Expr.CallAgg -> walkExprCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> walkExprSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> walkExprSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> walkExprStruct(node)
                is PartiqlBasic.Expr.Bag -> walkExprBag(node)
                is PartiqlBasic.Expr.List -> walkExprList(node)
                is PartiqlBasic.Expr.Select -> walkExprSelect(node)
            }
        }
    
        open fun walkExprLit(node: PartiqlBasic.Expr.Lit) {
            visitor.visitExprLit(node)
            walkIonElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprId(node: PartiqlBasic.Expr.Id) {
            visitor.visitExprId(node)
            walkSymbolPrimitive(node.name)
            walkCaseSensitivity(node.case)
            walkScopeQualifier(node.scopeQualifier)
            walkMetas(node.metas)
        }
    
        open fun walkExprParameter(node: PartiqlBasic.Expr.Parameter) {
            visitor.visitExprParameter(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: PartiqlBasic.Expr.Not) {
            visitor.visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: PartiqlBasic.Expr.Plus) {
            visitor.visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: PartiqlBasic.Expr.Minus) {
            visitor.visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: PartiqlBasic.Expr.Times) {
            visitor.visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: PartiqlBasic.Expr.Divide) {
            visitor.visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: PartiqlBasic.Expr.Modulo) {
            visitor.visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprConcat(node: PartiqlBasic.Expr.Concat) {
            visitor.visitExprConcat(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprLike(node: PartiqlBasic.Expr.Like) {
            visitor.visitExprLike(node)
            walkExpr(node.left)
            walkExpr(node.right)
            walkExpr(node.escape)
            walkMetas(node.metas)
        }
    
        open fun walkExprBetween(node: PartiqlBasic.Expr.Between) {
            visitor.visitExprBetween(node)
            walkExpr(node.value)
            walkExpr(node.from)
            walkExpr(node.to)
            walkMetas(node.metas)
        }
    
        open fun walkExprPath(node: PartiqlBasic.Expr.Path) {
            visitor.visitExprPath(node)
            walkExpr(node.root)
            node.elements.map { walkPathElement(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: PartiqlBasic.Expr.Call) {
            visitor.visitExprCall(node)
            walkSymbolPrimitive(node.name)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCallAgg(node: PartiqlBasic.Expr.CallAgg) {
            visitor.visitExprCallAgg(node)
            walkSymbolPrimitive(node.name)
            walkSetQuantifier(node.setQuantifier)
            walkExpr(node.arg)
            walkMetas(node.metas)
        }
    
        open fun walkExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) {
            visitor.visitExprSimpleCase(node)
            walkExpr(node.value)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) {
            visitor.visitExprSearchedCase(node)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprStruct(node: PartiqlBasic.Expr.Struct) {
            visitor.visitExprStruct(node)
            node.fields.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprBag(node: PartiqlBasic.Expr.Bag) {
            visitor.visitExprBag(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprList(node: PartiqlBasic.Expr.List) {
            visitor.visitExprList(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSelect(node: PartiqlBasic.Expr.Select) {
            visitor.visitExprSelect(node)
            node.setq?.let { walkSetQuantifier(it) }
            walkProjection(node.project)
            walkFromSource(node.from)
            node.where?.let { walkExpr(it) }
            node.group?.let { walkGroupBy(it) }
            node.having?.let { walkExpr(it) }
            node.limit?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
    }
}

