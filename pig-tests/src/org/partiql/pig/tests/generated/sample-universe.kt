/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",  "USELESS_ELVIS")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class ToyLang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): ToyLangNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNode =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: Expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Variable(
                name = name.asPrimitive(),
                metas = metas)
        
        fun variable_(
            name: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Variable(
                name = name,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Call(
                name = name.asPrimitive(),
                operands = operands,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Call(
                name = name,
                operands = operands,
                metas = metas)
        
        
        fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            name: SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Let(
                name = name,
                value = value,
                body = body,
                metas = metas)
        
        
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            varName: SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLang.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLang types. */
    abstract class ToyLangNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNode() {
    
        class Lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: SymbolPrimitive,
            val operands: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    operands.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: SymbolPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLang.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    ToyLang.Expr.Variable(
                        name,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLang.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val operands = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Call(
                        name,
                        operands,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLang.Expr.Let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
}

class ToyLangNameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNamelessNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): ToyLangNamelessNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNamelessNode =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: Expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Call(
                name = name.asPrimitive(),
                operands = operands,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Call(
                name = name,
                operands = operands,
                metas = metas)
        
        
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            varName: SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
        
        
        fun variable(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Variable(
                index = index.asPrimitive(),
                metas = metas)
        
        fun variable_(
            index: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Variable(
                index = index,
                metas = metas)
        
        
        fun let(
            index: Long,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Let(
                index = index.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            index: LongPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            ToyLangNameless.Expr.Let(
                index = index,
                value = value,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLangNameless types. */
    abstract class ToyLangNamelessNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNamelessNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNamelessNode() {
    
        class Lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: SymbolPrimitive,
            val operands: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    operands.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val index: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val index: LongPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    index = index,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    index.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (index != other.index) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNamelessNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNamelessNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLangNameless.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLangNameless.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val operands = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Call(
                        name,
                        operands,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    ToyLangNameless.Expr.Variable(
                        index,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLangNameless.Expr.Let(
                        index,
                        value,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_nameless'")
            }
        }
    }
}

class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: TestDomainNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun intPair_(
            first: LongPrimitive,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbolPair_(
            first: SymbolPrimitive,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionPair(
            first: IonElement,
            second: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): IonPair =
            TestDomain.IonPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun intSymbolPair_(
            first: LongPrimitive,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbolIntPair_(
            first: SymbolPrimitive,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionIntPair(
            firs: IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): IonIntPair =
            TestDomain.IonIntPair(
                firs = firs,
                second = second.asPrimitive(),
                metas = metas)
        
        fun ionIntPair_(
            firs: IonElement,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): IonIntPair =
            TestDomain.IonIntPair(
                firs = firs,
                second = second,
                metas = metas)
        
        
        fun ionSymbolPair(
            firs: IonElement,
            second: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): IonSymbolPair =
            TestDomain.IonSymbolPair(
                firs = firs,
                second = second,
                metas = metas)
        
        
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun recursivePair_(
            first: LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answerIntPair_(
            first: Answer,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun intAnswerPair_(
            first: LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun symbolAnswerPair_(
            first: SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answerSymbolPair_(
            first: Answer,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun variadicMin0(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin0_(
            ints: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = metas)
        
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin0_(
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = metas)
        
        
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin1_(
            ints: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = metas)
        
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadicMin1_(
            ints0: LongPrimitive,
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = metas)
        
        
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun elementVariadic_(
            name: SymbolPrimitive,
            ints: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
        
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun elementVariadic_(
            name: SymbolPrimitive,
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = metas)
        
        
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = metas)
        
        fun optional1_(
            value: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = metas)
        
        
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = metas)
        
        fun optional2_(
            first: LongPrimitive? = null,
            second: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = metas)
        
        
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = metas)
        
        fun domainLevelRecord_(
            someField: LongPrimitive,
            anotherField: SymbolPrimitive,
            optionalField: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
        
        
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun productWithRecord_(
            value: LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = metas)
        
        
        // Variants for Sum: Answer 
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): Answer =
            TestDomain.Answer.No(
                metas = metas)
        
        
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): Answer =
            TestDomain.Answer.Yes(
                metas = metas)
        
        
        // Variants for Sum: SumWithRecord 
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun variantWithRecord_(
            value: LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        // Variants for Sum: Entity 
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): Entity =
            TestDomain.Entity.Slug(
                metas = metas)
        
        
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): Entity =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = metas)
        
        fun android_(
            id: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): Entity =
            TestDomain.Entity.Android(
                id = id,
                metas = metas)
        
        
        fun human(
            firstName: String,
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Entity =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        fun human_(
            firstName: SymbolPrimitive,
            lastName: SymbolPrimitive,
            title: SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Entity =
            TestDomain.Entity.Human(
                firstName = firstName,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class IntPair(
        val first: LongPrimitive,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: SymbolPrimitive,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: IonElement,
        val second: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: LongPrimitive,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: SymbolPrimitive,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val firs: IonElement,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                firs = firs,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                firs.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (firs != other.firs) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = firs.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val firs: IonElement,
        val second: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                firs = firs,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                firs.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (firs != other.firs) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = firs.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: SymbolPrimitive,
        val ints: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: LongPrimitive?,
        val second: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: LongPrimitive,
        val anotherField: SymbolPrimitive,
        val optionalField: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer : TestDomainNode() {
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class SumWithRecord : TestDomainNode() {
    
        class VariantWithRecord(
            val value: LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class Entity : TestDomainNode() {
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Android(
            val id: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: SymbolPrimitive,
            val lastName: SymbolPrimitive,
            val title: SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = firstName.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val firs = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        firs,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val firs = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        firs,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
}

class MultiWordDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: MultiWordDomainNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): MultiWordDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): MultiWordDomainNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun aaaAaa(
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAaa =
            MultiWordDomain.AaaAaa(
                metas = metas)
        
        
        fun aaaAab(
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField?.asPrimitive(),
                metas = metas)
        
        fun aaaAab_(
            dField: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField,
                metas = metas)
        
        
        fun aaaAac(
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        fun aaaAac_(
            dField: LongPrimitive? = null,
            eField: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        fun aaaAad(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAad_(
            dField: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField,
                metas = metas)
        
        fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAad_(
            vararg dField: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.toList(),
                metas = metas)
        
        
        fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAae_(
            dField: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField,
                metas = metas)
        
        fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aaaAae_(
            dField0: LongPrimitive,
            dField1: LongPrimitive,
            vararg dField: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                metas = metas)
        
        fun aabAaa_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField,
                cField = cField,
                metas = metas)
        
        
        fun aabAab(
            bField: Long,
            cField: String,
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAab =
            MultiWordDomain.AabAab(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                metas = metas)
        
        fun aabAab_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            dField: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAab =
            MultiWordDomain.AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        
        fun aabAac(
            bField: Long,
            cField: String,
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAac =
            MultiWordDomain.AabAac(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        fun aabAac_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            dField: LongPrimitive? = null,
            eField: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAac =
            MultiWordDomain.AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAad_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            dField: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAad_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            vararg dField: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField.toList(),
                metas = metas)
        
        
        fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAae_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            dField: kotlin.collections.List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        fun aabAae_(
            bField: LongPrimitive,
            cField: SymbolPrimitive,
            dField0: LongPrimitive,
            dField1: LongPrimitive,
            vararg dField: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        // Variants for Sum: SssTtt 
        fun lll(
            uField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtt =
            MultiWordDomain.SssTtt.Lll(
                uField = uField.asPrimitive(),
                metas = metas)
        
        fun lll_(
            uField: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtt =
            MultiWordDomain.SssTtt.Lll(
                uField = uField,
                metas = metas)
        
        
        fun mmm(
            vField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtt =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField.asPrimitive(),
                metas = metas)
        
        fun mmm_(
            vField: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtt =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField,
                metas = metas)
        
        
        // Variants for Sum: SssTtu 
        fun nnn(
            uField: AaaAaa,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtu =
            MultiWordDomain.SssTtu.Nnn(
                uField = uField,
                metas = metas)
        
        
        fun ooo(
            vField: AaaAab,
            metas: MetaContainer = emptyMetaContainer()
        ): SssTtu =
            MultiWordDomain.SssTtu.Ooo(
                vField = vField,
                metas = metas)
    }
    
    /** Base class for all MultiWordDomain types. */
    abstract class MultiWordDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): MultiWordDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class AaaAaa(
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAaa =
            AaaAaa(
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aaa"),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAaa::class.java) return false
    
            return true
        }
    
        override fun hashCode(): Int = 0
    }
    
    class AaaAab(
        val dField: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aab"),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAab::class.java) return false
    
            other as AaaAab
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAac(
        val dField: LongPrimitive?,
        val eField: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aac"),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAac::class.java) return false
    
            other as AaaAac
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAad(
        val dField: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aad"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAad::class.java) return false
    
            other as AaaAad
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAae(
        val dField: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aae"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAae::class.java) return false
    
            other as AaaAae
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAaa(
        val bField: LongPrimitive,
        val cField: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aaa"),
                bField.toIonElement(),
                cField.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAaa::class.java) return false
    
            other as AabAaa
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAab(
        val bField: LongPrimitive,
        val cField: SymbolPrimitive,
        val dField: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aab"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAab::class.java) return false
    
            other as AabAab
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAac(
        val bField: LongPrimitive,
        val cField: SymbolPrimitive,
        val dField: LongPrimitive?,
        val eField: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aac"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAac::class.java) return false
    
            other as AabAac
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAad(
        val bField: LongPrimitive,
        val cField: SymbolPrimitive,
        val dField: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aad"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAad::class.java) return false
    
            other as AabAad
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAae(
        val bField: LongPrimitive,
        val cField: SymbolPrimitive,
        val dField: kotlin.collections.List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aae"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAae::class.java) return false
    
            other as AabAae
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SssTtt : MultiWordDomainNode() {
    
        class Lll(
            val uField: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lll =
                Lll(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lll"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lll::class.java) return false
        
                other as Lll
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Mmm(
            val vField: SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("mmm"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Mmm::class.java) return false
        
                other as Mmm
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class SssTtu : MultiWordDomainNode() {
    
        class Nnn(
            val uField: AaaAaa,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtu() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Nnn =
                Nnn(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("nnn"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Nnn::class.java) return false
        
                other as Nnn
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Ooo(
            val vField: AaaAab,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtu() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Ooo =
                Ooo(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("ooo"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Ooo::class.java) return false
        
                other as Ooo
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<MultiWordDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): MultiWordDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "aaa_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    MultiWordDomain.AaaAaa(
                        metas = sexp.metas)
                }
                "aaa_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    MultiWordDomain.AaaAab(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    val eField = sexp.getOptional(1)?.toSymbolPrimitive()
                    MultiWordDomain.AaaAac(
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aaa_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAad(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAae(
                        dField,
                        metas = sexp.metas)
                }
                "aab_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    MultiWordDomain.AabAaa(
                        bField,
                        cField,
                        metas = sexp.metas)
                }
                "aab_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    MultiWordDomain.AabAab(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    val eField = sexp.getOptional(3)?.toSymbolPrimitive()
                    MultiWordDomain.AabAac(
                        bField,
                        cField,
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aab_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAad(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAae(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtt'
                //////////////////////////////////////
                "lll" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).toLongPrimitive()
                    MultiWordDomain.SssTtt.Lll(
                        uField,
                        metas = sexp.metas)
                }
                "mmm" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).toSymbolPrimitive()
                    MultiWordDomain.SssTtt.Mmm(
                        vField,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtu'
                //////////////////////////////////////
                "nnn" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).transformExpect<AaaAaa>()
                    MultiWordDomain.SssTtu.Nnn(
                        uField,
                        metas = sexp.metas)
                }
                "ooo" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).transformExpect<AaaAab>()
                    MultiWordDomain.SssTtu.Ooo(
                        vField,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'multi_word_domain'")
            }
        }
    }
}

class PartiqlBasic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: PartiqlBasicNode> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): PartiqlBasicNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): PartiqlBasicNode =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun exprPair(
            first: Expr,
            second: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ExprPair =
            PartiqlBasic.ExprPair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun groupByItem(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        fun groupByItem_(
            value: Expr,
            asAlias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        fun groupByList(
            items: kotlin.collections.List<GroupByItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupByList =
            PartiqlBasic.GroupByList(
                items = items,
                metas = metas)
        
        fun groupByList(
            items0: GroupByItem,
            vararg items: GroupByItem,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupByList =
            PartiqlBasic.GroupByList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        fun groupBy(
            items: GroupByList,
            groupAsAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias?.asPrimitive(),
                metas = metas)
        
        fun groupBy_(
            items: GroupByList,
            groupAsAlias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas)
        
        
        // Variants for Sum: Projection 
        fun projectList(
            items: kotlin.collections.List<ProjectItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): Projection =
            PartiqlBasic.Projection.ProjectList(
                items = items,
                metas = metas)
        
        fun projectList(
            items0: ProjectItem,
            vararg items: ProjectItem,
            metas: MetaContainer = emptyMetaContainer()
        ): Projection =
            PartiqlBasic.Projection.ProjectList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        fun projectValue(
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Projection =
            PartiqlBasic.Projection.ProjectValue(
                value = value,
                metas = metas)
        
        
        // Variants for Sum: ProjectItem 
        fun projectAll(
            metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem =
            PartiqlBasic.ProjectItem.ProjectAll(
                metas = metas)
        
        
        fun projectExpr(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        fun projectExpr_(
            value: Expr,
            asAlias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        // Variants for Sum: JoinType 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): JoinType =
            PartiqlBasic.JoinType.Inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): JoinType =
            PartiqlBasic.JoinType.Left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): JoinType =
            PartiqlBasic.JoinType.Right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): JoinType =
            PartiqlBasic.JoinType.Outer(
                metas = metas)
        
        
        // Variants for Sum: FromSource 
        fun scan(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): FromSource =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr: Expr,
            asAlias: SymbolPrimitive? = null,
            atAlias: SymbolPrimitive? = null,
            byAlias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): FromSource =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = metas)
        
        
        fun join(
            type: JoinType,
            left: FromSource,
            right: FromSource,
            predicate: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): FromSource =
            PartiqlBasic.FromSource.Join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = metas)
        
        
        // Variants for Sum: CaseSensitivity 
        fun caseSensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity =
            PartiqlBasic.CaseSensitivity.CaseSensitive(
                metas = metas)
        
        
        fun caseInsensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity =
            PartiqlBasic.CaseSensitivity.CaseInsensitive(
                metas = metas)
        
        
        // Variants for Sum: ScopeQualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier =
            PartiqlBasic.ScopeQualifier.Unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier =
            PartiqlBasic.ScopeQualifier.Qualified(
                metas = metas)
        
        
        // Variants for Sum: SetQuantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier =
            PartiqlBasic.SetQuantifier.All(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier =
            PartiqlBasic.SetQuantifier.Distinct(
                metas = metas)
        
        
        // Variants for Sum: PathElement 
        fun pathExpr(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PathElement =
            PartiqlBasic.PathElement.PathExpr(
                expr = expr,
                metas = metas)
        
        
        fun pathWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PathElement =
            PartiqlBasic.PathElement.PathWildcard(
                metas = metas)
        
        
        fun pathUnpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): PathElement =
            PartiqlBasic.PathElement.PathUnpivot(
                metas = metas)
        
        
        // Variants for Sum: Expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Lit(
                value = value,
                metas = metas)
        
        
        fun id(
            name: String,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Id(
                name = name.asPrimitive(),
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        fun id_(
            name: SymbolPrimitive,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Id(
                name = name,
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Parameter(
                index = index.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            index: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Parameter(
                index = index,
                metas = metas)
        
        
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun concat(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Concat(
                operands = operands,
                metas = metas)
        
        fun concat(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Concat(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        fun like(
            left: Expr,
            right: Expr,
            escape: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Like(
                left = left,
                right = right,
                escape = escape,
                metas = metas)
        
        
        fun between(
            value: Expr,
            from: Expr,
            to: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Between(
                value = value,
                from = from,
                to = to,
                metas = metas)
        
        
        fun path(
            root: Expr,
            elements: kotlin.collections.List<PathElement>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = elements,
                metas = metas)
        
        fun path(
            root: Expr,
            elements0: PathElement,
            vararg elements: PathElement,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = listOf(elements0) + elements.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = args,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Call(
                name = name,
                args = args,
                metas = metas)
        
        fun call(
            name: String,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Call(
                name = name,
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        
        fun callAgg(
            name: String,
            setQuantifier: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.CallAgg(
                name = name.asPrimitive(),
                setQuantifier = setQuantifier,
                metas = metas)
        
        fun callAgg_(
            name: SymbolPrimitive,
            setQuantifier: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.CallAgg(
                name = name,
                setQuantifier = setQuantifier,
                metas = metas)
        
        
        fun simpleCase(
            value: Expr,
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = branches,
                metas = metas)
        
        fun simpleCase(
            value: Expr,
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        fun searchedCase(
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.SearchedCase(
                branches = branches,
                metas = metas)
        
        fun searchedCase(
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.SearchedCase(
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        fun struct(
            fields: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Struct(
                fields = fields,
                metas = metas)
        
        fun struct(
            vararg fields: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Struct(
                fields = fields.toList(),
                metas = metas)
        
        
        fun bag(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Bag(
                values = values,
                metas = metas)
        
        fun bag(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Bag(
                values = values.toList(),
                metas = metas)
        
        
        fun list(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.List(
                values = values,
                metas = metas)
        
        fun list(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.List(
                values = values.toList(),
                metas = metas)
        
        
        fun select(
            setq: SetQuantifier? = null,
            project: Projection,
            from: FromSource,
            where: Expr? = null,
            group: GroupBy? = null,
            having: Expr? = null,
            limit: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): Expr =
            PartiqlBasic.Expr.Select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = metas)
    }
    
    /** Base class for all PartiqlBasic types. */
    abstract class PartiqlBasicNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): PartiqlBasicNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ExprPair(
        val first: Expr,
        val second: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPair::class.java) return false
    
            other as ExprPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByItem(
        val value: Expr,
        val asAlias: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByItem =
            GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                value.toIonElement(),
                asAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByItem::class.java) return false
    
            other as GroupByItem
            if (value != other.value) return false
            if (asAlias != other.asAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + asAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByList(
        val items: kotlin.collections.List<GroupByItem>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByList =
            GroupByList(
                items = items,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *items.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByList::class.java) return false
    
            other as GroupByList
            if (items != other.items) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupBy(
        val items: GroupByList,
        val groupAsAlias: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupBy =
            GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                items.toIonElement(),
                groupAsAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupBy::class.java) return false
    
            other as GroupBy
            if (items != other.items) return false
            if (groupAsAlias != other.groupAsAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc = 31 * hc + groupAsAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Projection : PartiqlBasicNode() {
    
        class ProjectList(
            val items: kotlin.collections.List<ProjectItem>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectList =
                ProjectList(
                    items = items,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *items.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectList::class.java) return false
        
                other as ProjectList
                if (items != other.items) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = items.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectValue(
            val value: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectValue::class.java) return false
        
                other as ProjectValue
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class ProjectItem : PartiqlBasicNode() {
    
        class ProjectAll(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectAll =
                ProjectAll(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectAll::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class ProjectExpr(
            val value: Expr,
            val asAlias: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectExpr =
                ProjectExpr(
                    value = value,
                    asAlias = asAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    value.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectExpr::class.java) return false
        
                other as ProjectExpr
                if (value != other.value) return false
                if (asAlias != other.asAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class JoinType : PartiqlBasicNode() {
    
        class Inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Inner =
                Inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Left =
                Left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class Right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Right =
                Right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class Outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Outer =
                Outer(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
    }
    
    sealed class FromSource : PartiqlBasicNode() {
    
        class Scan(
            val expr: Expr,
            val asAlias: SymbolPrimitive?,
            val atAlias: SymbolPrimitive?,
            val byAlias: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Scan::class.java) return false
        
                other as Scan
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Join(
            val type: JoinType,
            val left: FromSource,
            val right: FromSource,
            val predicate: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Join::class.java) return false
        
                other as Join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class CaseSensitivity : PartiqlBasicNode() {
    
        class CaseSensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseSensitive =
                CaseSensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseSensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class CaseInsensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseInsensitive =
                CaseInsensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseInsensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class ScopeQualifier : PartiqlBasicNode() {
    
        class Unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Unqualified =
                Unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class Qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Qualified =
                Qualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
    }
    
    sealed class SetQuantifier : PartiqlBasicNode() {
    
        class All(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): All =
                All(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != All::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class Distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Distinct =
                Distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
    }
    
    sealed class PathElement : PartiqlBasicNode() {
    
        class PathExpr(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathExpr =
                PathExpr(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathExpr::class.java) return false
        
                other as PathExpr
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class PathWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathWildcard =
                PathWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class PathUnpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathUnpivot =
                PathUnpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathUnpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
    }
    
    sealed class Expr : PartiqlBasicNode() {
    
        class Lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Id(
            val name: SymbolPrimitive,
            val case: CaseSensitivity,
            val scopeQualifier: ScopeQualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Id =
                Id(
                    name = name,
                    case = case,
                    scopeQualifier = scopeQualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    scopeQualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Id::class.java) return false
        
                other as Id
                if (name != other.name) return false
                if (case != other.case) return false
                if (scopeQualifier != other.scopeQualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + scopeQualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Parameter(
            val index: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Parameter =
                Parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Parameter::class.java) return false
        
                other as Parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Concat(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Concat =
                Concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Concat::class.java) return false
        
                other as Concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Like(
            val left: Expr,
            val right: Expr,
            val escape: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Like =
                Like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    left.toIonElement(),
                    right.toIonElement(),
                    escape.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Like::class.java) return false
        
                other as Like
                if (left != other.left) return false
                if (right != other.right) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Between(
            val value: Expr,
            val from: Expr,
            val to: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Between::class.java) return false
        
                other as Between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Path(
            val root: Expr,
            val elements: kotlin.collections.List<PathElement>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Path =
                Path(
                    root = root,
                    elements = elements,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *elements.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Path::class.java) return false
        
                other as Path
                if (root != other.root) return false
                if (elements != other.elements) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = root.hashCode()
                hc = 31 * hc + elements.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CallAgg(
            val name: SymbolPrimitive,
            val setQuantifier: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CallAgg =
                CallAgg(
                    name = name,
                    setQuantifier = setQuantifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    name.toIonElement(),
                    setQuantifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CallAgg::class.java) return false
        
                other as CallAgg
                if (name != other.name) return false
                if (setQuantifier != other.setQuantifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + setQuantifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SimpleCase(
            val value: Expr,
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SimpleCase =
                SimpleCase(
                    value = value,
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    value.toIonElement(),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SimpleCase::class.java) return false
        
                other as SimpleCase
                if (value != other.value) return false
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SearchedCase(
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SearchedCase =
                SearchedCase(
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SearchedCase::class.java) return false
        
                other as SearchedCase
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Struct(
            val fields: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Struct =
                Struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Struct::class.java) return false
        
                other as Struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Bag(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Bag =
                Bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Bag::class.java) return false
        
                other as Bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class List(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): List =
                List(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != List::class.java) return false
        
                other as List
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Select(
            val setq: SetQuantifier?,
            val project: Projection,
            val from: FromSource,
            val where: Expr?,
            val group: GroupBy?,
            val having: Expr?,
            val limit: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Select::class.java) return false
        
                other as Select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<PartiqlBasicNode>() {
    
        override fun innerTransform(sexp: SexpElement): PartiqlBasicNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Expr>()
                    val second = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlBasic.ExprPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupByItem(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<GroupByItem>() }
                    PartiqlBasic.GroupByList(
                        items,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val items = sexp.getRequired(0).transformExpect<GroupByList>()
                    val groupAsAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupBy(
                        items,
                        groupAsAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<ProjectItem>() }
                    PartiqlBasic.Projection.ProjectList(
                        items,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Projection.ProjectValue(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ProjectItem'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ProjectItem.ProjectAll(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.ProjectItem.ProjectExpr(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'JoinType'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'FromSource'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlBasic.FromSource.Scan(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<JoinType>()
                    val left = sexp.getRequired(1).transformExpect<FromSource>()
                    val right = sexp.getRequired(2).transformExpect<FromSource>()
                    val predicate = sexp.getOptional(3)?.transformExpect<Expr>()
                    PartiqlBasic.FromSource.Join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'CaseSensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseSensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseInsensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ScopeQualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SetQuantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.All(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.Distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'PathElement'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.PathElement.PathExpr(
                        expr,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathWildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathUnpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    PartiqlBasic.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    val scopeQualifier = sexp.getRequired(2).transformExpect<ScopeQualifier>()
                    PartiqlBasic.Expr.Id(
                        name,
                        case,
                        scopeQualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    PartiqlBasic.Expr.Parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Concat(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val left = sexp.getRequired(0).transformExpect<Expr>()
                    val right = sexp.getRequired(1).transformExpect<Expr>()
                    val escape = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Like(
                        left,
                        right,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val from = sexp.getRequired(1).transformExpect<Expr>()
                    val to = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<Expr>()
                    val elements = sexp.values.drop(2).map { it.transformExpect<PathElement>() }
                    PartiqlBasic.Expr.Path(
                        root,
                        elements,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Call(
                        name,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val setQuantifier = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlBasic.Expr.CallAgg(
                        name,
                        setQuantifier,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val branches = sexp.values.drop(2).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SimpleCase(
                        value,
                        branches,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val branches = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SearchedCase(
                        branches,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.Struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.List(
                        values,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<SetQuantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<Projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<FromSource>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<GroupBy>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<Expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<Expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Expr.Select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
}

