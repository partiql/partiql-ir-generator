/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "FunctionName", "ClassName", "MemberVisibilityCanBePrivate", "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL", "LocalVariableName", "USELESS_ELVIS")


package org.partiql.pig.tests.generated

import javax.annotation.*
import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class toy_lang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: toy_lang_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): toy_lang_node =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): toy_lang_node =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.lit(
                value = value,
                metas = metas)
        
        
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.variable(
                name = name.asPrimitive(),
                metas = metas)
        
        fun variable_(
            name: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.variable(
                name = name,
                metas = metas)
        
        
        fun not(
            expr: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.plus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.minus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.times(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.divide(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.modulo(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.call(
                name = name.asPrimitive(),
                operands = operands,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.call(
                name = name,
                operands = operands,
                metas = metas)
        
        
        fun let(
            name: String,
            value: expr,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            name: SymbolPrimitive,
            value: expr,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.let(
                name = name,
                value = value,
                body = body,
                metas = metas)
        
        
        fun function(
            var_name: String,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.function(
                var_name = var_name.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            var_name: SymbolPrimitive,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang.expr.function(
                var_name = var_name,
                body = body,
                metas = metas)
    }
    
    /** Base class for all toy_lang types. */
    abstract class toy_lang_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): toy_lang_node
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class expr : toy_lang_node() {
    
        class lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): lit =
                lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class variable(
            val name: SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): variable =
                variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != variable::class.java) return false
        
                other as variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): not =
                not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): plus =
                plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): minus =
                minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): times =
                times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): divide =
                divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): modulo =
                modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val name: SymbolPrimitive,
            val operands: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): call =
                call(
                    name = name,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    operands.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (name != other.name) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class let(
            val name: SymbolPrimitive,
            val value: expr,
            val body: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): let =
                let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != let::class.java) return false
        
                other as let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class function(
            val var_name: SymbolPrimitive,
            val body: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): function =
                function(
                    var_name = var_name,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    var_name.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != function::class.java) return false
        
                other as function
                if (var_name != other.var_name) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = var_name.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<toy_lang_node>() {
    
        override fun innerTransform(sexp: SexpElement): toy_lang_node {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    toy_lang.expr.lit(
                        value,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    toy_lang.expr.variable(
                        name,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<expr>()
                    toy_lang.expr.not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang.expr.plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang.expr.minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang.expr.times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang.expr.divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang.expr.modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val operands = sexp.getRequired(1).transformExpect<expr>()
                    toy_lang.expr.call(
                        name,
                        operands,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<expr>()
                    val body = sexp.getRequired(2).transformExpect<expr>()
                    toy_lang.expr.let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val var_name = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<expr>()
                    toy_lang.expr.function(
                        var_name,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
}

class toy_lang_nameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: toy_lang_nameless_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): toy_lang_nameless_node =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): toy_lang_nameless_node =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.lit(
                value = value,
                metas = metas)
        
        
        fun not(
            expr: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.plus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.minus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.times(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.divide(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.modulo(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.call(
                name = name.asPrimitive(),
                operands = operands,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.call(
                name = name,
                operands = operands,
                metas = metas)
        
        
        fun function(
            var_name: String,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.function(
                var_name = var_name.asPrimitive(),
                body = body,
                metas = metas)
        
        fun function_(
            var_name: SymbolPrimitive,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.function(
                var_name = var_name,
                body = body,
                metas = metas)
        
        
        fun variable(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.variable(
                index = index.asPrimitive(),
                metas = metas)
        
        fun variable_(
            index: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.variable(
                index = index,
                metas = metas)
        
        
        fun let(
            index: Long,
            value: expr,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.let(
                index = index.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        fun let_(
            index: LongPrimitive,
            value: expr,
            body: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            toy_lang_nameless.expr.let(
                index = index,
                value = value,
                body = body,
                metas = metas)
    }
    
    /** Base class for all toy_lang_nameless types. */
    abstract class toy_lang_nameless_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): toy_lang_nameless_node
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class expr : toy_lang_nameless_node() {
    
        class lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): lit =
                lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): not =
                not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): plus =
                plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): minus =
                minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): times =
                times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): divide =
                divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): modulo =
                modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val name: SymbolPrimitive,
            val operands: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): call =
                call(
                    name = name,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    operands.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (name != other.name) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class function(
            val var_name: SymbolPrimitive,
            val body: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): function =
                function(
                    var_name = var_name,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    var_name.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != function::class.java) return false
        
                other as function
                if (var_name != other.var_name) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = var_name.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class variable(
            val index: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): variable =
                variable(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != variable::class.java) return false
        
                other as variable
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class let(
            val index: LongPrimitive,
            val value: expr,
            val body: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): let =
                let(
                    index = index,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    index.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != let::class.java) return false
        
                other as let
                if (index != other.index) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<toy_lang_nameless_node>() {
    
        override fun innerTransform(sexp: SexpElement): toy_lang_nameless_node {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    toy_lang_nameless.expr.lit(
                        value,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<expr>()
                    toy_lang_nameless.expr.not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang_nameless.expr.plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang_nameless.expr.minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang_nameless.expr.times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang_nameless.expr.divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    toy_lang_nameless.expr.modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val operands = sexp.getRequired(1).transformExpect<expr>()
                    toy_lang_nameless.expr.call(
                        name,
                        operands,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val var_name = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<expr>()
                    toy_lang_nameless.expr.function(
                        var_name,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    toy_lang_nameless.expr.variable(
                        index,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    val value = sexp.getRequired(1).transformExpect<expr>()
                    val body = sexp.getRequired(2).transformExpect<expr>()
                    toy_lang_nameless.expr.let(
                        index,
                        value,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_nameless'")
            }
        }
    }
}

class test_domain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: test_domain_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): test_domain_node =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): test_domain_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun int_pair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair =
            test_domain.int_pair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun int_pair_(
            first: LongPrimitive,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair =
            test_domain.int_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbol_pair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair =
            test_domain.symbol_pair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbol_pair_(
            first: SymbolPrimitive,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair =
            test_domain.symbol_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ion_pair(
            first: IonElement,
            second: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_pair =
            test_domain.ion_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun int_symbol_pair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): int_symbol_pair =
            test_domain.int_symbol_pair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun int_symbol_pair_(
            first: LongPrimitive,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): int_symbol_pair =
            test_domain.int_symbol_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbol_int_pair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_int_pair =
            test_domain.symbol_int_pair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        fun symbol_int_pair_(
            first: SymbolPrimitive,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_int_pair =
            test_domain.symbol_int_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ion_int_pair(
            firs: IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_int_pair =
            test_domain.ion_int_pair(
                firs = firs,
                second = second.asPrimitive(),
                metas = metas)
        
        fun ion_int_pair_(
            firs: IonElement,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_int_pair =
            test_domain.ion_int_pair(
                firs = firs,
                second = second,
                metas = metas)
        
        
        fun ion_symbol_pair(
            firs: IonElement,
            second: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_symbol_pair =
            test_domain.ion_symbol_pair(
                firs = firs,
                second = second,
                metas = metas)
        
        
        fun int_pair_pair(
            first: int_pair,
            second: int_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair_pair =
            test_domain.int_pair_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbol_pair_pair(
            first: symbol_pair,
            second: symbol_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair_pair =
            test_domain.symbol_pair_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun ion_pair_pair(
            first: ion_pair,
            second: ion_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_pair_pair =
            test_domain.ion_pair_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun recursive_pair(
            first: Long,
            second: recursive_pair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): recursive_pair =
            test_domain.recursive_pair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun recursive_pair_(
            first: LongPrimitive,
            second: recursive_pair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): recursive_pair =
            test_domain.recursive_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answer_pair(
            first: answer,
            second: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_pair =
            test_domain.answer_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answer_int_pair(
            first: answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_int_pair =
            test_domain.answer_int_pair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answer_int_pair_(
            first: answer,
            second: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_int_pair =
            test_domain.answer_int_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun int_answer_pair(
            first: Long,
            second: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): int_answer_pair =
            test_domain.int_answer_pair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun int_answer_pair_(
            first: LongPrimitive,
            second: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): int_answer_pair =
            test_domain.int_answer_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun symbol_answer_pair(
            first: String,
            second: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_answer_pair =
            test_domain.symbol_answer_pair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        fun symbol_answer_pair_(
            first: SymbolPrimitive,
            second: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_answer_pair =
            test_domain.symbol_answer_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun answer_symbol_pair(
            first: answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_symbol_pair =
            test_domain.answer_symbol_pair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        fun answer_symbol_pair_(
            first: answer,
            second: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_symbol_pair =
            test_domain.answer_symbol_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun variadic_min_0(
            ints: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_0_(
            ints: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                ints = ints,
                metas = metas)
        
        fun variadic_min_0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_0_(
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                ints = ints.toList(),
                metas = metas)
        
        
        fun variadic_min_1(
            ints: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_1_(
            ints: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                ints = ints,
                metas = metas)
        
        fun variadic_min_1(
            ints_required_0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                ints = listOfPrimitives(ints_required_0) + ints.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_1_(
            ints_required_0: LongPrimitive,
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                ints = listOfPrimitives(ints_required_0) + ints.toList(),
                metas = metas)
        
        
        fun element_variadic(
            name: String,
            ints: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun element_variadic_(
            name: SymbolPrimitive,
            ints: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                name = name,
                ints = ints,
                metas = metas)
        
        fun element_variadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        fun element_variadic_(
            name: SymbolPrimitive,
            vararg ints: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                name = name,
                ints = ints.toList(),
                metas = metas)
        
        
        fun optional_1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_1 =
            test_domain.optional_1(
                value = value?.asPrimitive(),
                metas = metas)
        
        fun optional_1_(
            value: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_1 =
            test_domain.optional_1(
                value = value,
                metas = metas)
        
        
        fun optional_2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_2 =
            test_domain.optional_2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = metas)
        
        fun optional_2_(
            first: LongPrimitive? = null,
            second: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_2 =
            test_domain.optional_2(
                first = first,
                second = second,
                metas = metas)
        
        
        fun domain_level_record(
            some_field: Long,
            another_field: String,
            optional_field: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): domain_level_record =
            test_domain.domain_level_record(
                some_field = some_field.asPrimitive(),
                another_field = another_field.asPrimitive(),
                optional_field = optional_field?.asPrimitive(),
                metas = metas)
        
        fun domain_level_record_(
            some_field: LongPrimitive,
            another_field: SymbolPrimitive,
            optional_field: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): domain_level_record =
            test_domain.domain_level_record(
                some_field = some_field,
                another_field = another_field,
                optional_field = optional_field,
                metas = metas)
        
        
        fun product_with_record(
            value: Long,
            dlr: domain_level_record,
            metas: MetaContainer = emptyMetaContainer()
        ): product_with_record =
            test_domain.product_with_record(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun product_with_record_(
            value: LongPrimitive,
            dlr: domain_level_record,
            metas: MetaContainer = emptyMetaContainer()
        ): product_with_record =
            test_domain.product_with_record(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        fun entity_pair(
            first: entity,
            second: entity,
            metas: MetaContainer = emptyMetaContainer()
        ): entity_pair =
            test_domain.entity_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        // Variants for Sum: answer 
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): answer =
            test_domain.answer.no(
                metas = metas)
        
        
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): answer =
            test_domain.answer.yes(
                metas = metas)
        
        
        // Variants for Sum: sum_with_record 
        fun variant_with_record(
            value: Long,
            dlr: domain_level_record,
            metas: MetaContainer = emptyMetaContainer()
        ): sum_with_record =
            test_domain.sum_with_record.variant_with_record(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        fun variant_with_record_(
            value: LongPrimitive,
            dlr: domain_level_record,
            metas: MetaContainer = emptyMetaContainer()
        ): sum_with_record =
            test_domain.sum_with_record.variant_with_record(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        // Variants for Sum: entity 
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            test_domain.entity.slug(
                metas = metas)
        
        
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            test_domain.entity.android(
                id = id.asPrimitive(),
                metas = metas)
        
        fun android_(
            id: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            test_domain.entity.android(
                id = id,
                metas = metas)
        
        
        fun human(
            first_name: String,
            last_name: String,
            title: String? = null,
            parent: entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            test_domain.entity.human(
                first_name = first_name.asPrimitive(),
                last_name = last_name.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        fun human_(
            first_name: SymbolPrimitive,
            last_name: SymbolPrimitive,
            title: SymbolPrimitive? = null,
            parent: entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            test_domain.entity.human(
                first_name = first_name,
                last_name = last_name,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all test_domain types. */
    abstract class test_domain_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): test_domain_node
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class int_pair(
        val first: LongPrimitive,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): int_pair =
            int_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_pair::class.java) return false
    
            other as int_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_pair(
        val first: SymbolPrimitive,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): symbol_pair =
            symbol_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_pair::class.java) return false
    
            other as symbol_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_pair(
        val first: IonElement,
        val second: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ion_pair =
            ion_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_pair::class.java) return false
    
            other as ion_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_symbol_pair(
        val first: LongPrimitive,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): int_symbol_pair =
            int_symbol_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_symbol_pair::class.java) return false
    
            other as int_symbol_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_int_pair(
        val first: SymbolPrimitive,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): symbol_int_pair =
            symbol_int_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_int_pair::class.java) return false
    
            other as symbol_int_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_int_pair(
        val firs: IonElement,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ion_int_pair =
            ion_int_pair(
                firs = firs,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                firs.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_int_pair::class.java) return false
    
            other as ion_int_pair
            if (firs != other.firs) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = firs.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_symbol_pair(
        val firs: IonElement,
        val second: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ion_symbol_pair =
            ion_symbol_pair(
                firs = firs,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                firs.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_symbol_pair::class.java) return false
    
            other as ion_symbol_pair
            if (firs != other.firs) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = firs.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_pair_pair(
        val first: int_pair,
        val second: int_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): int_pair_pair =
            int_pair_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_pair_pair::class.java) return false
    
            other as int_pair_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_pair_pair(
        val first: symbol_pair,
        val second: symbol_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): symbol_pair_pair =
            symbol_pair_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_pair_pair::class.java) return false
    
            other as symbol_pair_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_pair_pair(
        val first: ion_pair,
        val second: ion_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ion_pair_pair =
            ion_pair_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_pair_pair::class.java) return false
    
            other as ion_pair_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class recursive_pair(
        val first: LongPrimitive,
        val second: recursive_pair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): recursive_pair =
            recursive_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != recursive_pair::class.java) return false
    
            other as recursive_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_pair(
        val first: answer,
        val second: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): answer_pair =
            answer_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_pair::class.java) return false
    
            other as answer_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_int_pair(
        val first: answer,
        val second: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): answer_int_pair =
            answer_int_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_int_pair::class.java) return false
    
            other as answer_int_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_answer_pair(
        val first: LongPrimitive,
        val second: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): int_answer_pair =
            int_answer_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_answer_pair::class.java) return false
    
            other as int_answer_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_answer_pair(
        val first: SymbolPrimitive,
        val second: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): symbol_answer_pair =
            symbol_answer_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_answer_pair::class.java) return false
    
            other as symbol_answer_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_symbol_pair(
        val first: answer,
        val second: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): answer_symbol_pair =
            answer_symbol_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_symbol_pair::class.java) return false
    
            other as answer_symbol_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class variadic_min_0(
        val ints: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): variadic_min_0 =
            variadic_min_0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != variadic_min_0::class.java) return false
    
            other as variadic_min_0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class variadic_min_1(
        val ints: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): variadic_min_1 =
            variadic_min_1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != variadic_min_1::class.java) return false
    
            other as variadic_min_1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class element_variadic(
        val name: SymbolPrimitive,
        val ints: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): element_variadic =
            element_variadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != element_variadic::class.java) return false
    
            other as element_variadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class optional_1(
        val value: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): optional_1 =
            optional_1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != optional_1::class.java) return false
    
            other as optional_1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class optional_2(
        val first: LongPrimitive?,
        val second: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): optional_2 =
            optional_2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != optional_2::class.java) return false
    
            other as optional_2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class domain_level_record(
        val some_field: LongPrimitive,
        val another_field: SymbolPrimitive,
        val optional_field: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): domain_level_record =
            domain_level_record(
                some_field = some_field,
                another_field = another_field,
                optional_field = optional_field,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                some_field?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                another_field?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optional_field?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != domain_level_record::class.java) return false
    
            other as domain_level_record
            if (some_field != other.some_field) return false
            if (another_field != other.another_field) return false
            if (optional_field != other.optional_field) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = some_field.hashCode()
            hc = 31 * hc + another_field.hashCode()
            hc = 31 * hc + optional_field.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class product_with_record(
        val value: LongPrimitive,
        val dlr: domain_level_record,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): product_with_record =
            product_with_record(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != product_with_record::class.java) return false
    
            other as product_with_record
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class entity_pair(
        val first: entity,
        val second: entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): entity_pair =
            entity_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != entity_pair::class.java) return false
    
            other as entity_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class answer : test_domain_node() {
    
        class no(
            override val metas: MetaContainer = emptyMetaContainer()
        ): answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): no =
                no(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != no::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): yes =
                yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class sum_with_record : test_domain_node() {
    
        class variant_with_record(
            val value: LongPrimitive,
            val dlr: domain_level_record,
            override val metas: MetaContainer = emptyMetaContainer()
        ): sum_with_record() {
        
            override fun withMeta(metaKey: String, metaValue: Any): variant_with_record =
                variant_with_record(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != variant_with_record::class.java) return false
        
                other as variant_with_record
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class entity : test_domain_node() {
    
        class slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): slug =
                slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class android(
            val id: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): android =
                android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != android::class.java) return false
        
                other as android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class human(
            val first_name: SymbolPrimitive,
            val last_name: SymbolPrimitive,
            val title: SymbolPrimitive?,
            val parent: entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): human =
                human(
                    first_name = first_name,
                    last_name = last_name,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    first_name?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    last_name?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != human::class.java) return false
        
                other as human
                if (first_name != other.first_name) return false
                if (last_name != other.last_name) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = first_name.hashCode()
                hc = 31 * hc + last_name.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<test_domain_node>() {
    
        override fun innerTransform(sexp: SexpElement): test_domain_node {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    test_domain.int_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    test_domain.symbol_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    test_domain.ion_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    test_domain.int_symbol_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    test_domain.symbol_int_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val firs = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    test_domain.ion_int_pair(
                        firs,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val firs = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    test_domain.ion_symbol_pair(
                        firs,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<int_pair>()
                    val second = sexp.getRequired(1).transformExpect<int_pair>()
                    test_domain.int_pair_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<symbol_pair>()
                    val second = sexp.getRequired(1).transformExpect<symbol_pair>()
                    test_domain.symbol_pair_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<ion_pair>()
                    val second = sexp.getRequired(1).transformExpect<ion_pair>()
                    test_domain.ion_pair_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<recursive_pair>()
                    test_domain.recursive_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<answer>()
                    val second = sexp.getRequired(1).transformExpect<answer>()
                    test_domain.answer_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    test_domain.answer_int_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<answer>()
                    test_domain.int_answer_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<answer>()
                    test_domain.symbol_answer_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    test_domain.answer_symbol_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    test_domain.variadic_min_0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    test_domain.variadic_min_1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    test_domain.element_variadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    test_domain.optional_1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    test_domain.optional_2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val some_field = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val another_field = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optional_field = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    domain_level_record(some_field, another_field, optional_field, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<domain_level_record>()
                    test_domain.product_with_record(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<entity>()
                    val second = sexp.getRequired(1).transformExpect<entity>()
                    test_domain.entity_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    test_domain.answer.no(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    test_domain.answer.yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'sum_with_record'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<domain_level_record>()
                    test_domain.sum_with_record.variant_with_record(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    test_domain.entity.slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    test_domain.entity.android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val first_name = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val last_name = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    entity.human(first_name, last_name, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
}

class partiql_basic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: partiql_basic_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: AnyElement): partiql_basic_node =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): partiql_basic_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun expr_pair(
            first: expr,
            second: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr_pair =
            partiql_basic.expr_pair(
                first = first,
                second = second,
                metas = metas)
        
        
        fun group_by_item(
            value: expr,
            as_alias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic.group_by_item(
                value = value,
                as_alias = as_alias?.asPrimitive(),
                metas = metas)
        
        fun group_by_item_(
            value: expr,
            as_alias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic.group_by_item(
                value = value,
                as_alias = as_alias,
                metas = metas)
        
        
        fun group_by_list(
            items: List<group_by_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic.group_by_list(
                items = items,
                metas = metas)
        
        fun group_by_list(
            items_required_0: group_by_item,
            vararg items: group_by_item,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic.group_by_list(
                items = listOf(items_required_0) + items.toList(),
                metas = metas)
        
        
        fun group_by(
            items: group_by_list,
            group_as_alias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic.group_by(
                items = items,
                group_as_alias = group_as_alias?.asPrimitive(),
                metas = metas)
        
        fun group_by_(
            items: group_by_list,
            group_as_alias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic.group_by(
                items = items,
                group_as_alias = group_as_alias,
                metas = metas)
        
        
        // Variants for Sum: projection 
        fun project_list(
            items: List<project_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            partiql_basic.projection.project_list(
                items = items,
                metas = metas)
        
        fun project_list(
            items_required_0: project_item,
            vararg items: project_item,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            partiql_basic.projection.project_list(
                items = listOf(items_required_0) + items.toList(),
                metas = metas)
        
        
        fun project_value(
            value: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            partiql_basic.projection.project_value(
                value = value,
                metas = metas)
        
        
        // Variants for Sum: project_item 
        fun project_all(
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            partiql_basic.project_item.project_all(
                metas = metas)
        
        
        fun project_expr(
            value: expr,
            as_alias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            partiql_basic.project_item.project_expr(
                value = value,
                as_alias = as_alias?.asPrimitive(),
                metas = metas)
        
        fun project_expr_(
            value: expr,
            as_alias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            partiql_basic.project_item.project_expr(
                value = value,
                as_alias = as_alias,
                metas = metas)
        
        
        // Variants for Sum: join_type 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            partiql_basic.join_type.inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            partiql_basic.join_type.left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            partiql_basic.join_type.right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            partiql_basic.join_type.outer(
                metas = metas)
        
        
        // Variants for Sum: from_source 
        fun scan(
            expr: expr,
            as_alias: String? = null,
            at_alias: String? = null,
            by_alias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            partiql_basic.from_source.scan(
                expr = expr,
                as_alias = as_alias?.asPrimitive(),
                at_alias = at_alias?.asPrimitive(),
                by_alias = by_alias?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr: expr,
            as_alias: SymbolPrimitive? = null,
            at_alias: SymbolPrimitive? = null,
            by_alias: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            partiql_basic.from_source.scan(
                expr = expr,
                as_alias = as_alias,
                at_alias = at_alias,
                by_alias = by_alias,
                metas = metas)
        
        
        fun join(
            type: join_type,
            left: from_source,
            right: from_source,
            predicate: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            partiql_basic.from_source.join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = metas)
        
        
        // Variants for Sum: case_sensitivity 
        fun case_sensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            partiql_basic.case_sensitivity.case_sensitive(
                metas = metas)
        
        
        fun case_insensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            partiql_basic.case_sensitivity.case_insensitive(
                metas = metas)
        
        
        // Variants for Sum: scope_qualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            partiql_basic.scope_qualifier.unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            partiql_basic.scope_qualifier.qualified(
                metas = metas)
        
        
        // Variants for Sum: set_quantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            partiql_basic.set_quantifier.all(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            partiql_basic.set_quantifier.distinct(
                metas = metas)
        
        
        // Variants for Sum: path_element 
        fun path_expr(
            expr: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            partiql_basic.path_element.path_expr(
                expr = expr,
                metas = metas)
        
        
        fun path_wildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            partiql_basic.path_element.path_wildcard(
                metas = metas)
        
        
        fun path_unpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            partiql_basic.path_element.path_unpivot(
                metas = metas)
        
        
        // Variants for Sum: expr 
        fun lit(
            value: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.lit(
                value = value,
                metas = metas)
        
        
        fun id(
            name: String,
            case: case_sensitivity,
            scope_qualifier: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.id(
                name = name.asPrimitive(),
                case = case,
                scope_qualifier = scope_qualifier,
                metas = metas)
        
        fun id_(
            name: SymbolPrimitive,
            case: case_sensitivity,
            scope_qualifier: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.id(
                name = name,
                case = case,
                scope_qualifier = scope_qualifier,
                metas = metas)
        
        
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.parameter(
                index = index.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            index: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.parameter(
                index = index,
                metas = metas)
        
        
        fun not(
            expr: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.not(
                expr = expr,
                metas = metas)
        
        
        fun plus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.plus(
                operands = operands,
                metas = metas)
        
        fun plus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.plus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun minus(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.minus(
                operands = operands,
                metas = metas)
        
        fun minus(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.minus(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun times(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.times(
                operands = operands,
                metas = metas)
        
        fun times(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.times(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun divide(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.divide(
                operands = operands,
                metas = metas)
        
        fun divide(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.divide(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun modulo(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.modulo(
                operands = operands,
                metas = metas)
        
        fun modulo(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.modulo(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun concat(
            operands: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.concat(
                operands = operands,
                metas = metas)
        
        fun concat(
            operands_required_0: expr,
            operands_required_1: expr,
            vararg operands: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.concat(
                operands = listOf(operands_required_0, operands_required_1) + operands.toList(),
                metas = metas)
        
        
        fun like(
            left: expr,
            right: expr,
            escape: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.like(
                left = left,
                right = right,
                escape = escape,
                metas = metas)
        
        
        fun between(
            value: expr,
            from: expr,
            to: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.between(
                value = value,
                from = from,
                to = to,
                metas = metas)
        
        
        fun path(
            root: expr,
            elements: List<path_element>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.path(
                root = root,
                elements = elements,
                metas = metas)
        
        fun path(
            root: expr,
            elements_required_0: path_element,
            vararg elements: path_element,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.path(
                root = root,
                elements = listOf(elements_required_0) + elements.toList(),
                metas = metas)
        
        
        fun call(
            name: String,
            args: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call(
                name = name.asPrimitive(),
                args = args,
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            args: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call(
                name = name,
                args = args,
                metas = metas)
        
        fun call(
            name: String,
            args_required_0: expr,
            vararg args: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call(
                name = name.asPrimitive(),
                args = listOf(args_required_0) + args.toList(),
                metas = metas)
        
        fun call_(
            name: SymbolPrimitive,
            args_required_0: expr,
            vararg args: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call(
                name = name,
                args = listOf(args_required_0) + args.toList(),
                metas = metas)
        
        
        fun call_agg(
            name: String,
            set_quantifier: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call_agg(
                name = name.asPrimitive(),
                set_quantifier = set_quantifier,
                metas = metas)
        
        fun call_agg_(
            name: SymbolPrimitive,
            set_quantifier: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.call_agg(
                name = name,
                set_quantifier = set_quantifier,
                metas = metas)
        
        
        fun simple_case(
            value: expr,
            branches: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.simple_case(
                value = value,
                branches = branches,
                metas = metas)
        
        fun simple_case(
            value: expr,
            branches_required_0: expr_pair,
            vararg branches: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.simple_case(
                value = value,
                branches = listOf(branches_required_0) + branches.toList(),
                metas = metas)
        
        
        fun searched_case(
            branches: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.searched_case(
                branches = branches,
                metas = metas)
        
        fun searched_case(
            branches_required_0: expr_pair,
            vararg branches: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.searched_case(
                branches = listOf(branches_required_0) + branches.toList(),
                metas = metas)
        
        
        fun struct(
            fields: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.struct(
                fields = fields,
                metas = metas)
        
        fun struct(
            vararg fields: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.struct(
                fields = fields.toList(),
                metas = metas)
        
        
        fun bag(
            values: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.bag(
                values = values,
                metas = metas)
        
        fun bag(
            vararg values: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.bag(
                values = values.toList(),
                metas = metas)
        
        
        fun list(
            values: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.list(
                values = values,
                metas = metas)
        
        fun list(
            vararg values: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.list(
                values = values.toList(),
                metas = metas)
        
        
        fun select(
            setq: set_quantifier? = null,
            project: projection,
            from: from_source,
            where: expr? = null,
            group: group_by? = null,
            having: expr? = null,
            limit: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            partiql_basic.expr.select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = metas)
    }
    
    /** Base class for all partiql_basic types. */
    abstract class partiql_basic_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): partiql_basic_node
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class expr_pair(
        val first: expr,
        val second: expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): expr_pair =
            expr_pair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != expr_pair::class.java) return false
    
            other as expr_pair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_item(
        val value: expr,
        val as_alias: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): group_by_item =
            group_by_item(
                value = value,
                as_alias = as_alias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                value.toIonElement(),
                as_alias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_item::class.java) return false
    
            other as group_by_item
            if (value != other.value) return false
            if (as_alias != other.as_alias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + as_alias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_list(
        val items: List<group_by_item>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): group_by_list =
            group_by_list(
                items = items,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *items.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_list::class.java) return false
    
            other as group_by_list
            if (items != other.items) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by(
        val items: group_by_list,
        val group_as_alias: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(metaKey: String, metaValue: Any): group_by =
            group_by(
                items = items,
                group_as_alias = group_as_alias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                items.toIonElement(),
                group_as_alias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by::class.java) return false
    
            other as group_by
            if (items != other.items) return false
            if (group_as_alias != other.group_as_alias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc = 31 * hc + group_as_alias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class projection : partiql_basic_node() {
    
        class project_list(
            val items: List<project_item>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): project_list =
                project_list(
                    items = items,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *items.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_list::class.java) return false
        
                other as project_list
                if (items != other.items) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = items.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class project_value(
            val value: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): project_value =
                project_value(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_value::class.java) return false
        
                other as project_value
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class project_item : partiql_basic_node() {
    
        class project_all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): project_item() {
        
            override fun withMeta(metaKey: String, metaValue: Any): project_all =
                project_all(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class project_expr(
            val value: expr,
            val as_alias: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): project_item() {
        
            override fun withMeta(metaKey: String, metaValue: Any): project_expr =
                project_expr(
                    value = value,
                    as_alias = as_alias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    value.toIonElement(),
                    as_alias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_expr::class.java) return false
        
                other as project_expr
                if (value != other.value) return false
                if (as_alias != other.as_alias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + as_alias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class join_type : partiql_basic_node() {
    
        class inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(metaKey: String, metaValue: Any): inner =
                inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(metaKey: String, metaValue: Any): left =
                left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(metaKey: String, metaValue: Any): right =
                right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(metaKey: String, metaValue: Any): outer =
                outer(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
    }
    
    sealed class from_source : partiql_basic_node() {
    
        class scan(
            val expr: expr,
            val as_alias: SymbolPrimitive?,
            val at_alias: SymbolPrimitive?,
            val by_alias: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(metaKey: String, metaValue: Any): scan =
                scan(
                    expr = expr,
                    as_alias = as_alias,
                    at_alias = at_alias,
                    by_alias = by_alias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    as_alias?.toIonElement() ?: ionNull(),
                    at_alias?.toIonElement() ?: ionNull(),
                    by_alias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != scan::class.java) return false
        
                other as scan
                if (expr != other.expr) return false
                if (as_alias != other.as_alias) return false
                if (at_alias != other.at_alias) return false
                if (by_alias != other.by_alias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc = 31 * hc + as_alias.hashCode()
                hc = 31 * hc + at_alias.hashCode()
                hc = 31 * hc + by_alias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class join(
            val type: join_type,
            val left: from_source,
            val right: from_source,
            val predicate: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(metaKey: String, metaValue: Any): join =
                join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != join::class.java) return false
        
                other as join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class case_sensitivity : partiql_basic_node() {
    
        class case_sensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): case_sensitive =
                case_sensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_sensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class case_insensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): case_insensitive =
                case_insensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_insensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class scope_qualifier : partiql_basic_node() {
    
        class unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): unqualified =
                unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): qualified =
                qualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
    }
    
    sealed class set_quantifier : partiql_basic_node() {
    
        class all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): all =
                all(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): distinct =
                distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
    }
    
    sealed class path_element : partiql_basic_node() {
    
        class path_expr(
            val expr: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(metaKey: String, metaValue: Any): path_expr =
                path_expr(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_expr::class.java) return false
        
                other as path_expr
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path_wildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(metaKey: String, metaValue: Any): path_wildcard =
                path_wildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_wildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class path_unpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(metaKey: String, metaValue: Any): path_unpivot =
                path_unpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_unpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
    }
    
    sealed class expr : partiql_basic_node() {
    
        class lit(
            val value: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): lit =
                lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class id(
            val name: SymbolPrimitive,
            val case: case_sensitivity,
            val scope_qualifier: scope_qualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): id =
                id(
                    name = name,
                    case = case,
                    scope_qualifier = scope_qualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    scope_qualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != id::class.java) return false
        
                other as id
                if (name != other.name) return false
                if (case != other.case) return false
                if (scope_qualifier != other.scope_qualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + scope_qualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class parameter(
            val index: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): parameter =
                parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != parameter::class.java) return false
        
                other as parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): not =
                not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): plus =
                plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): minus =
                minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): times =
                times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): divide =
                divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): modulo =
                modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class concat(
            val operands: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): concat =
                concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != concat::class.java) return false
        
                other as concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class like(
            val left: expr,
            val right: expr,
            val escape: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): like =
                like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    left.toIonElement(),
                    right.toIonElement(),
                    escape.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != like::class.java) return false
        
                other as like
                if (left != other.left) return false
                if (right != other.right) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class between(
            val value: expr,
            val from: expr,
            val to: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): between =
                between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != between::class.java) return false
        
                other as between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path(
            val root: expr,
            val elements: List<path_element>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): path =
                path(
                    root = root,
                    elements = elements,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *elements.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path::class.java) return false
        
                other as path
                if (root != other.root) return false
                if (elements != other.elements) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = root.hashCode()
                hc = 31 * hc + elements.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val name: SymbolPrimitive,
            val args: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): call =
                call(
                    name = name,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (name != other.name) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call_agg(
            val name: SymbolPrimitive,
            val set_quantifier: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): call_agg =
                call_agg(
                    name = name,
                    set_quantifier = set_quantifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    name.toIonElement(),
                    set_quantifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call_agg::class.java) return false
        
                other as call_agg
                if (name != other.name) return false
                if (set_quantifier != other.set_quantifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + set_quantifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class simple_case(
            val value: expr,
            val branches: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): simple_case =
                simple_case(
                    value = value,
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    value.toIonElement(),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != simple_case::class.java) return false
        
                other as simple_case
                if (value != other.value) return false
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class searched_case(
            val branches: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): searched_case =
                searched_case(
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != searched_case::class.java) return false
        
                other as searched_case
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class struct(
            val fields: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): struct =
                struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != struct::class.java) return false
        
                other as struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class bag(
            val values: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): bag =
                bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != bag::class.java) return false
        
                other as bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class list(
            val values: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): list =
                list(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != list::class.java) return false
        
                other as list
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class select(
            val setq: set_quantifier?,
            val project: projection,
            val from: from_source,
            val where: expr?,
            val group: group_by?,
            val having: expr?,
            val limit: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): select =
                select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != select::class.java) return false
        
                other as select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<partiql_basic_node>() {
    
        override fun innerTransform(sexp: SexpElement): partiql_basic_node {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<expr>()
                    val second = sexp.getRequired(1).transformExpect<expr>()
                    partiql_basic.expr_pair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<expr>()
                    val as_alias = sexp.getOptional(1)?.toSymbolPrimitive()
                    partiql_basic.group_by_item(
                        value,
                        as_alias,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<group_by_item>() }
                    partiql_basic.group_by_list(
                        items,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val items = sexp.getRequired(0).transformExpect<group_by_list>()
                    val group_as_alias = sexp.getOptional(1)?.toSymbolPrimitive()
                    partiql_basic.group_by(
                        items,
                        group_as_alias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<project_item>() }
                    partiql_basic.projection.project_list(
                        items,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<expr>()
                    partiql_basic.projection.project_value(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'project_item'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.project_item.project_all(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<expr>()
                    val as_alias = sexp.getOptional(1)?.toSymbolPrimitive()
                    partiql_basic.project_item.project_expr(
                        value,
                        as_alias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'join_type'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.join_type.inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.join_type.left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.join_type.right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.join_type.outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'from_source'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<expr>()
                    val as_alias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val at_alias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val by_alias = sexp.getOptional(3)?.toSymbolPrimitive()
                    partiql_basic.from_source.scan(
                        expr,
                        as_alias,
                        at_alias,
                        by_alias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<join_type>()
                    val left = sexp.getRequired(1).transformExpect<from_source>()
                    val right = sexp.getRequired(2).transformExpect<from_source>()
                    val predicate = sexp.getOptional(3)?.transformExpect<expr>()
                    partiql_basic.from_source.join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'case_sensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.case_sensitivity.case_sensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.case_sensitivity.case_insensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'scope_qualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.scope_qualifier.unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.scope_qualifier.qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'set_quantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.set_quantifier.all(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.set_quantifier.distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'path_element'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<expr>()
                    partiql_basic.path_element.path_expr(
                        expr,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.path_element.path_wildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    partiql_basic.path_element.path_unpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    partiql_basic.expr.lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<case_sensitivity>()
                    val scope_qualifier = sexp.getRequired(2).transformExpect<scope_qualifier>()
                    partiql_basic.expr.id(
                        name,
                        case,
                        scope_qualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    partiql_basic.expr.parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<expr>()
                    partiql_basic.expr.not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.concat(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val left = sexp.getRequired(0).transformExpect<expr>()
                    val right = sexp.getRequired(1).transformExpect<expr>()
                    val escape = sexp.getRequired(2).transformExpect<expr>()
                    partiql_basic.expr.like(
                        left,
                        right,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<expr>()
                    val from = sexp.getRequired(1).transformExpect<expr>()
                    val to = sexp.getRequired(2).transformExpect<expr>()
                    partiql_basic.expr.between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<expr>()
                    val elements = sexp.values.drop(2).map { it.transformExpect<path_element>() }
                    partiql_basic.expr.path(
                        root,
                        elements,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<expr>() }
                    partiql_basic.expr.call(
                        name,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val set_quantifier = sexp.getRequired(1).transformExpect<expr>()
                    partiql_basic.expr.call_agg(
                        name,
                        set_quantifier,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val value = sexp.getRequired(0).transformExpect<expr>()
                    val branches = sexp.values.drop(2).map { it.transformExpect<expr_pair>() }
                    partiql_basic.expr.simple_case(
                        value,
                        branches,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val branches = sexp.values.drop(1).map { it.transformExpect<expr_pair>() }
                    partiql_basic.expr.searched_case(
                        branches,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<expr_pair>() }
                    partiql_basic.expr.struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<expr>() }
                    partiql_basic.expr.list(
                        values,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<set_quantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<from_source>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<group_by>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    expr.select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
}

