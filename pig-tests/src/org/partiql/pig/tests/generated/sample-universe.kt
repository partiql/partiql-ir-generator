/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
    "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
    "USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = TestDomainBuilder
    
        fun <T: TestDomainNode> build(block: Builder.() -> T) =
            TestDomainBuilder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [TestDomain.BoolPair].
         */
        fun boolPair(
            first: Boolean,
            second: Boolean,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.BoolPair =
            TestDomain.BoolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.BoolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun boolPair_(
            first: org.partiql.pig.runtime.BoolPrimitive,
            second: org.partiql.pig.runtime.BoolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.BoolPair =
            TestDomain.BoolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         */
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         */
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonPair].
         */
        fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPair =
            TestDomain.IonPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         */
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         */
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         */
        fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonSymbolPair].
         */
        fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonSymbolPair =
            TestDomain.IonSymbolPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntPairPair].
         */
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPairPair].
         */
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IonPairPair].
         */
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         */
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerPair].
         */
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         */
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         */
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         */
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         */
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            ints: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name?.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         */
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         */
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive? = null,
            second: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         */
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         */
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSumTriplet].
         */
        fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSumTriplet =
            TestDomain.TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.EntityPair].
         */
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Answer 
        /**
         * Creates an instance of [TestDomain.Answer.No].
         */
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.No =
            TestDomain.Answer.No(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Answer.Yes].
         */
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.Yes =
            TestDomain.Answer.Yes(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumWithRecord 
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         */
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: TestSum 
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         */
        fun one(
            a: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         */
        fun two(
            a: Long,
            b: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a,
                b = b,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         */
        fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                c = c.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a,
                b = b,
                c = c,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Entity 
        /**
         * Creates an instance of [TestDomain.Entity.Slug].
         */
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Slug =
            TestDomain.Entity.Slug(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         */
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         */
        fun human(
            firstName: String,
            middleNames: kotlin.collections.List<String> = emptyList(),
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                middleNames = middleNames.map { it.asPrimitive() },
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive> = emptyList(),
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName,
                middleNames = middleNames,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object TestDomainBuilder : Builder
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): TestDomainNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class BoolPair(
        val first: org.partiql.pig.runtime.BoolPrimitive,
        val second: org.partiql.pig.runtime.BoolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): BoolPair =
            BoolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): BoolPair =
            BoolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("bool_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.BoolPrimitive = this.first,
            second: org.partiql.pig.runtime.BoolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            BoolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != BoolPair::class.java) return false
    
            other as BoolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IntPair = this.first,
            second: IntPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: SymbolPair = this.first,
            second: SymbolPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IonPair = this.first,
            second: IonPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: RecursivePair? = this.second,
            metas: MetaContainer = this.metas
        ) =
            RecursivePair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin0(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin1(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            ElementVariadic(
                name,
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): Optional1 =
            Optional1(
                value = value,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive? = this.value,
            metas: MetaContainer = this.metas
        ) =
            Optional1(
                value,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: org.partiql.pig.runtime.LongPrimitive?,
        val second: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive? = this.first,
            second: org.partiql.pig.runtime.LongPrimitive? = this.second,
            metas: MetaContainer = this.metas
        ) =
            Optional2(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: org.partiql.pig.runtime.LongPrimitive,
        val anotherField: org.partiql.pig.runtime.SymbolPrimitive,
        val optionalField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            someField: org.partiql.pig.runtime.LongPrimitive = this.someField,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive = this.anotherField,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = this.optionalField,
            metas: MetaContainer = this.metas
        ) =
            DomainLevelRecord(
                someField,
                anotherField,
                optionalField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: org.partiql.pig.runtime.LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive = this.value,
            dlr: DomainLevelRecord = this.dlr,
            metas: MetaContainer = this.metas
        ) =
            ProductWithRecord(
                value,
                dlr,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class TestSumTriplet(
        val a: TestSum,
        val b: TestSum,
        val c: TestSum,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("test_sum_triplet"),
                a.toIonElement(),
                b.toIonElement(),
                c.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            a: TestSum = this.a,
            b: TestSum = this.b,
            c: TestSum = this.c,
            metas: MetaContainer = this.metas
        ) =
            TestSumTriplet(
                a,
                b,
                c,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TestSumTriplet::class.java) return false
    
            other as TestSumTriplet
            if (a != other.a) return false
            if (b != other.b) return false
            if (c != other.c) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = a.hashCode()
            hc = 31 * hc + b.hashCode()
            hc = 31 * hc + c.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copy(metas: MetaContainer): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Entity = this.first,
            second: Entity = this.second,
            metas: MetaContainer = this.metas
        ) =
            EntityPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): Answer =
            when (this) {
                is No -> copy(metas = metas)
                is Yes -> copy(metas = metas)
            }
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copy(metas: MetaContainer): No =
                No(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copy(metas: MetaContainer): Yes =
                Yes(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        /** Converts instances of [TestDomain.Answer] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.Answer): T = when(node) {
                is TestDomain.Answer.No -> convertNo(node)
                is TestDomain.Answer.Yes -> convertYes(node)
            }
    
            fun convertNo(node: TestDomain.Answer.No): T
            fun convertYes(node: TestDomain.Answer.Yes): T
        }
    }
    
    sealed class SumWithRecord(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): SumWithRecord =
            when (this) {
                is VariantWithRecord -> copy(metas = metas)
            }
    
        class VariantWithRecord(
            val value: org.partiql.pig.runtime.LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun copy(metas: MetaContainer): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                dlr: DomainLevelRecord = this.dlr,
                metas: MetaContainer = this.metas
            ) =
                VariantWithRecord(
                    value,
                    dlr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.SumWithRecord] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.SumWithRecord): T = when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> convertVariantWithRecord(node)
            }
    
            fun convertVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): T
        }
    }
    
    sealed class TestSum(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): TestSum =
            when (this) {
                is One -> copy(metas = metas)
                is Two -> copy(metas = metas)
                is Three -> copy(metas = metas)
            }
    
        class One(
            val a: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): One =
                One(
                    a = a,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): One =
                One(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("one"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                metas: MetaContainer = this.metas
            ) =
                One(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != One::class.java) return false
        
                other as One
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Two(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("two"),
                    a.toIonElement(),
                    b.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                metas: MetaContainer = this.metas
            ) =
                Two(
                    a,
                    b,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Two::class.java) return false
        
                other as Two
                if (a != other.a) return false
                if (b != other.b) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Three(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            val c: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copy(metas: MetaContainer): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("three"),
                    a.toIonElement(),
                    b.toIonElement(),
                    c.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                c: org.partiql.pig.runtime.LongPrimitive = this.c,
                metas: MetaContainer = this.metas
            ) =
                Three(
                    a,
                    b,
                    c,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Three::class.java) return false
        
                other as Three
                if (a != other.a) return false
                if (b != other.b) return false
                if (c != other.c) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc = 31 * hc + c.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.TestSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.TestSum): T = when(node) {
                is TestDomain.TestSum.One -> convertOne(node)
                is TestDomain.TestSum.Two -> convertTwo(node)
                is TestDomain.TestSum.Three -> convertThree(node)
            }
    
            fun convertOne(node: TestDomain.TestSum.One): T
            fun convertTwo(node: TestDomain.TestSum.Two): T
            fun convertThree(node: TestDomain.TestSum.Three): T
        }
    }
    
    sealed class Entity(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copy(metas: MetaContainer): Entity =
            when (this) {
                is Slug -> copy(metas = metas)
                is Android -> copy(metas = metas)
                is Human -> copy(metas = metas)
            }
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Slug =
                Slug(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class Android(
            val id: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Android =
                Android(
                    id = id,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                id: org.partiql.pig.runtime.LongPrimitive = this.id,
                metas: MetaContainer = this.metas
            ) =
                Android(
                    id,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: org.partiql.pig.runtime.SymbolPrimitive,
            val middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive>,
            val lastName: org.partiql.pig.runtime.SymbolPrimitive,
            val title: org.partiql.pig.runtime.SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copy(metas: MetaContainer): Human =
                Human(
                    firstName = firstName,
                    middleNames = middleNames,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    middleNames = middleNames,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    if(middleNames.any()) { ionSexpOf(ionSymbol("middle_names"), *middleNames.map { it.toIonElement() }.toTypedArray()) } else { null },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                firstName: org.partiql.pig.runtime.SymbolPrimitive = this.firstName,
                middleNames: kotlin.collections.List<org.partiql.pig.runtime.SymbolPrimitive> = this.middleNames,
                lastName: org.partiql.pig.runtime.SymbolPrimitive = this.lastName,
                title: org.partiql.pig.runtime.SymbolPrimitive? = this.title,
                parent: Entity? = this.parent,
                metas: MetaContainer = this.metas
            ) =
                Human(
                    firstName,
                    middleNames,
                    lastName,
                    title,
                    parent,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (middleNames != other.middleNames) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = firstName.hashCode()
                hc = 31 * hc + middleNames.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [TestDomain.Entity] to any [T]. */
        interface Converter<T> {
            fun convert(node: TestDomain.Entity): T = when(node) {
                is TestDomain.Entity.Slug -> convertSlug(node)
                is TestDomain.Entity.Android -> convertAndroid(node)
                is TestDomain.Entity.Human -> convertHuman(node)
            }
    
            fun convertSlug(node: TestDomain.Entity.Slug): T
            fun convertAndroid(node: TestDomain.Entity.Android): T
            fun convertHuman(node: TestDomain.Entity.Human): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "bool_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toBoolPrimitive()
                    val second = sexp.getRequired(1).toBoolPrimitive()
                    TestDomain.BoolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "test_sum_triplet" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).transformExpect<TestSum>()
                    val b = sexp.getRequired(1).transformExpect<TestSum>()
                    val c = sexp.getRequired(2).transformExpect<TestSum>()
                    TestDomain.TestSumTriplet(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'TestSum'
                //////////////////////////////////////
                "one" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.TestSum.One(
                        a,
                        metas = sexp.metas)
                }
                "two" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.TestSum.Two(
                        a,
                        b,
                        metas = sexp.metas)
                }
                "three" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    val c = sexp.getRequired(2).toLongPrimitive()
                    TestDomain.TestSum.Three(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val middleNames = ir.processVariadicField("middle_names", 0) { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, middleNames, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitBoolPair(node: TestDomain.BoolPair) { }
        open fun visitIntPair(node: TestDomain.IntPair) { }
        open fun visitSymbolPair(node: TestDomain.SymbolPair) { }
        open fun visitIonPair(node: TestDomain.IonPair) { }
        open fun visitIntSymbolPair(node: TestDomain.IntSymbolPair) { }
        open fun visitSymbolIntPair(node: TestDomain.SymbolIntPair) { }
        open fun visitIonIntPair(node: TestDomain.IonIntPair) { }
        open fun visitIonSymbolPair(node: TestDomain.IonSymbolPair) { }
        open fun visitIntPairPair(node: TestDomain.IntPairPair) { }
        open fun visitSymbolPairPair(node: TestDomain.SymbolPairPair) { }
        open fun visitIonPairPair(node: TestDomain.IonPairPair) { }
        open fun visitRecursivePair(node: TestDomain.RecursivePair) { }
        open fun visitAnswerPair(node: TestDomain.AnswerPair) { }
        open fun visitAnswerIntPair(node: TestDomain.AnswerIntPair) { }
        open fun visitIntAnswerPair(node: TestDomain.IntAnswerPair) { }
        open fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) { }
        open fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) { }
        open fun visitVariadicMin0(node: TestDomain.VariadicMin0) { }
        open fun visitVariadicMin1(node: TestDomain.VariadicMin1) { }
        open fun visitElementVariadic(node: TestDomain.ElementVariadic) { }
        open fun visitOptional1(node: TestDomain.Optional1) { }
        open fun visitOptional2(node: TestDomain.Optional2) { }
        open fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord) { }
        open fun visitProductWithRecord(node: TestDomain.ProductWithRecord) { }
        open fun visitTestSumTriplet(node: TestDomain.TestSumTriplet) { }
        open fun visitEntityPair(node: TestDomain.EntityPair) { }
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        protected open fun visitAnswer(node: TestDomain.Answer) { }
        protected open fun visitAnswerNo(node: TestDomain.Answer.No) { }
        protected open fun visitAnswerYes(node: TestDomain.Answer.Yes) { }
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        protected open fun visitSumWithRecord(node: TestDomain.SumWithRecord) { }
        protected open fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) { }
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        protected open fun visitTestSum(node: TestDomain.TestSum) { }
        protected open fun visitTestSumOne(node: TestDomain.TestSum.One) { }
        protected open fun visitTestSumTwo(node: TestDomain.TestSum.Two) { }
        protected open fun visitTestSumThree(node: TestDomain.TestSum.Three) { }
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        protected open fun visitEntity(node: TestDomain.Entity) { }
        protected open fun visitEntitySlug(node: TestDomain.Entity.Slug) { }
        protected open fun visitEntityAndroid(node: TestDomain.Entity.Android) { }
        protected open fun visitEntityHuman(node: TestDomain.Entity.Human) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkBoolPair(node: TestDomain.BoolPair) {
            visitBoolPair(node)
            walkBoolPrimitive(node.first)
            walkBoolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPair(node: TestDomain.IntPair) {
            visitIntPair(node)
            walkLongPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair) {
            visitSymbolPair(node)
            walkSymbolPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPair(node: TestDomain.IonPair) {
            visitIonPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair) {
            visitIntSymbolPair(node)
            walkLongPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair) {
            visitSymbolIntPair(node)
            walkSymbolPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair) {
            visitIonIntPair(node)
            walkAnyElement(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair) {
            visitIonSymbolPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair) {
            visitIntPairPair(node)
            walkIntPair(node.first)
            walkIntPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair) {
            visitSymbolPairPair(node)
            walkSymbolPair(node.first)
            walkSymbolPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair) {
            visitIonPairPair(node)
            walkIonPair(node.first)
            walkIonPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair) {
            visitRecursivePair(node)
            walkLongPrimitive(node.first)
            node.second?.let { walkRecursivePair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair) {
            visitAnswerPair(node)
            walkAnswer(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair) {
            visitAnswerIntPair(node)
            walkAnswer(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair) {
            visitIntAnswerPair(node)
            walkLongPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) {
            visitSymbolAnswerPair(node)
            walkSymbolPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) {
            visitAnswerSymbolPair(node)
            walkAnswer(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0) {
            visitVariadicMin0(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1) {
            visitVariadicMin1(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic) {
            visitElementVariadic(node)
            walkSymbolPrimitive(node.name)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional1(node: TestDomain.Optional1) {
            visitOptional1(node)
            node.value?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional2(node: TestDomain.Optional2) {
            visitOptional2(node)
            node.first?.let { walkLongPrimitive(it) }
            node.second?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord) {
            visitDomainLevelRecord(node)
            walkLongPrimitive(node.someField)
            walkSymbolPrimitive(node.anotherField)
            node.optionalField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord) {
            visitProductWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet) {
            visitTestSumTriplet(node)
            walkTestSum(node.a)
            walkTestSum(node.b)
            walkTestSum(node.c)
            walkMetas(node.metas)
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair) {
            visitEntityPair(node)
            walkEntity(node.first)
            walkEntity(node.second)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer) {
            visitAnswer(node)
            when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node)
                is TestDomain.Answer.Yes -> walkAnswerYes(node)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No) {
            visitAnswerNo(node)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes) {
            visitAnswerYes(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord) {
            visitSumWithRecord(node)
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) {
            visitSumWithRecordVariantWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum) {
            visitTestSum(node)
            when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node)
                is TestDomain.TestSum.Three -> walkTestSumThree(node)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One) {
            visitTestSumOne(node)
            walkLongPrimitive(node.a)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two) {
            visitTestSumTwo(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three) {
            visitTestSumThree(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkLongPrimitive(node.c)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity) {
            visitEntity(node)
            when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node)
                is TestDomain.Entity.Android -> walkEntityAndroid(node)
                is TestDomain.Entity.Human -> walkEntityHuman(node)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug) {
            visitEntitySlug(node)
            walkMetas(node.metas)
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android) {
            visitEntityAndroid(node)
            walkLongPrimitive(node.id)
            walkMetas(node.metas)
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human) {
            visitEntityHuman(node)
            walkSymbolPrimitive(node.firstName)
            node.middleNames.map { walkSymbolPrimitive(it) }
            walkSymbolPrimitive(node.lastName)
            node.title?.let { walkSymbolPrimitive(it) }
            node.parent?.let { walkEntity(it) }
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitBoolPair(node: TestDomain.BoolPair, accumulator: T): T = accumulator
        open protected fun visitIntPair(node: TestDomain.IntPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T = accumulator
        open protected fun visitIonPair(node: TestDomain.IonPair, accumulator: T): T = accumulator
        open protected fun visitIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T = accumulator
        open protected fun visitSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T = accumulator
        open protected fun visitIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T = accumulator
        open protected fun visitIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T = accumulator
        open protected fun visitIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T = accumulator
        open protected fun visitIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T = accumulator
        open protected fun visitRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T = accumulator
        open protected fun visitAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T = accumulator
        open protected fun visitIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T = accumulator
        open protected fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T = accumulator
        open protected fun visitVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T = accumulator
        open protected fun visitVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T = accumulator
        open protected fun visitElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T = accumulator
        open protected fun visitOptional1(node: TestDomain.Optional1, accumulator: T): T = accumulator
        open protected fun visitOptional2(node: TestDomain.Optional2, accumulator: T): T = accumulator
        open protected fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T = accumulator
        open protected fun visitProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T = accumulator
        open protected fun visitTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T = accumulator
        open protected fun visitEntityPair(node: TestDomain.EntityPair, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open protected fun visitAnswer(node: TestDomain.Answer, accumulator: T): T = accumulator
        open protected fun visitAnswerNo(node: TestDomain.Answer.No, accumulator: T): T = accumulator
        open protected fun visitAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open protected fun visitSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T = accumulator
        open protected fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open protected fun visitTestSum(node: TestDomain.TestSum, accumulator: T): T = accumulator
        open protected fun visitTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T = accumulator
        open protected fun visitTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T = accumulator
        open protected fun visitTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open protected fun visitEntity(node: TestDomain.Entity, accumulator: T): T = accumulator
        open protected fun visitEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T = accumulator
        open protected fun visitEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T = accumulator
        open protected fun visitEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkBoolPair(node: TestDomain.BoolPair, accumulator: T): T {
            var current = accumulator
            current = visitBoolPair(node, current)
            current = walkBoolPrimitive(node.first, current)
            current = walkBoolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPair(node: TestDomain.IntPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPair(node: TestDomain.IonPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIntSymbolPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolIntPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T {
            var current = accumulator
            current = visitIonIntPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIonSymbolPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPairPair(node, current)
            current = walkIntPair(node.first, current)
            current = walkIntPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPairPair(node, current)
            current = walkSymbolPair(node.first, current)
            current = walkSymbolPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPairPair(node, current)
            current = walkIonPair(node.first, current)
            current = walkIonPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T {
            var current = accumulator
            current = visitRecursivePair(node, current)
            current = walkLongPrimitive(node.first, current)
            node.second?.let { current = walkRecursivePair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerIntPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitIntAnswerPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolAnswerPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerSymbolPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin0(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin1(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T {
            var current = accumulator
            current = visitElementVariadic(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional1(node: TestDomain.Optional1, accumulator: T): T {
            var current = accumulator
            current = visitOptional1(node, current)
            node.value?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional2(node: TestDomain.Optional2, accumulator: T): T {
            var current = accumulator
            current = visitOptional2(node, current)
            node.first?.let { current = walkLongPrimitive(it, current) }
            node.second?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T {
            var current = accumulator
            current = visitDomainLevelRecord(node, current)
            current = walkLongPrimitive(node.someField, current)
            current = walkSymbolPrimitive(node.anotherField, current)
            node.optionalField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitProductWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTriplet(node, current)
            current = walkTestSum(node.a, current)
            current = walkTestSum(node.b, current)
            current = walkTestSum(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair, accumulator: T): T {
            var current = accumulator
            current = visitEntityPair(node, current)
            current = walkEntity(node.first, current)
            current = walkEntity(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer, accumulator: T): T {
            val current = visitAnswer(node, accumulator)
            return when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node, current)
                is TestDomain.Answer.Yes -> walkAnswerYes(node, current)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No, accumulator: T): T {
            var current = accumulator
            current = visitAnswerNo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T {
            var current = accumulator
            current = visitAnswerYes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T {
            val current = visitSumWithRecord(node, accumulator)
            return when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node, current)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitSumWithRecordVariantWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum, accumulator: T): T {
            val current = visitTestSum(node, accumulator)
            return when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node, current)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node, current)
                is TestDomain.TestSum.Three -> walkTestSumThree(node, current)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T {
            var current = accumulator
            current = visitTestSumOne(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTwo(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T {
            var current = accumulator
            current = visitTestSumThree(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkLongPrimitive(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity, accumulator: T): T {
            val current = visitEntity(node, accumulator)
            return when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node, current)
                is TestDomain.Entity.Android -> walkEntityAndroid(node, current)
                is TestDomain.Entity.Human -> walkEntityHuman(node, current)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T {
            var current = accumulator
            current = visitEntitySlug(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T {
            var current = accumulator
            current = visitEntityAndroid(node, current)
            current = walkLongPrimitive(node.id, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T {
            var current = accumulator
            current = visitEntityHuman(node, current)
            current = walkSymbolPrimitive(node.firstName, current)
            node.middleNames.map { current = walkSymbolPrimitive(it, current) }
            current = walkSymbolPrimitive(node.lastName, current)
            node.title?.let { current = walkSymbolPrimitive(it, current) }
            node.parent?.let { current = walkEntity(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple BoolPair
        open fun transformBoolPair(node: TestDomain.BoolPair): TestDomain.BoolPair {
            val new_first = transformBoolPair_first(node)
            val new_second = transformBoolPair_second(node)
            val new_metas = transformBoolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.BoolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformBoolPair_first(node: TestDomain.BoolPair) =
            transformBoolPrimitive(node.first)
        open fun transformBoolPair_second(node: TestDomain.BoolPair) =
            transformBoolPrimitive(node.second)
        open fun transformBoolPair_metas(node: TestDomain.BoolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPair
        open fun transformIntPair(node: TestDomain.IntPair): TestDomain.IntPair {
            val new_first = transformIntPair_first(node)
            val new_second = transformIntPair_second(node)
            val new_metas = transformIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntPair_first(node: TestDomain.IntPair) =
            transformLongPrimitive(node.first)
        open fun transformIntPair_second(node: TestDomain.IntPair) =
            transformLongPrimitive(node.second)
        open fun transformIntPair_metas(node: TestDomain.IntPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPair
        open fun transformSymbolPair(node: TestDomain.SymbolPair): TestDomain.SymbolPair {
            val new_first = transformSymbolPair_first(node)
            val new_second = transformSymbolPair_second(node)
            val new_metas = transformSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolPair_first(node: TestDomain.SymbolPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolPair_second(node: TestDomain.SymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformSymbolPair_metas(node: TestDomain.SymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IonPair
        open fun transformIonPair(node: TestDomain.IonPair): TestDomain.IonPair {
            val new_first = transformIonPair_first(node)
            val new_second = transformIonPair_second(node)
            val new_metas = transformIonPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonPair_first(node: TestDomain.IonPair) =
            transformAnyElement(node.first)
        open fun transformIonPair_second(node: TestDomain.IonPair) =
            transformAnyElement(node.second)
        open fun transformIonPair_metas(node: TestDomain.IonPair) =
            transformMetas(node.metas)
    
        // Tuple IntSymbolPair
        open fun transformIntSymbolPair(node: TestDomain.IntSymbolPair): TestDomain.IntSymbolPair {
            val new_first = transformIntSymbolPair_first(node)
            val new_second = transformIntSymbolPair_second(node)
            val new_metas = transformIntSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntSymbolPair_first(node: TestDomain.IntSymbolPair) =
            transformLongPrimitive(node.first)
        open fun transformIntSymbolPair_second(node: TestDomain.IntSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformIntSymbolPair_metas(node: TestDomain.IntSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolIntPair
        open fun transformSymbolIntPair(node: TestDomain.SymbolIntPair): TestDomain.SymbolIntPair {
            val new_first = transformSymbolIntPair_first(node)
            val new_second = transformSymbolIntPair_second(node)
            val new_metas = transformSymbolIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolIntPair_first(node: TestDomain.SymbolIntPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolIntPair_second(node: TestDomain.SymbolIntPair) =
            transformLongPrimitive(node.second)
        open fun transformSymbolIntPair_metas(node: TestDomain.SymbolIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonIntPair
        open fun transformIonIntPair(node: TestDomain.IonIntPair): TestDomain.IonIntPair {
            val new_first = transformIonIntPair_first(node)
            val new_second = transformIonIntPair_second(node)
            val new_metas = transformIonIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonIntPair_first(node: TestDomain.IonIntPair) =
            transformAnyElement(node.first)
        open fun transformIonIntPair_second(node: TestDomain.IonIntPair) =
            transformLongPrimitive(node.second)
        open fun transformIonIntPair_metas(node: TestDomain.IonIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonSymbolPair
        open fun transformIonSymbolPair(node: TestDomain.IonSymbolPair): TestDomain.IonSymbolPair {
            val new_first = transformIonSymbolPair_first(node)
            val new_second = transformIonSymbolPair_second(node)
            val new_metas = transformIonSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonSymbolPair_first(node: TestDomain.IonSymbolPair) =
            transformAnyElement(node.first)
        open fun transformIonSymbolPair_second(node: TestDomain.IonSymbolPair) =
            transformAnyElement(node.second)
        open fun transformIonSymbolPair_metas(node: TestDomain.IonSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPairPair
        open fun transformIntPairPair(node: TestDomain.IntPairPair): TestDomain.IntPairPair {
            val new_first = transformIntPairPair_first(node)
            val new_second = transformIntPairPair_second(node)
            val new_metas = transformIntPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntPairPair_first(node: TestDomain.IntPairPair) =
            transformIntPair(node.first)
        open fun transformIntPairPair_second(node: TestDomain.IntPairPair) =
            transformIntPair(node.second)
        open fun transformIntPairPair_metas(node: TestDomain.IntPairPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPairPair
        open fun transformSymbolPairPair(node: TestDomain.SymbolPairPair): TestDomain.SymbolPairPair {
            val new_first = transformSymbolPairPair_first(node)
            val new_second = transformSymbolPairPair_second(node)
            val new_metas = transformSymbolPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolPairPair_first(node: TestDomain.SymbolPairPair) =
            transformSymbolPair(node.first)
        open fun transformSymbolPairPair_second(node: TestDomain.SymbolPairPair) =
            transformSymbolPair(node.second)
        open fun transformSymbolPairPair_metas(node: TestDomain.SymbolPairPair) =
            transformMetas(node.metas)
    
        // Tuple IonPairPair
        open fun transformIonPairPair(node: TestDomain.IonPairPair): TestDomain.IonPairPair {
            val new_first = transformIonPairPair_first(node)
            val new_second = transformIonPairPair_second(node)
            val new_metas = transformIonPairPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IonPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIonPairPair_first(node: TestDomain.IonPairPair) =
            transformIonPair(node.first)
        open fun transformIonPairPair_second(node: TestDomain.IonPairPair) =
            transformIonPair(node.second)
        open fun transformIonPairPair_metas(node: TestDomain.IonPairPair) =
            transformMetas(node.metas)
    
        // Tuple RecursivePair
        open fun transformRecursivePair(node: TestDomain.RecursivePair): TestDomain.RecursivePair {
            val new_first = transformRecursivePair_first(node)
            val new_second = transformRecursivePair_second(node)
            val new_metas = transformRecursivePair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.RecursivePair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecursivePair_first(node: TestDomain.RecursivePair) =
            transformLongPrimitive(node.first)
        open fun transformRecursivePair_second(node: TestDomain.RecursivePair) =
            node.second?.let { transformRecursivePair(it) }
        open fun transformRecursivePair_metas(node: TestDomain.RecursivePair) =
            transformMetas(node.metas)
    
        // Tuple AnswerPair
        open fun transformAnswerPair(node: TestDomain.AnswerPair): TestDomain.AnswerPair {
            val new_first = transformAnswerPair_first(node)
            val new_second = transformAnswerPair_second(node)
            val new_metas = transformAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerPair_first(node: TestDomain.AnswerPair) =
            transformAnswer(node.first)
        open fun transformAnswerPair_second(node: TestDomain.AnswerPair) =
            transformAnswer(node.second)
        open fun transformAnswerPair_metas(node: TestDomain.AnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerIntPair
        open fun transformAnswerIntPair(node: TestDomain.AnswerIntPair): TestDomain.AnswerIntPair {
            val new_first = transformAnswerIntPair_first(node)
            val new_second = transformAnswerIntPair_second(node)
            val new_metas = transformAnswerIntPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerIntPair_first(node: TestDomain.AnswerIntPair) =
            transformAnswer(node.first)
        open fun transformAnswerIntPair_second(node: TestDomain.AnswerIntPair) =
            transformLongPrimitive(node.second)
        open fun transformAnswerIntPair_metas(node: TestDomain.AnswerIntPair) =
            transformMetas(node.metas)
    
        // Tuple IntAnswerPair
        open fun transformIntAnswerPair(node: TestDomain.IntAnswerPair): TestDomain.IntAnswerPair {
            val new_first = transformIntAnswerPair_first(node)
            val new_second = transformIntAnswerPair_second(node)
            val new_metas = transformIntAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.IntAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIntAnswerPair_first(node: TestDomain.IntAnswerPair) =
            transformLongPrimitive(node.first)
        open fun transformIntAnswerPair_second(node: TestDomain.IntAnswerPair) =
            transformAnswer(node.second)
        open fun transformIntAnswerPair_metas(node: TestDomain.IntAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolAnswerPair
        open fun transformSymbolAnswerPair(node: TestDomain.SymbolAnswerPair): TestDomain.SymbolAnswerPair {
            val new_first = transformSymbolAnswerPair_first(node)
            val new_second = transformSymbolAnswerPair_second(node)
            val new_metas = transformSymbolAnswerPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.SymbolAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSymbolAnswerPair_first(node: TestDomain.SymbolAnswerPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolAnswerPair_second(node: TestDomain.SymbolAnswerPair) =
            transformAnswer(node.second)
        open fun transformSymbolAnswerPair_metas(node: TestDomain.SymbolAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerSymbolPair
        open fun transformAnswerSymbolPair(node: TestDomain.AnswerSymbolPair): TestDomain.AnswerSymbolPair {
            val new_first = transformAnswerSymbolPair_first(node)
            val new_second = transformAnswerSymbolPair_second(node)
            val new_metas = transformAnswerSymbolPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.AnswerSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerSymbolPair_first(node: TestDomain.AnswerSymbolPair) =
            transformAnswer(node.first)
        open fun transformAnswerSymbolPair_second(node: TestDomain.AnswerSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformAnswerSymbolPair_metas(node: TestDomain.AnswerSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin0
        open fun transformVariadicMin0(node: TestDomain.VariadicMin0): TestDomain.VariadicMin0 {
            val new_ints = transformVariadicMin0_ints(node)
            val new_metas = transformVariadicMin0_metas(node)
            return if (
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.VariadicMin0(
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformVariadicMin0_ints(node: TestDomain.VariadicMin0) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin0_metas(node: TestDomain.VariadicMin0) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin1
        open fun transformVariadicMin1(node: TestDomain.VariadicMin1): TestDomain.VariadicMin1 {
            val new_ints = transformVariadicMin1_ints(node)
            val new_metas = transformVariadicMin1_metas(node)
            return if (
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.VariadicMin1(
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformVariadicMin1_ints(node: TestDomain.VariadicMin1) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin1_metas(node: TestDomain.VariadicMin1) =
            transformMetas(node.metas)
    
        // Tuple ElementVariadic
        open fun transformElementVariadic(node: TestDomain.ElementVariadic): TestDomain.ElementVariadic {
            val new_name = transformElementVariadic_name(node)
            val new_ints = transformElementVariadic_ints(node)
            val new_metas = transformElementVariadic_metas(node)
            return if (
                node.name !== new_name ||
                node.ints !== new_ints ||
                node.metas !== new_metas
            ) {
                TestDomain.ElementVariadic(
                    name = new_name,
                    ints = new_ints,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformElementVariadic_name(node: TestDomain.ElementVariadic) =
            transformSymbolPrimitive(node.name)
        open fun transformElementVariadic_ints(node: TestDomain.ElementVariadic) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformElementVariadic_metas(node: TestDomain.ElementVariadic) =
            transformMetas(node.metas)
    
        // Tuple Optional1
        open fun transformOptional1(node: TestDomain.Optional1): TestDomain.Optional1 {
            val new_value = transformOptional1_value(node)
            val new_metas = transformOptional1_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                TestDomain.Optional1(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOptional1_value(node: TestDomain.Optional1) =
            node.value?.let { transformLongPrimitive(it) }
        open fun transformOptional1_metas(node: TestDomain.Optional1) =
            transformMetas(node.metas)
    
        // Tuple Optional2
        open fun transformOptional2(node: TestDomain.Optional2): TestDomain.Optional2 {
            val new_first = transformOptional2_first(node)
            val new_second = transformOptional2_second(node)
            val new_metas = transformOptional2_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.Optional2(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOptional2_first(node: TestDomain.Optional2) =
            node.first?.let { transformLongPrimitive(it) }
        open fun transformOptional2_second(node: TestDomain.Optional2) =
            node.second?.let { transformLongPrimitive(it) }
        open fun transformOptional2_metas(node: TestDomain.Optional2) =
            transformMetas(node.metas)
    
        // Tuple DomainLevelRecord
        open fun transformDomainLevelRecord(node: TestDomain.DomainLevelRecord): TestDomain.DomainLevelRecord {
            val new_someField = transformDomainLevelRecord_someField(node)
            val new_anotherField = transformDomainLevelRecord_anotherField(node)
            val new_optionalField = transformDomainLevelRecord_optionalField(node)
            val new_metas = transformDomainLevelRecord_metas(node)
            return if (
                node.someField !== new_someField ||
                node.anotherField !== new_anotherField ||
                node.optionalField !== new_optionalField ||
                node.metas !== new_metas
            ) {
                TestDomain.DomainLevelRecord(
                    someField = new_someField,
                    anotherField = new_anotherField,
                    optionalField = new_optionalField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDomainLevelRecord_someField(node: TestDomain.DomainLevelRecord) =
            transformLongPrimitive(node.someField)
        open fun transformDomainLevelRecord_anotherField(node: TestDomain.DomainLevelRecord) =
            transformSymbolPrimitive(node.anotherField)
        open fun transformDomainLevelRecord_optionalField(node: TestDomain.DomainLevelRecord) =
            node.optionalField?.let { transformLongPrimitive(it) }
        open fun transformDomainLevelRecord_metas(node: TestDomain.DomainLevelRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductWithRecord
        open fun transformProductWithRecord(node: TestDomain.ProductWithRecord): TestDomain.ProductWithRecord {
            val new_value = transformProductWithRecord_value(node)
            val new_dlr = transformProductWithRecord_dlr(node)
            val new_metas = transformProductWithRecord_metas(node)
            return if (
                node.value !== new_value ||
                node.dlr !== new_dlr ||
                node.metas !== new_metas
            ) {
                TestDomain.ProductWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductWithRecord_value(node: TestDomain.ProductWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformProductWithRecord_dlr(node: TestDomain.ProductWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformProductWithRecord_metas(node: TestDomain.ProductWithRecord) =
            transformMetas(node.metas)
    
        // Tuple TestSumTriplet
        open fun transformTestSumTriplet(node: TestDomain.TestSumTriplet): TestDomain.TestSumTriplet {
            val new_a = transformTestSumTriplet_a(node)
            val new_b = transformTestSumTriplet_b(node)
            val new_c = transformTestSumTriplet_c(node)
            val new_metas = transformTestSumTriplet_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.c !== new_c ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSumTriplet(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumTriplet_a(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.a)
        open fun transformTestSumTriplet_b(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.b)
        open fun transformTestSumTriplet_c(node: TestDomain.TestSumTriplet) =
            transformTestSum(node.c)
        open fun transformTestSumTriplet_metas(node: TestDomain.TestSumTriplet) =
            transformMetas(node.metas)
    
        // Tuple EntityPair
        open fun transformEntityPair(node: TestDomain.EntityPair): TestDomain.EntityPair {
            val new_first = transformEntityPair_first(node)
            val new_second = transformEntityPair_second(node)
            val new_metas = transformEntityPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                TestDomain.EntityPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityPair_first(node: TestDomain.EntityPair) =
            transformEntity(node.first)
        open fun transformEntityPair_second(node: TestDomain.EntityPair) =
            transformEntity(node.second)
        open fun transformEntityPair_metas(node: TestDomain.EntityPair) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun transformAnswer(node: TestDomain.Answer): TestDomain.Answer =
            when(node) {
                is TestDomain.Answer.No -> transformAnswerNo(node)
                is TestDomain.Answer.Yes -> transformAnswerYes(node)
            }
        // Variant AnswerNo
        open fun transformAnswerNo(node: TestDomain.Answer.No): TestDomain.Answer  {
            val new_metas = transformAnswerNo_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Answer.No(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerNo_metas(node: TestDomain.Answer.No) =
            transformMetas(node.metas)
    
        // Variant AnswerYes
        open fun transformAnswerYes(node: TestDomain.Answer.Yes): TestDomain.Answer  {
            val new_metas = transformAnswerYes_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Answer.Yes(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAnswerYes_metas(node: TestDomain.Answer.Yes) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun transformSumWithRecord(node: TestDomain.SumWithRecord): TestDomain.SumWithRecord =
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> transformSumWithRecordVariantWithRecord(node)
            }
        // Variant SumWithRecordVariantWithRecord
        open fun transformSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): TestDomain.SumWithRecord  {
            val new_value = transformSumWithRecordVariantWithRecord_value(node)
            val new_dlr = transformSumWithRecordVariantWithRecord_dlr(node)
            val new_metas = transformSumWithRecordVariantWithRecord_metas(node)
            return if (
                node.value !== new_value ||
                node.dlr !== new_dlr ||
                node.metas !== new_metas
            ) {
                TestDomain.SumWithRecord.VariantWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumWithRecordVariantWithRecord_value(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformSumWithRecordVariantWithRecord_dlr(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformSumWithRecordVariantWithRecord_metas(node: TestDomain.SumWithRecord.VariantWithRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun transformTestSum(node: TestDomain.TestSum): TestDomain.TestSum =
            when(node) {
                is TestDomain.TestSum.One -> transformTestSumOne(node)
                is TestDomain.TestSum.Two -> transformTestSumTwo(node)
                is TestDomain.TestSum.Three -> transformTestSumThree(node)
            }
        // Variant TestSumOne
        open fun transformTestSumOne(node: TestDomain.TestSum.One): TestDomain.TestSum  {
            val new_a = transformTestSumOne_a(node)
            val new_metas = transformTestSumOne_metas(node)
            return if (
                node.a !== new_a ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.One(
                    a = new_a,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumOne_a(node: TestDomain.TestSum.One) =
            transformLongPrimitive(node.a)
        open fun transformTestSumOne_metas(node: TestDomain.TestSum.One) =
            transformMetas(node.metas)
    
        // Variant TestSumTwo
        open fun transformTestSumTwo(node: TestDomain.TestSum.Two): TestDomain.TestSum  {
            val new_a = transformTestSumTwo_a(node)
            val new_b = transformTestSumTwo_b(node)
            val new_metas = transformTestSumTwo_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.Two(
                    a = new_a,
                    b = new_b,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumTwo_a(node: TestDomain.TestSum.Two) =
            transformLongPrimitive(node.a)
        open fun transformTestSumTwo_b(node: TestDomain.TestSum.Two) =
            transformLongPrimitive(node.b)
        open fun transformTestSumTwo_metas(node: TestDomain.TestSum.Two) =
            transformMetas(node.metas)
    
        // Variant TestSumThree
        open fun transformTestSumThree(node: TestDomain.TestSum.Three): TestDomain.TestSum  {
            val new_a = transformTestSumThree_a(node)
            val new_b = transformTestSumThree_b(node)
            val new_c = transformTestSumThree_c(node)
            val new_metas = transformTestSumThree_metas(node)
            return if (
                node.a !== new_a ||
                node.b !== new_b ||
                node.c !== new_c ||
                node.metas !== new_metas
            ) {
                TestDomain.TestSum.Three(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTestSumThree_a(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.a)
        open fun transformTestSumThree_b(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.b)
        open fun transformTestSumThree_c(node: TestDomain.TestSum.Three) =
            transformLongPrimitive(node.c)
        open fun transformTestSumThree_metas(node: TestDomain.TestSum.Three) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun transformEntity(node: TestDomain.Entity): TestDomain.Entity =
            when(node) {
                is TestDomain.Entity.Slug -> transformEntitySlug(node)
                is TestDomain.Entity.Android -> transformEntityAndroid(node)
                is TestDomain.Entity.Human -> transformEntityHuman(node)
            }
        // Variant EntitySlug
        open fun transformEntitySlug(node: TestDomain.Entity.Slug): TestDomain.Entity  {
            val new_metas = transformEntitySlug_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Slug(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntitySlug_metas(node: TestDomain.Entity.Slug) =
            transformMetas(node.metas)
    
        // Variant EntityAndroid
        open fun transformEntityAndroid(node: TestDomain.Entity.Android): TestDomain.Entity  {
            val new_id = transformEntityAndroid_id(node)
            val new_metas = transformEntityAndroid_metas(node)
            return if (
                node.id !== new_id ||
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Android(
                    id = new_id,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityAndroid_id(node: TestDomain.Entity.Android) =
            transformLongPrimitive(node.id)
        open fun transformEntityAndroid_metas(node: TestDomain.Entity.Android) =
            transformMetas(node.metas)
    
        // Variant EntityHuman
        open fun transformEntityHuman(node: TestDomain.Entity.Human): TestDomain.Entity  {
            val new_firstName = transformEntityHuman_firstName(node)
            val new_middleNames = transformEntityHuman_middleNames(node)
            val new_lastName = transformEntityHuman_lastName(node)
            val new_title = transformEntityHuman_title(node)
            val new_parent = transformEntityHuman_parent(node)
            val new_metas = transformEntityHuman_metas(node)
            return if (
                node.firstName !== new_firstName ||
                node.middleNames !== new_middleNames ||
                node.lastName !== new_lastName ||
                node.title !== new_title ||
                node.parent !== new_parent ||
                node.metas !== new_metas
            ) {
                TestDomain.Entity.Human(
                    firstName = new_firstName,
                    middleNames = new_middleNames,
                    lastName = new_lastName,
                    title = new_title,
                    parent = new_parent,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformEntityHuman_firstName(node: TestDomain.Entity.Human) =
            transformSymbolPrimitive(node.firstName)
        open fun transformEntityHuman_middleNames(node: TestDomain.Entity.Human) =
            node.middleNames.map { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_lastName(node: TestDomain.Entity.Human) =
            transformSymbolPrimitive(node.lastName)
        open fun transformEntityHuman_title(node: TestDomain.Entity.Human) =
            node.title?.let { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_parent(node: TestDomain.Entity.Human) =
            node.parent?.let { transformEntity(it) }
        open fun transformEntityHuman_metas(node: TestDomain.Entity.Human) =
            transformMetas(node.metas)
    
    }
}


class MultiWordDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = MultiWordDomainBuilder
    
        fun <T: MultiWordDomainNode> build(block: Builder.() -> T) =
            MultiWordDomainBuilder.block()
    
        fun transform(element: AnyElement): MultiWordDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): MultiWordDomainNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [MultiWordDomain.AaaAaa].
         */
        fun aaaAaa(
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAaa =
            MultiWordDomain.AaaAaa(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         */
        fun aaaAab(
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAab_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         */
        fun aaaAac(
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAac_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField,
                eField = eField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            dField: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         */
        fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAaa_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField,
                cField = cField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         */
        fun aabAab(
            bField: Long,
            cField: String,
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAab_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         */
        fun aabAac(
            bField: Long,
            cField: String,
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAac_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField?.asPrimitive(),
                cField = cField?.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField?.asPrimitive(),
                cField = cField?.asPrimitive(),
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         */
        fun rrr(
            aField: Long,
            bbbField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField.asPrimitive(),
                bbbField = bbbField.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun rrr_(
            aField: org.partiql.pig.runtime.LongPrimitive,
            bbbField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SssTtt 
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         */
        fun lll(
            uField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun lll_(
            uField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         */
        fun mmm(
            vField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun mmm_(
            vField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object MultiWordDomainBuilder : Builder
    
    /** Base class for all MultiWordDomain types. */
    abstract class MultiWordDomainNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): MultiWordDomainNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): MultiWordDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class AaaAaa(
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AaaAaa =
            AaaAaa(
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAaa =
            AaaAaa(
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aaa"),
                metas = metas)
            return elements
        }
    
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAaa::class.java) return false
    
            return true
        }
    
        override fun hashCode(): Int = 0
    }
    
    class AaaAab(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aab"),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAab(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAab::class.java) return false
    
            other as AaaAab
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAac(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aac"),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas
        ) =
            AaaAac(
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAac::class.java) return false
    
            other as AaaAac
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAad(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aad"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAad(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAad::class.java) return false
    
            other as AaaAad
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAae(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aae"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAae(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAae::class.java) return false
    
            other as AaaAae
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAaa(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aaa"),
                bField.toIonElement(),
                cField.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            metas: MetaContainer = this.metas
        ) =
            AabAaa(
                bField,
                cField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAaa::class.java) return false
    
            other as AabAaa
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAab(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aab"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAab(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAab::class.java) return false
    
            other as AabAab
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAac(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aac"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas
        ) =
            AabAac(
                bField,
                cField,
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAac::class.java) return false
    
            other as AabAac
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAad(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aad"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAad(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAad::class.java) return false
    
            other as AabAad
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAae(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aae"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAae(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAae::class.java) return false
    
            other as AabAae
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Rrr(
        val aField: org.partiql.pig.runtime.LongPrimitive,
        val bbbField: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copy(metas: MetaContainer): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("rrr"),
                aField?.let { ionSexpOf(ionSymbol("a_field"), it.toIonElement()) },
                bbbField?.let { ionSexpOf(ionSymbol("b_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            aField: org.partiql.pig.runtime.LongPrimitive = this.aField,
            bbbField: org.partiql.pig.runtime.LongPrimitive = this.bbbField,
            metas: MetaContainer = this.metas
        ) =
            Rrr(
                aField,
                bbbField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Rrr::class.java) return false
    
            other as Rrr
            if (aField != other.aField) return false
            if (bbbField != other.bbbField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = aField.hashCode()
            hc = 31 * hc + bbbField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SssTtt(override val metas: MetaContainer = emptyMetaContainer()) : MultiWordDomainNode() {
        override fun copy(metas: MetaContainer): SssTtt =
            when (this) {
                is Lll -> copy(metas = metas)
                is Mmm -> copy(metas = metas)
            }
    
        class Lll(
            val uField: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun copy(metas: MetaContainer): Lll =
                Lll(
                    uField = uField,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lll =
                Lll(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lll"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                uField: org.partiql.pig.runtime.LongPrimitive = this.uField,
                metas: MetaContainer = this.metas
            ) =
                Lll(
                    uField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lll::class.java) return false
        
                other as Lll
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Mmm(
            val vField: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun copy(metas: MetaContainer): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("mmm"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                vField: org.partiql.pig.runtime.SymbolPrimitive = this.vField,
                metas: MetaContainer = this.metas
            ) =
                Mmm(
                    vField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Mmm::class.java) return false
        
                other as Mmm
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [MultiWordDomain.SssTtt] to any [T]. */
        interface Converter<T> {
            fun convert(node: MultiWordDomain.SssTtt): T = when(node) {
                is MultiWordDomain.SssTtt.Lll -> convertLll(node)
                is MultiWordDomain.SssTtt.Mmm -> convertMmm(node)
            }
    
            fun convertLll(node: MultiWordDomain.SssTtt.Lll): T
            fun convertMmm(node: MultiWordDomain.SssTtt.Mmm): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<MultiWordDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): MultiWordDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "aaa_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    MultiWordDomain.AaaAaa(
                        metas = sexp.metas)
                }
                "aaa_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    MultiWordDomain.AaaAab(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    val eField = sexp.getOptional(1)?.toSymbolPrimitive()
                    MultiWordDomain.AaaAac(
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aaa_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAad(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAae(
                        dField,
                        metas = sexp.metas)
                }
                "aab_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    MultiWordDomain.AabAaa(
                        bField,
                        cField,
                        metas = sexp.metas)
                }
                "aab_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    MultiWordDomain.AabAab(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    val eField = sexp.getOptional(3)?.toSymbolPrimitive()
                    MultiWordDomain.AabAac(
                        bField,
                        cField,
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aab_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAad(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAae(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "rrr" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val aField = ir.processRequiredField("a_field") { it.toLongPrimitive() }
                    val bbbField = ir.processRequiredField("bbb_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Rrr(aField, bbbField, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtt'
                //////////////////////////////////////
                "lll" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).toLongPrimitive()
                    MultiWordDomain.SssTtt.Lll(
                        uField,
                        metas = sexp.metas)
                }
                "mmm" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).toSymbolPrimitive()
                    MultiWordDomain.SssTtt.Mmm(
                        vField,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'multi_word_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitAaaAaa(node: MultiWordDomain.AaaAaa) { }
        open fun visitAaaAab(node: MultiWordDomain.AaaAab) { }
        open fun visitAaaAac(node: MultiWordDomain.AaaAac) { }
        open fun visitAaaAad(node: MultiWordDomain.AaaAad) { }
        open fun visitAaaAae(node: MultiWordDomain.AaaAae) { }
        open fun visitAabAaa(node: MultiWordDomain.AabAaa) { }
        open fun visitAabAab(node: MultiWordDomain.AabAab) { }
        open fun visitAabAac(node: MultiWordDomain.AabAac) { }
        open fun visitAabAad(node: MultiWordDomain.AabAad) { }
        open fun visitAabAae(node: MultiWordDomain.AabAae) { }
        open fun visitRrr(node: MultiWordDomain.Rrr) { }
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        protected open fun visitSssTtt(node: MultiWordDomain.SssTtt) { }
        protected open fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll) { }
        protected open fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa) {
            visitAaaAaa(node)
            walkMetas(node.metas)
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab) {
            visitAaaAab(node)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac) {
            visitAaaAac(node)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad) {
            visitAaaAad(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae) {
            visitAaaAae(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa) {
            visitAabAaa(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            walkMetas(node.metas)
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab) {
            visitAabAab(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac) {
            visitAabAac(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad) {
            visitAabAad(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae) {
            visitAabAae(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr) {
            visitRrr(node)
            walkLongPrimitive(node.aField)
            walkLongPrimitive(node.bbbField)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt) {
            visitSssTtt(node)
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll) {
            visitSssTttLll(node)
            walkLongPrimitive(node.uField)
            walkMetas(node.metas)
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) {
            visitSssTttMmm(node)
            walkSymbolPrimitive(node.vField)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T = accumulator
        open protected fun visitAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T = accumulator
        open protected fun visitAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T = accumulator
        open protected fun visitAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T = accumulator
        open protected fun visitAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T = accumulator
        open protected fun visitAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T = accumulator
        open protected fun visitAabAab(node: MultiWordDomain.AabAab, accumulator: T): T = accumulator
        open protected fun visitAabAac(node: MultiWordDomain.AabAac, accumulator: T): T = accumulator
        open protected fun visitAabAad(node: MultiWordDomain.AabAad, accumulator: T): T = accumulator
        open protected fun visitAabAae(node: MultiWordDomain.AabAae, accumulator: T): T = accumulator
        open protected fun visitRrr(node: MultiWordDomain.Rrr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open protected fun visitSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T = accumulator
        open protected fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T = accumulator
        open protected fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T {
            var current = accumulator
            current = visitAaaAaa(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T {
            var current = accumulator
            current = visitAaaAab(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T {
            var current = accumulator
            current = visitAaaAac(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T {
            var current = accumulator
            current = visitAaaAad(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T {
            var current = accumulator
            current = visitAaaAae(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T {
            var current = accumulator
            current = visitAabAaa(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab, accumulator: T): T {
            var current = accumulator
            current = visitAabAab(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac, accumulator: T): T {
            var current = accumulator
            current = visitAabAac(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad, accumulator: T): T {
            var current = accumulator
            current = visitAabAad(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae, accumulator: T): T {
            var current = accumulator
            current = visitAabAae(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr, accumulator: T): T {
            var current = accumulator
            current = visitRrr(node, current)
            current = walkLongPrimitive(node.aField, current)
            current = walkLongPrimitive(node.bbbField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T {
            val current = visitSssTtt(node, accumulator)
            return when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node, current)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node, current)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T {
            var current = accumulator
            current = visitSssTttLll(node, current)
            current = walkLongPrimitive(node.uField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T {
            var current = accumulator
            current = visitSssTttMmm(node, current)
            current = walkSymbolPrimitive(node.vField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple AaaAaa
        open fun transformAaaAaa(node: MultiWordDomain.AaaAaa): MultiWordDomain.AaaAaa {
            val new_metas = transformAaaAaa_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                MultiWordDomain.AaaAaa(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAaaAaa_metas(node: MultiWordDomain.AaaAaa) =
            transformMetas(node.metas)
    
        // Tuple AaaAab
        open fun transformAaaAab(node: MultiWordDomain.AaaAab): MultiWordDomain.AaaAab {
            val new_dField = transformAaaAab_dField(node)
            val new_metas = transformAaaAab_metas(node)
            return if (
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AaaAab(
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAaaAab_dField(node: MultiWordDomain.AaaAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAab_metas(node: MultiWordDomain.AaaAab) =
            transformMetas(node.metas)
    
        // Tuple AaaAac
        open fun transformAaaAac(node: MultiWordDomain.AaaAac): MultiWordDomain.AaaAac {
            val new_dField = transformAaaAac_dField(node)
            val new_eField = transformAaaAac_eField(node)
            val new_metas = transformAaaAac_metas(node)
            return if (
                node.dField !== new_dField ||
                node.eField !== new_eField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AaaAac(
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAaaAac_dField(node: MultiWordDomain.AaaAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAac_eField(node: MultiWordDomain.AaaAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAaaAac_metas(node: MultiWordDomain.AaaAac) =
            transformMetas(node.metas)
    
        // Tuple AaaAad
        open fun transformAaaAad(node: MultiWordDomain.AaaAad): MultiWordDomain.AaaAad {
            val new_dField = transformAaaAad_dField(node)
            val new_metas = transformAaaAad_metas(node)
            return if (
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AaaAad(
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAaaAad_dField(node: MultiWordDomain.AaaAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAad_metas(node: MultiWordDomain.AaaAad) =
            transformMetas(node.metas)
    
        // Tuple AaaAae
        open fun transformAaaAae(node: MultiWordDomain.AaaAae): MultiWordDomain.AaaAae {
            val new_dField = transformAaaAae_dField(node)
            val new_metas = transformAaaAae_metas(node)
            return if (
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AaaAae(
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAaaAae_dField(node: MultiWordDomain.AaaAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAae_metas(node: MultiWordDomain.AaaAae) =
            transformMetas(node.metas)
    
        // Tuple AabAaa
        open fun transformAabAaa(node: MultiWordDomain.AabAaa): MultiWordDomain.AabAaa {
            val new_bField = transformAabAaa_bField(node)
            val new_cField = transformAabAaa_cField(node)
            val new_metas = transformAabAaa_metas(node)
            return if (
                node.bField !== new_bField ||
                node.cField !== new_cField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AabAaa(
                    bField = new_bField,
                    cField = new_cField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAabAaa_bField(node: MultiWordDomain.AabAaa) =
            transformLongPrimitive(node.bField)
        open fun transformAabAaa_cField(node: MultiWordDomain.AabAaa) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAaa_metas(node: MultiWordDomain.AabAaa) =
            transformMetas(node.metas)
    
        // Tuple AabAab
        open fun transformAabAab(node: MultiWordDomain.AabAab): MultiWordDomain.AabAab {
            val new_bField = transformAabAab_bField(node)
            val new_cField = transformAabAab_cField(node)
            val new_dField = transformAabAab_dField(node)
            val new_metas = transformAabAab_metas(node)
            return if (
                node.bField !== new_bField ||
                node.cField !== new_cField ||
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AabAab(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAabAab_bField(node: MultiWordDomain.AabAab) =
            transformLongPrimitive(node.bField)
        open fun transformAabAab_cField(node: MultiWordDomain.AabAab) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAab_dField(node: MultiWordDomain.AabAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAab_metas(node: MultiWordDomain.AabAab) =
            transformMetas(node.metas)
    
        // Tuple AabAac
        open fun transformAabAac(node: MultiWordDomain.AabAac): MultiWordDomain.AabAac {
            val new_bField = transformAabAac_bField(node)
            val new_cField = transformAabAac_cField(node)
            val new_dField = transformAabAac_dField(node)
            val new_eField = transformAabAac_eField(node)
            val new_metas = transformAabAac_metas(node)
            return if (
                node.bField !== new_bField ||
                node.cField !== new_cField ||
                node.dField !== new_dField ||
                node.eField !== new_eField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AabAac(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAabAac_bField(node: MultiWordDomain.AabAac) =
            transformLongPrimitive(node.bField)
        open fun transformAabAac_cField(node: MultiWordDomain.AabAac) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAac_dField(node: MultiWordDomain.AabAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAac_eField(node: MultiWordDomain.AabAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAabAac_metas(node: MultiWordDomain.AabAac) =
            transformMetas(node.metas)
    
        // Tuple AabAad
        open fun transformAabAad(node: MultiWordDomain.AabAad): MultiWordDomain.AabAad {
            val new_bField = transformAabAad_bField(node)
            val new_cField = transformAabAad_cField(node)
            val new_dField = transformAabAad_dField(node)
            val new_metas = transformAabAad_metas(node)
            return if (
                node.bField !== new_bField ||
                node.cField !== new_cField ||
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AabAad(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAabAad_bField(node: MultiWordDomain.AabAad) =
            transformLongPrimitive(node.bField)
        open fun transformAabAad_cField(node: MultiWordDomain.AabAad) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAad_dField(node: MultiWordDomain.AabAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAad_metas(node: MultiWordDomain.AabAad) =
            transformMetas(node.metas)
    
        // Tuple AabAae
        open fun transformAabAae(node: MultiWordDomain.AabAae): MultiWordDomain.AabAae {
            val new_bField = transformAabAae_bField(node)
            val new_cField = transformAabAae_cField(node)
            val new_dField = transformAabAae_dField(node)
            val new_metas = transformAabAae_metas(node)
            return if (
                node.bField !== new_bField ||
                node.cField !== new_cField ||
                node.dField !== new_dField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.AabAae(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAabAae_bField(node: MultiWordDomain.AabAae) =
            transformLongPrimitive(node.bField)
        open fun transformAabAae_cField(node: MultiWordDomain.AabAae) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAae_dField(node: MultiWordDomain.AabAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAae_metas(node: MultiWordDomain.AabAae) =
            transformMetas(node.metas)
    
        // Tuple Rrr
        open fun transformRrr(node: MultiWordDomain.Rrr): MultiWordDomain.Rrr {
            val new_aField = transformRrr_aField(node)
            val new_bbbField = transformRrr_bbbField(node)
            val new_metas = transformRrr_metas(node)
            return if (
                node.aField !== new_aField ||
                node.bbbField !== new_bbbField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.Rrr(
                    aField = new_aField,
                    bbbField = new_bbbField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRrr_aField(node: MultiWordDomain.Rrr) =
            transformLongPrimitive(node.aField)
        open fun transformRrr_bbbField(node: MultiWordDomain.Rrr) =
            transformLongPrimitive(node.bbbField)
        open fun transformRrr_metas(node: MultiWordDomain.Rrr) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun transformSssTtt(node: MultiWordDomain.SssTtt): MultiWordDomain.SssTtt =
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> transformSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> transformSssTttMmm(node)
            }
        // Variant SssTttLll
        open fun transformSssTttLll(node: MultiWordDomain.SssTtt.Lll): MultiWordDomain.SssTtt  {
            val new_uField = transformSssTttLll_uField(node)
            val new_metas = transformSssTttLll_metas(node)
            return if (
                node.uField !== new_uField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.SssTtt.Lll(
                    uField = new_uField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSssTttLll_uField(node: MultiWordDomain.SssTtt.Lll) =
            transformLongPrimitive(node.uField)
        open fun transformSssTttLll_metas(node: MultiWordDomain.SssTtt.Lll) =
            transformMetas(node.metas)
    
        // Variant SssTttMmm
        open fun transformSssTttMmm(node: MultiWordDomain.SssTtt.Mmm): MultiWordDomain.SssTtt  {
            val new_vField = transformSssTttMmm_vField(node)
            val new_metas = transformSssTttMmm_metas(node)
            return if (
                node.vField !== new_vField ||
                node.metas !== new_metas
            ) {
                MultiWordDomain.SssTtt.Mmm(
                    vField = new_vField,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSssTttMmm_vField(node: MultiWordDomain.SssTtt.Mmm) =
            transformSymbolPrimitive(node.vField)
        open fun transformSssTttMmm_metas(node: MultiWordDomain.SssTtt.Mmm) =
            transformMetas(node.metas)
    
    }
}


class DomainA private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = DomainABuilder
    
        fun <T: DomainANode> build(block: Builder.() -> T) =
            DomainABuilder.block()
    
        fun transform(element: AnyElement): DomainANode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): DomainANode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [DomainA.ProductToRemove].
         */
        fun productToRemove(
            whatever: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductToRemove =
            DomainA.ProductToRemove(
                whatever = whatever.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.ProductToRemove].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productToRemove_(
            whatever: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductToRemove =
            DomainA.ProductToRemove(
                whatever = whatever,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.RecordToRemove].
         */
        fun recordToRemove(
            irrelevant: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordToRemove =
            DomainA.RecordToRemove(
                irrelevant = irrelevant.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.RecordToRemove].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordToRemove_(
            irrelevant: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordToRemove =
            DomainA.RecordToRemove(
                irrelevant = irrelevant,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.ProductA].
         */
        fun productA(
            one: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductA =
            DomainA.ProductA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.ProductA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productA_(
            one: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductA =
            DomainA.ProductA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.RecordA].
         */
        fun recordA(
            one: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordA =
            DomainA.RecordA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.RecordA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordA_(
            one: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordA =
            DomainA.RecordA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedProduct].
         */
        fun unpermutedProduct(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedProduct =
            DomainA.UnpermutedProduct(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProduct_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedProduct =
            DomainA.UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedRecord].
         */
        fun unpermutedRecord(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedRecord =
            DomainA.UnpermutedRecord(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecord_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedRecord =
            DomainA.UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumToRemove 
        /**
         * Creates an instance of [DomainA.SumToRemove.Doesnt].
         */
        fun doesnt(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumToRemove.Doesnt =
            DomainA.SumToRemove.Doesnt(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumToRemove.Matter].
         */
        fun matter(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumToRemove.Matter =
            DomainA.SumToRemove.Matter(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumA 
        /**
         * Creates an instance of [DomainA.SumA.Who].
         */
        fun who(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumA.Who =
            DomainA.SumA.Who(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumA.Cares].
         */
        fun cares(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumA.Cares =
            DomainA.SumA.Cares(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumB 
        /**
         * Creates an instance of [DomainA.SumB.WillBeUnchanged].
         */
        fun willBeUnchanged(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeUnchanged =
            DomainA.SumB.WillBeUnchanged(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeRemoved].
         */
        fun willBeRemoved(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeRemoved =
            DomainA.SumB.WillBeRemoved(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeReplaced].
         */
        fun willBeReplaced(
            something: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeReplaced =
            DomainA.SumB.WillBeReplaced(
                something = something.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeReplaced].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun willBeReplaced_(
            something: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeReplaced =
            DomainA.SumB.WillBeReplaced(
                something = something,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: UnpermutedSum 
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedProductVariant].
         */
        fun unpermutedProductVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedProductVariant =
            DomainA.UnpermutedSum.UnpermutedProductVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedProductVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProductVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedProductVariant =
            DomainA.UnpermutedSum.UnpermutedProductVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedRecordVariant].
         */
        fun unpermutedRecordVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedRecordVariant =
            DomainA.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedRecordVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecordVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedRecordVariant =
            DomainA.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object DomainABuilder : Builder
    
    /** Base class for all DomainA types. */
    abstract class DomainANode : DomainNode {
        abstract override fun copy(metas: MetaContainer): DomainANode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): DomainANode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ProductToRemove(
        val whatever: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): ProductToRemove =
            ProductToRemove(
                whatever = whatever,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductToRemove =
            ProductToRemove(
                whatever = whatever,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_to_remove"),
                whatever.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            whatever: org.partiql.pig.runtime.SymbolPrimitive = this.whatever,
            metas: MetaContainer = this.metas
        ) =
            ProductToRemove(
                whatever,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductToRemove::class.java) return false
    
            other as ProductToRemove
            if (whatever != other.whatever) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = whatever.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordToRemove(
        val irrelevant: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): RecordToRemove =
            RecordToRemove(
                irrelevant = irrelevant,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordToRemove =
            RecordToRemove(
                irrelevant = irrelevant,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_to_remove"),
                irrelevant?.let { ionSexpOf(ionSymbol("irrelevant"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            irrelevant: org.partiql.pig.runtime.LongPrimitive = this.irrelevant,
            metas: MetaContainer = this.metas
        ) =
            RecordToRemove(
                irrelevant,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordToRemove::class.java) return false
    
            other as RecordToRemove
            if (irrelevant != other.irrelevant) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = irrelevant.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductA(
        val one: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): ProductA =
            ProductA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductA =
            ProductA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_a"),
                one.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            one: org.partiql.pig.runtime.LongPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            ProductA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductA::class.java) return false
    
            other as ProductA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordA(
        val one: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): RecordA =
            RecordA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordA =
            RecordA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_a"),
                one?.let { ionSexpOf(ionSymbol("one"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            one: org.partiql.pig.runtime.LongPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            RecordA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordA::class.java) return false
    
            other as RecordA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedProduct(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("unpermuted_product"),
                foo.toIonElement(),
                bar.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedProduct(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedProduct::class.java) return false
    
            other as UnpermutedProduct
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedRecord(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("unpermuted_record"),
                foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedRecord(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedRecord::class.java) return false
    
            other as UnpermutedRecord
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SumToRemove(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumToRemove =
            when (this) {
                is Doesnt -> copy(metas = metas)
                is Matter -> copy(metas = metas)
            }
    
        class Doesnt(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumToRemove() {
        
            override fun copy(metas: MetaContainer): Doesnt =
                Doesnt(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Doesnt =
                Doesnt(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("doesnt"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Doesnt::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Matter(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumToRemove() {
        
            override fun copy(metas: MetaContainer): Matter =
                Matter(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Matter =
                Matter(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("matter"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Matter::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        /** Converts instances of [DomainA.SumToRemove] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumToRemove): T = when(node) {
                is DomainA.SumToRemove.Doesnt -> convertDoesnt(node)
                is DomainA.SumToRemove.Matter -> convertMatter(node)
            }
    
            fun convertDoesnt(node: DomainA.SumToRemove.Doesnt): T
            fun convertMatter(node: DomainA.SumToRemove.Matter): T
        }
    }
    
    sealed class SumA(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumA =
            when (this) {
                is Who -> copy(metas = metas)
                is Cares -> copy(metas = metas)
            }
    
        class Who(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumA() {
        
            override fun copy(metas: MetaContainer): Who =
                Who(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Who =
                Who(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("who"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Who::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class Cares(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumA() {
        
            override fun copy(metas: MetaContainer): Cares =
                Cares(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Cares =
                Cares(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("cares"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Cares::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2001
        }
    
        /** Converts instances of [DomainA.SumA] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumA): T = when(node) {
                is DomainA.SumA.Who -> convertWho(node)
                is DomainA.SumA.Cares -> convertCares(node)
            }
    
            fun convertWho(node: DomainA.SumA.Who): T
            fun convertCares(node: DomainA.SumA.Cares): T
        }
    }
    
    sealed class SumB(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumB =
            when (this) {
                is WillBeUnchanged -> copy(metas = metas)
                is WillBeRemoved -> copy(metas = metas)
                is WillBeReplaced -> copy(metas = metas)
            }
    
        class WillBeUnchanged(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_unchanged"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeUnchanged::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class WillBeRemoved(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeRemoved =
                WillBeRemoved(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeRemoved =
                WillBeRemoved(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_removed"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeRemoved::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class WillBeReplaced(
            val something: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_replaced"),
                    something.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                something: org.partiql.pig.runtime.LongPrimitive = this.something,
                metas: MetaContainer = this.metas
            ) =
                WillBeReplaced(
                    something,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeReplaced::class.java) return false
        
                other as WillBeReplaced
                if (something != other.something) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = something.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.SumB] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumB): T = when(node) {
                is DomainA.SumB.WillBeUnchanged -> convertWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> convertWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> convertWillBeReplaced(node)
            }
    
            fun convertWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged): T
            fun convertWillBeRemoved(node: DomainA.SumB.WillBeRemoved): T
            fun convertWillBeReplaced(node: DomainA.SumB.WillBeReplaced): T
        }
    }
    
    sealed class UnpermutedSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): UnpermutedSum =
            when (this) {
                is UnpermutedProductVariant -> copy(metas = metas)
                is UnpermutedRecordVariant -> copy(metas = metas)
            }
    
        class UnpermutedProductVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unpermuted_product_variant"),
                    foo.toIonElement(),
                    bar.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedProductVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedProductVariant::class.java) return false
        
                other as UnpermutedProductVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class UnpermutedRecordVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("unpermuted_record_variant"),
                    foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                    bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedRecordVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedRecordVariant::class.java) return false
        
                other as UnpermutedRecordVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.UnpermutedSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.UnpermutedSum): T = when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> convertUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> convertUnpermutedRecordVariant(node)
            }
    
            fun convertUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant): T
            fun convertUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<DomainANode>() {
    
        override fun innerTransform(sexp: SexpElement): DomainANode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "product_to_remove" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val whatever = sexp.getRequired(0).toSymbolPrimitive()
                    DomainA.ProductToRemove(
                        whatever,
                        metas = sexp.metas)
                }
                "record_to_remove" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val irrelevant = ir.processRequiredField("irrelevant") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordToRemove(irrelevant, metas = sexp.metas)
                }
                "product_a" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val one = sexp.getRequired(0).toLongPrimitive()
                    DomainA.ProductA(
                        one,
                        metas = sexp.metas)
                }
                "record_a" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val one = ir.processRequiredField("one") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordA(one, metas = sexp.metas)
                }
                "unpermuted_product" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainA.UnpermutedProduct(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedRecord(foo, bar, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumToRemove'
                //////////////////////////////////////
                "doesnt" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumToRemove.Doesnt(
                        metas = sexp.metas)
                }
                "matter" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumToRemove.Matter(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumA'
                //////////////////////////////////////
                "who" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumA.Who(
                        metas = sexp.metas)
                }
                "cares" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumA.Cares(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumB'
                //////////////////////////////////////
                "will_be_unchanged" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumB.WillBeUnchanged(
                        metas = sexp.metas)
                }
                "will_be_removed" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumB.WillBeRemoved(
                        metas = sexp.metas)
                }
                "will_be_replaced" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val something = sexp.getRequired(0).toLongPrimitive()
                    DomainA.SumB.WillBeReplaced(
                        something,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'UnpermutedSum'
                //////////////////////////////////////
                "unpermuted_product_variant" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainA.UnpermutedSum.UnpermutedProductVariant(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record_variant" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedSum.UnpermutedRecordVariant(foo, bar, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'domain_a'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitProductToRemove(node: DomainA.ProductToRemove) { }
        open fun visitRecordToRemove(node: DomainA.RecordToRemove) { }
        open fun visitProductA(node: DomainA.ProductA) { }
        open fun visitRecordA(node: DomainA.RecordA) { }
        open fun visitUnpermutedProduct(node: DomainA.UnpermutedProduct) { }
        open fun visitUnpermutedRecord(node: DomainA.UnpermutedRecord) { }
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        protected open fun visitSumToRemove(node: DomainA.SumToRemove) { }
        protected open fun visitSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt) { }
        protected open fun visitSumToRemoveMatter(node: DomainA.SumToRemove.Matter) { }
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        protected open fun visitSumA(node: DomainA.SumA) { }
        protected open fun visitSumAWho(node: DomainA.SumA.Who) { }
        protected open fun visitSumACares(node: DomainA.SumA.Cares) { }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        protected open fun visitSumB(node: DomainA.SumB) { }
        protected open fun visitSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged) { }
        protected open fun visitSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved) { }
        protected open fun visitSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced) { }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        protected open fun visitUnpermutedSum(node: DomainA.UnpermutedSum) { }
        protected open fun visitUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant) { }
        protected open fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkProductToRemove(node: DomainA.ProductToRemove) {
            visitProductToRemove(node)
            walkSymbolPrimitive(node.whatever)
            walkMetas(node.metas)
        }
    
        open fun walkRecordToRemove(node: DomainA.RecordToRemove) {
            visitRecordToRemove(node)
            walkLongPrimitive(node.irrelevant)
            walkMetas(node.metas)
        }
    
        open fun walkProductA(node: DomainA.ProductA) {
            visitProductA(node)
            walkLongPrimitive(node.one)
            walkMetas(node.metas)
        }
    
        open fun walkRecordA(node: DomainA.RecordA) {
            visitRecordA(node)
            walkLongPrimitive(node.one)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedProduct(node: DomainA.UnpermutedProduct) {
            visitUnpermutedProduct(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedRecord(node: DomainA.UnpermutedRecord) {
            visitUnpermutedRecord(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun walkSumToRemove(node: DomainA.SumToRemove) {
            visitSumToRemove(node)
            when(node) {
                is DomainA.SumToRemove.Doesnt -> walkSumToRemoveDoesnt(node)
                is DomainA.SumToRemove.Matter -> walkSumToRemoveMatter(node)
            }
        }
    
        open fun walkSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt) {
            visitSumToRemoveDoesnt(node)
            walkMetas(node.metas)
        }
    
        open fun walkSumToRemoveMatter(node: DomainA.SumToRemove.Matter) {
            visitSumToRemoveMatter(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun walkSumA(node: DomainA.SumA) {
            visitSumA(node)
            when(node) {
                is DomainA.SumA.Who -> walkSumAWho(node)
                is DomainA.SumA.Cares -> walkSumACares(node)
            }
        }
    
        open fun walkSumAWho(node: DomainA.SumA.Who) {
            visitSumAWho(node)
            walkMetas(node.metas)
        }
    
        open fun walkSumACares(node: DomainA.SumA.Cares) {
            visitSumACares(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainA.SumB) {
            visitSumB(node)
            when(node) {
                is DomainA.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> walkSumBWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged) {
            visitSumBWillBeUnchanged(node)
            walkMetas(node.metas)
        }
    
        open fun walkSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved) {
            visitSumBWillBeRemoved(node)
            walkMetas(node.metas)
        }
    
        open fun walkSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced) {
            visitSumBWillBeReplaced(node)
            walkLongPrimitive(node.something)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainA.UnpermutedSum) {
            visitUnpermutedSum(node)
            when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant) {
            visitUnpermutedSumUnpermutedProductVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) {
            visitUnpermutedSumUnpermutedRecordVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitProductToRemove(node: DomainA.ProductToRemove, accumulator: T): T = accumulator
        open protected fun visitRecordToRemove(node: DomainA.RecordToRemove, accumulator: T): T = accumulator
        open protected fun visitProductA(node: DomainA.ProductA, accumulator: T): T = accumulator
        open protected fun visitRecordA(node: DomainA.RecordA, accumulator: T): T = accumulator
        open protected fun visitUnpermutedProduct(node: DomainA.UnpermutedProduct, accumulator: T): T = accumulator
        open protected fun visitUnpermutedRecord(node: DomainA.UnpermutedRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open protected fun visitSumToRemove(node: DomainA.SumToRemove, accumulator: T): T = accumulator
        open protected fun visitSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt, accumulator: T): T = accumulator
        open protected fun visitSumToRemoveMatter(node: DomainA.SumToRemove.Matter, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open protected fun visitSumA(node: DomainA.SumA, accumulator: T): T = accumulator
        open protected fun visitSumAWho(node: DomainA.SumA.Who, accumulator: T): T = accumulator
        open protected fun visitSumACares(node: DomainA.SumA.Cares, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open protected fun visitSumB(node: DomainA.SumB, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open protected fun visitUnpermutedSum(node: DomainA.UnpermutedSum, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkProductToRemove(node: DomainA.ProductToRemove, accumulator: T): T {
            var current = accumulator
            current = visitProductToRemove(node, current)
            current = walkSymbolPrimitive(node.whatever, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordToRemove(node: DomainA.RecordToRemove, accumulator: T): T {
            var current = accumulator
            current = visitRecordToRemove(node, current)
            current = walkLongPrimitive(node.irrelevant, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductA(node: DomainA.ProductA, accumulator: T): T {
            var current = accumulator
            current = visitProductA(node, current)
            current = walkLongPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordA(node: DomainA.RecordA, accumulator: T): T {
            var current = accumulator
            current = visitRecordA(node, current)
            current = walkLongPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedProduct(node: DomainA.UnpermutedProduct, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedProduct(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedRecord(node: DomainA.UnpermutedRecord, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedRecord(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun walkSumToRemove(node: DomainA.SumToRemove, accumulator: T): T {
            val current = visitSumToRemove(node, accumulator)
            return when(node) {
                is DomainA.SumToRemove.Doesnt -> walkSumToRemoveDoesnt(node, current)
                is DomainA.SumToRemove.Matter -> walkSumToRemoveMatter(node, current)
            }
        }
    
        open fun walkSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt, accumulator: T): T {
            var current = accumulator
            current = visitSumToRemoveDoesnt(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumToRemoveMatter(node: DomainA.SumToRemove.Matter, accumulator: T): T {
            var current = accumulator
            current = visitSumToRemoveMatter(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun walkSumA(node: DomainA.SumA, accumulator: T): T {
            val current = visitSumA(node, accumulator)
            return when(node) {
                is DomainA.SumA.Who -> walkSumAWho(node, current)
                is DomainA.SumA.Cares -> walkSumACares(node, current)
            }
        }
    
        open fun walkSumAWho(node: DomainA.SumA.Who, accumulator: T): T {
            var current = accumulator
            current = visitSumAWho(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumACares(node: DomainA.SumA.Cares, accumulator: T): T {
            var current = accumulator
            current = visitSumACares(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainA.SumB, accumulator: T): T {
            val current = visitSumB(node, accumulator)
            return when(node) {
                is DomainA.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node, current)
                is DomainA.SumB.WillBeRemoved -> walkSumBWillBeRemoved(node, current)
                is DomainA.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node, current)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeUnchanged(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeRemoved(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeReplaced(node, current)
            current = walkLongPrimitive(node.something, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainA.UnpermutedSum, accumulator: T): T {
            val current = visitUnpermutedSum(node, accumulator)
            return when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node, current)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node, current)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedProductVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedRecordVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple ProductToRemove
        open fun transformProductToRemove(node: DomainA.ProductToRemove): DomainA.ProductToRemove {
            val new_whatever = transformProductToRemove_whatever(node)
            val new_metas = transformProductToRemove_metas(node)
            return if (
                node.whatever !== new_whatever ||
                node.metas !== new_metas
            ) {
                DomainA.ProductToRemove(
                    whatever = new_whatever,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductToRemove_whatever(node: DomainA.ProductToRemove) =
            transformSymbolPrimitive(node.whatever)
        open fun transformProductToRemove_metas(node: DomainA.ProductToRemove) =
            transformMetas(node.metas)
    
        // Tuple RecordToRemove
        open fun transformRecordToRemove(node: DomainA.RecordToRemove): DomainA.RecordToRemove {
            val new_irrelevant = transformRecordToRemove_irrelevant(node)
            val new_metas = transformRecordToRemove_metas(node)
            return if (
                node.irrelevant !== new_irrelevant ||
                node.metas !== new_metas
            ) {
                DomainA.RecordToRemove(
                    irrelevant = new_irrelevant,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordToRemove_irrelevant(node: DomainA.RecordToRemove) =
            transformLongPrimitive(node.irrelevant)
        open fun transformRecordToRemove_metas(node: DomainA.RecordToRemove) =
            transformMetas(node.metas)
    
        // Tuple ProductA
        open fun transformProductA(node: DomainA.ProductA): DomainA.ProductA {
            val new_one = transformProductA_one(node)
            val new_metas = transformProductA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainA.ProductA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductA_one(node: DomainA.ProductA) =
            transformLongPrimitive(node.one)
        open fun transformProductA_metas(node: DomainA.ProductA) =
            transformMetas(node.metas)
    
        // Tuple RecordA
        open fun transformRecordA(node: DomainA.RecordA): DomainA.RecordA {
            val new_one = transformRecordA_one(node)
            val new_metas = transformRecordA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainA.RecordA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordA_one(node: DomainA.RecordA) =
            transformLongPrimitive(node.one)
        open fun transformRecordA_metas(node: DomainA.RecordA) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedProduct
        open fun transformUnpermutedProduct(node: DomainA.UnpermutedProduct): DomainA.UnpermutedProduct {
            val new_foo = transformUnpermutedProduct_foo(node)
            val new_bar = transformUnpermutedProduct_bar(node)
            val new_metas = transformUnpermutedProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedProduct(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedProduct_foo(node: DomainA.UnpermutedProduct) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedProduct_bar(node: DomainA.UnpermutedProduct) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedProduct_metas(node: DomainA.UnpermutedProduct) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedRecord
        open fun transformUnpermutedRecord(node: DomainA.UnpermutedRecord): DomainA.UnpermutedRecord {
            val new_foo = transformUnpermutedRecord_foo(node)
            val new_bar = transformUnpermutedRecord_bar(node)
            val new_metas = transformUnpermutedRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedRecord(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedRecord_foo(node: DomainA.UnpermutedRecord) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedRecord_bar(node: DomainA.UnpermutedRecord) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedRecord_metas(node: DomainA.UnpermutedRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun transformSumToRemove(node: DomainA.SumToRemove): DomainA.SumToRemove =
            when(node) {
                is DomainA.SumToRemove.Doesnt -> transformSumToRemoveDoesnt(node)
                is DomainA.SumToRemove.Matter -> transformSumToRemoveMatter(node)
            }
        // Variant SumToRemoveDoesnt
        open fun transformSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt): DomainA.SumToRemove  {
            val new_metas = transformSumToRemoveDoesnt_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumToRemove.Doesnt(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToRemoveDoesnt_metas(node: DomainA.SumToRemove.Doesnt) =
            transformMetas(node.metas)
    
        // Variant SumToRemoveMatter
        open fun transformSumToRemoveMatter(node: DomainA.SumToRemove.Matter): DomainA.SumToRemove  {
            val new_metas = transformSumToRemoveMatter_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumToRemove.Matter(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToRemoveMatter_metas(node: DomainA.SumToRemove.Matter) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun transformSumA(node: DomainA.SumA): DomainA.SumA =
            when(node) {
                is DomainA.SumA.Who -> transformSumAWho(node)
                is DomainA.SumA.Cares -> transformSumACares(node)
            }
        // Variant SumAWho
        open fun transformSumAWho(node: DomainA.SumA.Who): DomainA.SumA  {
            val new_metas = transformSumAWho_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumA.Who(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumAWho_metas(node: DomainA.SumA.Who) =
            transformMetas(node.metas)
    
        // Variant SumACares
        open fun transformSumACares(node: DomainA.SumA.Cares): DomainA.SumA  {
            val new_metas = transformSumACares_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumA.Cares(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumACares_metas(node: DomainA.SumA.Cares) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun transformSumB(node: DomainA.SumB): DomainA.SumB =
            when(node) {
                is DomainA.SumB.WillBeUnchanged -> transformSumBWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> transformSumBWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> transformSumBWillBeReplaced(node)
            }
        // Variant SumBWillBeUnchanged
        open fun transformSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged): DomainA.SumB  {
            val new_metas = transformSumBWillBeUnchanged_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeUnchanged(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeUnchanged_metas(node: DomainA.SumB.WillBeUnchanged) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeRemoved
        open fun transformSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved): DomainA.SumB  {
            val new_metas = transformSumBWillBeRemoved_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeRemoved(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeRemoved_metas(node: DomainA.SumB.WillBeRemoved) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeReplaced
        open fun transformSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced): DomainA.SumB  {
            val new_something = transformSumBWillBeReplaced_something(node)
            val new_metas = transformSumBWillBeReplaced_metas(node)
            return if (
                node.something !== new_something ||
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeReplaced(
                    something = new_something,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeReplaced_something(node: DomainA.SumB.WillBeReplaced) =
            transformLongPrimitive(node.something)
        open fun transformSumBWillBeReplaced_metas(node: DomainA.SumB.WillBeReplaced) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun transformUnpermutedSum(node: DomainA.UnpermutedSum): DomainA.UnpermutedSum =
            when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> transformUnpermutedSumUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> transformUnpermutedSumUnpermutedRecordVariant(node)
            }
        // Variant UnpermutedSumUnpermutedProductVariant
        open fun transformUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant): DomainA.UnpermutedSum  {
            val new_foo = transformUnpermutedSumUnpermutedProductVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedProductVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedProductVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedSum.UnpermutedProductVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedProductVariant_foo(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedProductVariant_bar(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedProductVariant_metas(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformMetas(node.metas)
    
        // Variant UnpermutedSumUnpermutedRecordVariant
        open fun transformUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant): DomainA.UnpermutedSum  {
            val new_foo = transformUnpermutedSumUnpermutedRecordVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedRecordVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedRecordVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedSum.UnpermutedRecordVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedRecordVariant_foo(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedRecordVariant_bar(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedRecordVariant_metas(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformMetas(node.metas)
    
    }
}


class DomainB private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = DomainBBuilder
    
        fun <T: DomainBNode> build(block: Builder.() -> T) =
            DomainBBuilder.block()
    
        fun transform(element: AnyElement): DomainBNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): DomainBNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [DomainB.UnpermutedProduct].
         */
        fun unpermutedProduct(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedProduct =
            DomainB.UnpermutedProduct(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProduct_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedProduct =
            DomainB.UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.UnpermutedRecord].
         */
        fun unpermutedRecord(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedRecord =
            DomainB.UnpermutedRecord(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecord_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedRecord =
            DomainB.UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.ProductA].
         */
        fun productA(
            one: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.ProductA =
            DomainB.ProductA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.ProductA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productA_(
            one: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.ProductA =
            DomainB.ProductA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.RecordA].
         */
        fun recordA(
            one: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.RecordA =
            DomainB.RecordA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.RecordA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordA_(
            one: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.RecordA =
            DomainB.RecordA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewProduct].
         */
        fun newProduct(
            foo: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewProduct =
            DomainB.NewProduct(
                foo = foo.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.NewProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun newProduct_(
            foo: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewProduct =
            DomainB.NewProduct(
                foo = foo,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewRecord].
         */
        fun newRecord(
            foo: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewRecord =
            DomainB.NewRecord(
                foo = foo.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.NewRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun newRecord_(
            foo: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewRecord =
            DomainB.NewRecord(
                foo = foo,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: UnpermutedSum 
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedProductVariant].
         */
        fun unpermutedProductVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedProductVariant =
            DomainB.UnpermutedSum.UnpermutedProductVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedProductVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProductVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedProductVariant =
            DomainB.UnpermutedSum.UnpermutedProductVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedRecordVariant].
         */
        fun unpermutedRecordVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedRecordVariant =
            DomainB.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedRecordVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecordVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedRecordVariant =
            DomainB.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumB 
        /**
         * Creates an instance of [DomainB.SumB.WillBeUnchanged].
         */
        fun willBeUnchanged(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeUnchanged =
            DomainB.SumB.WillBeUnchanged(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.SumB.WillBeReplaced].
         */
        fun willBeReplaced(
            something: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeReplaced =
            DomainB.SumB.WillBeReplaced(
                something = something.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.SumB.WillBeReplaced].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun willBeReplaced_(
            something: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeReplaced =
            DomainB.SumB.WillBeReplaced(
                something = something,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: NewSum 
        /**
         * Creates an instance of [DomainB.NewSum.Eek].
         */
        fun eek(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewSum.Eek =
            DomainB.NewSum.Eek(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewSum.Whatever].
         */
        fun whatever(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewSum.Whatever =
            DomainB.NewSum.Whatever(
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object DomainBBuilder : Builder
    
    /** Base class for all DomainB types. */
    abstract class DomainBNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): DomainBNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): DomainBNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class UnpermutedProduct(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("unpermuted_product"),
                foo.toIonElement(),
                bar.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedProduct(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedProduct::class.java) return false
    
            other as UnpermutedProduct
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedRecord(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("unpermuted_record"),
                foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedRecord(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedRecord::class.java) return false
    
            other as UnpermutedRecord
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductA(
        val one: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): ProductA =
            ProductA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductA =
            ProductA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_a"),
                one.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            one: org.partiql.pig.runtime.SymbolPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            ProductA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductA::class.java) return false
    
            other as ProductA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordA(
        val one: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): RecordA =
            RecordA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordA =
            RecordA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_a"),
                one?.let { ionSexpOf(ionSymbol("one"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            one: org.partiql.pig.runtime.SymbolPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            RecordA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordA::class.java) return false
    
            other as RecordA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class NewProduct(
        val foo: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): NewProduct =
            NewProduct(
                foo = foo,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): NewProduct =
            NewProduct(
                foo = foo,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("new_product"),
                foo.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.LongPrimitive = this.foo,
            metas: MetaContainer = this.metas
        ) =
            NewProduct(
                foo,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != NewProduct::class.java) return false
    
            other as NewProduct
            if (foo != other.foo) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class NewRecord(
        val foo: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): NewRecord =
            NewRecord(
                foo = foo,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): NewRecord =
            NewRecord(
                foo = foo,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("new_record"),
                foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.LongPrimitive = this.foo,
            metas: MetaContainer = this.metas
        ) =
            NewRecord(
                foo,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != NewRecord::class.java) return false
    
            other as NewRecord
            if (foo != other.foo) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = foo.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class UnpermutedSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): UnpermutedSum =
            when (this) {
                is UnpermutedProductVariant -> copy(metas = metas)
                is UnpermutedRecordVariant -> copy(metas = metas)
            }
    
        class UnpermutedProductVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unpermuted_product_variant"),
                    foo.toIonElement(),
                    bar.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedProductVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedProductVariant::class.java) return false
        
                other as UnpermutedProductVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class UnpermutedRecordVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("unpermuted_record_variant"),
                    foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                    bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedRecordVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedRecordVariant::class.java) return false
        
                other as UnpermutedRecordVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainB.UnpermutedSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.UnpermutedSum): T = when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> convertUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> convertUnpermutedRecordVariant(node)
            }
    
            fun convertUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant): T
            fun convertUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant): T
        }
    }
    
    sealed class SumB(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): SumB =
            when (this) {
                is WillBeUnchanged -> copy(metas = metas)
                is WillBeReplaced -> copy(metas = metas)
            }
    
        class WillBeUnchanged(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_unchanged"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeUnchanged::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class WillBeReplaced(
            val something: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_replaced"),
                    something.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                something: org.partiql.pig.runtime.SymbolPrimitive = this.something,
                metas: MetaContainer = this.metas
            ) =
                WillBeReplaced(
                    something,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeReplaced::class.java) return false
        
                other as WillBeReplaced
                if (something != other.something) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = something.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainB.SumB] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.SumB): T = when(node) {
                is DomainB.SumB.WillBeUnchanged -> convertWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> convertWillBeReplaced(node)
            }
    
            fun convertWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged): T
            fun convertWillBeReplaced(node: DomainB.SumB.WillBeReplaced): T
        }
    }
    
    sealed class NewSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): NewSum =
            when (this) {
                is Eek -> copy(metas = metas)
                is Whatever -> copy(metas = metas)
            }
    
        class Eek(
            override val metas: MetaContainer = emptyMetaContainer()
        ): NewSum() {
        
            override fun copy(metas: MetaContainer): Eek =
                Eek(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Eek =
                Eek(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("eek"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Eek::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Whatever(
            override val metas: MetaContainer = emptyMetaContainer()
        ): NewSum() {
        
            override fun copy(metas: MetaContainer): Whatever =
                Whatever(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Whatever =
                Whatever(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("whatever"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Whatever::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        /** Converts instances of [DomainB.NewSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.NewSum): T = when(node) {
                is DomainB.NewSum.Eek -> convertEek(node)
                is DomainB.NewSum.Whatever -> convertWhatever(node)
            }
    
            fun convertEek(node: DomainB.NewSum.Eek): T
            fun convertWhatever(node: DomainB.NewSum.Whatever): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<DomainBNode>() {
    
        override fun innerTransform(sexp: SexpElement): DomainBNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "unpermuted_product" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainB.UnpermutedProduct(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedRecord(foo, bar, metas = sexp.metas)
                }
                "product_a" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val one = sexp.getRequired(0).toSymbolPrimitive()
                    DomainB.ProductA(
                        one,
                        metas = sexp.metas)
                }
                "record_a" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val one = ir.processRequiredField("one") { it.toSymbolPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordA(one, metas = sexp.metas)
                }
                "new_product" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val foo = sexp.getRequired(0).toLongPrimitive()
                    DomainB.NewProduct(
                        foo,
                        metas = sexp.metas)
                }
                "new_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    NewRecord(foo, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'UnpermutedSum'
                //////////////////////////////////////
                "unpermuted_product_variant" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainB.UnpermutedSum.UnpermutedProductVariant(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record_variant" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedSum.UnpermutedRecordVariant(foo, bar, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumB'
                //////////////////////////////////////
                "will_be_unchanged" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.SumB.WillBeUnchanged(
                        metas = sexp.metas)
                }
                "will_be_replaced" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val something = sexp.getRequired(0).toSymbolPrimitive()
                    DomainB.SumB.WillBeReplaced(
                        something,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'NewSum'
                //////////////////////////////////////
                "eek" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.NewSum.Eek(
                        metas = sexp.metas)
                }
                "whatever" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.NewSum.Whatever(
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'domain_b'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitUnpermutedProduct(node: DomainB.UnpermutedProduct) { }
        open fun visitUnpermutedRecord(node: DomainB.UnpermutedRecord) { }
        open fun visitProductA(node: DomainB.ProductA) { }
        open fun visitRecordA(node: DomainB.RecordA) { }
        open fun visitNewProduct(node: DomainB.NewProduct) { }
        open fun visitNewRecord(node: DomainB.NewRecord) { }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        protected open fun visitUnpermutedSum(node: DomainB.UnpermutedSum) { }
        protected open fun visitUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant) { }
        protected open fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) { }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        protected open fun visitSumB(node: DomainB.SumB) { }
        protected open fun visitSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged) { }
        protected open fun visitSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced) { }
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        protected open fun visitNewSum(node: DomainB.NewSum) { }
        protected open fun visitNewSumEek(node: DomainB.NewSum.Eek) { }
        protected open fun visitNewSumWhatever(node: DomainB.NewSum.Whatever) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkUnpermutedProduct(node: DomainB.UnpermutedProduct) {
            visitUnpermutedProduct(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedRecord(node: DomainB.UnpermutedRecord) {
            visitUnpermutedRecord(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkProductA(node: DomainB.ProductA) {
            visitProductA(node)
            walkSymbolPrimitive(node.one)
            walkMetas(node.metas)
        }
    
        open fun walkRecordA(node: DomainB.RecordA) {
            visitRecordA(node)
            walkSymbolPrimitive(node.one)
            walkMetas(node.metas)
        }
    
        open fun walkNewProduct(node: DomainB.NewProduct) {
            visitNewProduct(node)
            walkLongPrimitive(node.foo)
            walkMetas(node.metas)
        }
    
        open fun walkNewRecord(node: DomainB.NewRecord) {
            visitNewRecord(node)
            walkLongPrimitive(node.foo)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainB.UnpermutedSum) {
            visitUnpermutedSum(node)
            when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant) {
            visitUnpermutedSumUnpermutedProductVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) {
            visitUnpermutedSumUnpermutedRecordVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainB.SumB) {
            visitSumB(node)
            when(node) {
                is DomainB.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged) {
            visitSumBWillBeUnchanged(node)
            walkMetas(node.metas)
        }
    
        open fun walkSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced) {
            visitSumBWillBeReplaced(node)
            walkSymbolPrimitive(node.something)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun walkNewSum(node: DomainB.NewSum) {
            visitNewSum(node)
            when(node) {
                is DomainB.NewSum.Eek -> walkNewSumEek(node)
                is DomainB.NewSum.Whatever -> walkNewSumWhatever(node)
            }
        }
    
        open fun walkNewSumEek(node: DomainB.NewSum.Eek) {
            visitNewSumEek(node)
            walkMetas(node.metas)
        }
    
        open fun walkNewSumWhatever(node: DomainB.NewSum.Whatever) {
            visitNewSumWhatever(node)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitUnpermutedProduct(node: DomainB.UnpermutedProduct, accumulator: T): T = accumulator
        open protected fun visitUnpermutedRecord(node: DomainB.UnpermutedRecord, accumulator: T): T = accumulator
        open protected fun visitProductA(node: DomainB.ProductA, accumulator: T): T = accumulator
        open protected fun visitRecordA(node: DomainB.RecordA, accumulator: T): T = accumulator
        open protected fun visitNewProduct(node: DomainB.NewProduct, accumulator: T): T = accumulator
        open protected fun visitNewRecord(node: DomainB.NewRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open protected fun visitUnpermutedSum(node: DomainB.UnpermutedSum, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open protected fun visitSumB(node: DomainB.SumB, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open protected fun visitNewSum(node: DomainB.NewSum, accumulator: T): T = accumulator
        open protected fun visitNewSumEek(node: DomainB.NewSum.Eek, accumulator: T): T = accumulator
        open protected fun visitNewSumWhatever(node: DomainB.NewSum.Whatever, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkUnpermutedProduct(node: DomainB.UnpermutedProduct, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedProduct(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedRecord(node: DomainB.UnpermutedRecord, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedRecord(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductA(node: DomainB.ProductA, accumulator: T): T {
            var current = accumulator
            current = visitProductA(node, current)
            current = walkSymbolPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordA(node: DomainB.RecordA, accumulator: T): T {
            var current = accumulator
            current = visitRecordA(node, current)
            current = walkSymbolPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewProduct(node: DomainB.NewProduct, accumulator: T): T {
            var current = accumulator
            current = visitNewProduct(node, current)
            current = walkLongPrimitive(node.foo, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewRecord(node: DomainB.NewRecord, accumulator: T): T {
            var current = accumulator
            current = visitNewRecord(node, current)
            current = walkLongPrimitive(node.foo, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainB.UnpermutedSum, accumulator: T): T {
            val current = visitUnpermutedSum(node, accumulator)
            return when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node, current)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node, current)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedProductVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedRecordVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainB.SumB, accumulator: T): T {
            val current = visitSumB(node, accumulator)
            return when(node) {
                is DomainB.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node, current)
                is DomainB.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node, current)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeUnchanged(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeReplaced(node, current)
            current = walkSymbolPrimitive(node.something, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun walkNewSum(node: DomainB.NewSum, accumulator: T): T {
            val current = visitNewSum(node, accumulator)
            return when(node) {
                is DomainB.NewSum.Eek -> walkNewSumEek(node, current)
                is DomainB.NewSum.Whatever -> walkNewSumWhatever(node, current)
            }
        }
    
        open fun walkNewSumEek(node: DomainB.NewSum.Eek, accumulator: T): T {
            var current = accumulator
            current = visitNewSumEek(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewSumWhatever(node: DomainB.NewSum.Whatever, accumulator: T): T {
            var current = accumulator
            current = visitNewSumWhatever(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple UnpermutedProduct
        open fun transformUnpermutedProduct(node: DomainB.UnpermutedProduct): DomainB.UnpermutedProduct {
            val new_foo = transformUnpermutedProduct_foo(node)
            val new_bar = transformUnpermutedProduct_bar(node)
            val new_metas = transformUnpermutedProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedProduct(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedProduct_foo(node: DomainB.UnpermutedProduct) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedProduct_bar(node: DomainB.UnpermutedProduct) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedProduct_metas(node: DomainB.UnpermutedProduct) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedRecord
        open fun transformUnpermutedRecord(node: DomainB.UnpermutedRecord): DomainB.UnpermutedRecord {
            val new_foo = transformUnpermutedRecord_foo(node)
            val new_bar = transformUnpermutedRecord_bar(node)
            val new_metas = transformUnpermutedRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedRecord(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedRecord_foo(node: DomainB.UnpermutedRecord) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedRecord_bar(node: DomainB.UnpermutedRecord) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedRecord_metas(node: DomainB.UnpermutedRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductA
        open fun transformProductA(node: DomainB.ProductA): DomainB.ProductA {
            val new_one = transformProductA_one(node)
            val new_metas = transformProductA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainB.ProductA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductA_one(node: DomainB.ProductA) =
            transformSymbolPrimitive(node.one)
        open fun transformProductA_metas(node: DomainB.ProductA) =
            transformMetas(node.metas)
    
        // Tuple RecordA
        open fun transformRecordA(node: DomainB.RecordA): DomainB.RecordA {
            val new_one = transformRecordA_one(node)
            val new_metas = transformRecordA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainB.RecordA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordA_one(node: DomainB.RecordA) =
            transformSymbolPrimitive(node.one)
        open fun transformRecordA_metas(node: DomainB.RecordA) =
            transformMetas(node.metas)
    
        // Tuple NewProduct
        open fun transformNewProduct(node: DomainB.NewProduct): DomainB.NewProduct {
            val new_foo = transformNewProduct_foo(node)
            val new_metas = transformNewProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.metas !== new_metas
            ) {
                DomainB.NewProduct(
                    foo = new_foo,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewProduct_foo(node: DomainB.NewProduct) =
            transformLongPrimitive(node.foo)
        open fun transformNewProduct_metas(node: DomainB.NewProduct) =
            transformMetas(node.metas)
    
        // Tuple NewRecord
        open fun transformNewRecord(node: DomainB.NewRecord): DomainB.NewRecord {
            val new_foo = transformNewRecord_foo(node)
            val new_metas = transformNewRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.metas !== new_metas
            ) {
                DomainB.NewRecord(
                    foo = new_foo,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewRecord_foo(node: DomainB.NewRecord) =
            transformLongPrimitive(node.foo)
        open fun transformNewRecord_metas(node: DomainB.NewRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun transformUnpermutedSum(node: DomainB.UnpermutedSum): DomainB.UnpermutedSum =
            when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> transformUnpermutedSumUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> transformUnpermutedSumUnpermutedRecordVariant(node)
            }
        // Variant UnpermutedSumUnpermutedProductVariant
        open fun transformUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant): DomainB.UnpermutedSum  {
            val new_foo = transformUnpermutedSumUnpermutedProductVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedProductVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedProductVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedSum.UnpermutedProductVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedProductVariant_foo(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedProductVariant_bar(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedProductVariant_metas(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformMetas(node.metas)
    
        // Variant UnpermutedSumUnpermutedRecordVariant
        open fun transformUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant): DomainB.UnpermutedSum  {
            val new_foo = transformUnpermutedSumUnpermutedRecordVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedRecordVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedRecordVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedSum.UnpermutedRecordVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedRecordVariant_foo(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedRecordVariant_bar(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedRecordVariant_metas(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun transformSumB(node: DomainB.SumB): DomainB.SumB =
            when(node) {
                is DomainB.SumB.WillBeUnchanged -> transformSumBWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> transformSumBWillBeReplaced(node)
            }
        // Variant SumBWillBeUnchanged
        open fun transformSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged): DomainB.SumB  {
            val new_metas = transformSumBWillBeUnchanged_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.SumB.WillBeUnchanged(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeUnchanged_metas(node: DomainB.SumB.WillBeUnchanged) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeReplaced
        open fun transformSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced): DomainB.SumB  {
            val new_something = transformSumBWillBeReplaced_something(node)
            val new_metas = transformSumBWillBeReplaced_metas(node)
            return if (
                node.something !== new_something ||
                node.metas !== new_metas
            ) {
                DomainB.SumB.WillBeReplaced(
                    something = new_something,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeReplaced_something(node: DomainB.SumB.WillBeReplaced) =
            transformSymbolPrimitive(node.something)
        open fun transformSumBWillBeReplaced_metas(node: DomainB.SumB.WillBeReplaced) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun transformNewSum(node: DomainB.NewSum): DomainB.NewSum =
            when(node) {
                is DomainB.NewSum.Eek -> transformNewSumEek(node)
                is DomainB.NewSum.Whatever -> transformNewSumWhatever(node)
            }
        // Variant NewSumEek
        open fun transformNewSumEek(node: DomainB.NewSum.Eek): DomainB.NewSum  {
            val new_metas = transformNewSumEek_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.NewSum.Eek(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewSumEek_metas(node: DomainB.NewSum.Eek) =
            transformMetas(node.metas)
    
        // Variant NewSumWhatever
        open fun transformNewSumWhatever(node: DomainB.NewSum.Whatever): DomainB.NewSum  {
            val new_metas = transformNewSumWhatever_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.NewSum.Whatever(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewSumWhatever_metas(node: DomainB.NewSum.Whatever) =
            transformMetas(node.metas)
    
    }
}



//////////////////////////////////////
// Cross domain transforms
//////////////////////////////////////

abstract class DomainAToDomainBVisitorTransform : DomainVisitorTransformBase() {
    //////////////////////////////////////
    // Tuple Types
    //////////////////////////////////////
    // Tuple ProductA
    abstract fun transformProductA(node:DomainA.ProductA): DomainB.ProductA
    // Tuple RecordA
    abstract fun transformRecordA(node:DomainA.RecordA): DomainB.RecordA
    // Tuple UnpermutedProduct
    open fun transformUnpermutedProduct(node: DomainA.UnpermutedProduct): DomainB.UnpermutedProduct {
        val new_foo = transformUnpermutedProduct_foo(node)
        val new_bar = transformUnpermutedProduct_bar(node)
        val new_metas = transformUnpermutedProduct_metas(node)
        return             DomainB.UnpermutedProduct(
                foo = new_foo,
                bar = new_bar,
                metas = new_metas
            )
    }
    open fun transformUnpermutedProduct_foo(node: DomainA.UnpermutedProduct) =
        transformSymbolPrimitive(node.foo)
    open fun transformUnpermutedProduct_bar(node: DomainA.UnpermutedProduct) =
        transformLongPrimitive(node.bar)
    open fun transformUnpermutedProduct_metas(node: DomainA.UnpermutedProduct) =
        transformMetas(node.metas)

    // Tuple UnpermutedRecord
    open fun transformUnpermutedRecord(node: DomainA.UnpermutedRecord): DomainB.UnpermutedRecord {
        val new_foo = transformUnpermutedRecord_foo(node)
        val new_bar = transformUnpermutedRecord_bar(node)
        val new_metas = transformUnpermutedRecord_metas(node)
        return             DomainB.UnpermutedRecord(
                foo = new_foo,
                bar = new_bar,
                metas = new_metas
            )
    }
    open fun transformUnpermutedRecord_foo(node: DomainA.UnpermutedRecord) =
        transformSymbolPrimitive(node.foo)
    open fun transformUnpermutedRecord_bar(node: DomainA.UnpermutedRecord) =
        transformLongPrimitive(node.bar)
    open fun transformUnpermutedRecord_metas(node: DomainA.UnpermutedRecord) =
        transformMetas(node.metas)

    //////////////////////////////////////
    // Sum Type: SumB
    //////////////////////////////////////
    open fun transformSumB(node: DomainA.SumB): DomainB.SumB =
        when(node) {
            is DomainA.SumB.WillBeUnchanged -> transformSumBWillBeUnchanged(node)
            is DomainA.SumB.WillBeRemoved -> transformSumBWillBeRemoved(node)
            is DomainA.SumB.WillBeReplaced -> transformSumBWillBeReplaced(node)
        }
    // Variant SumBWillBeUnchanged
    open fun transformSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged): DomainB.SumB  {
        val new_metas = transformSumBWillBeUnchanged_metas(node)
        return             DomainB.SumB.WillBeUnchanged(
                metas = new_metas
            )
    }
    open fun transformSumBWillBeUnchanged_metas(node: DomainA.SumB.WillBeUnchanged) =
        transformMetas(node.metas)

    // Variant SumBWillBeRemoved
    abstract fun transformSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved): DomainB.SumB
    // Variant SumBWillBeReplaced
    abstract fun transformSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced): DomainB.SumB
    //////////////////////////////////////
    // Sum Type: UnpermutedSum
    //////////////////////////////////////
    open fun transformUnpermutedSum(node: DomainA.UnpermutedSum): DomainB.UnpermutedSum =
        when(node) {
            is DomainA.UnpermutedSum.UnpermutedProductVariant -> transformUnpermutedSumUnpermutedProductVariant(node)
            is DomainA.UnpermutedSum.UnpermutedRecordVariant -> transformUnpermutedSumUnpermutedRecordVariant(node)
        }
    // Variant UnpermutedSumUnpermutedProductVariant
    open fun transformUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant): DomainB.UnpermutedSum  {
        val new_foo = transformUnpermutedSumUnpermutedProductVariant_foo(node)
        val new_bar = transformUnpermutedSumUnpermutedProductVariant_bar(node)
        val new_metas = transformUnpermutedSumUnpermutedProductVariant_metas(node)
        return             DomainB.UnpermutedSum.UnpermutedProductVariant(
                foo = new_foo,
                bar = new_bar,
                metas = new_metas
            )
    }
    open fun transformUnpermutedSumUnpermutedProductVariant_foo(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
        transformSymbolPrimitive(node.foo)
    open fun transformUnpermutedSumUnpermutedProductVariant_bar(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
        transformLongPrimitive(node.bar)
    open fun transformUnpermutedSumUnpermutedProductVariant_metas(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
        transformMetas(node.metas)

    // Variant UnpermutedSumUnpermutedRecordVariant
    open fun transformUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant): DomainB.UnpermutedSum  {
        val new_foo = transformUnpermutedSumUnpermutedRecordVariant_foo(node)
        val new_bar = transformUnpermutedSumUnpermutedRecordVariant_bar(node)
        val new_metas = transformUnpermutedSumUnpermutedRecordVariant_metas(node)
        return             DomainB.UnpermutedSum.UnpermutedRecordVariant(
                foo = new_foo,
                bar = new_bar,
                metas = new_metas
            )
    }
    open fun transformUnpermutedSumUnpermutedRecordVariant_foo(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
        transformSymbolPrimitive(node.foo)
    open fun transformUnpermutedSumUnpermutedRecordVariant_bar(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
        transformLongPrimitive(node.bar)
    open fun transformUnpermutedSumUnpermutedRecordVariant_metas(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
        transformMetas(node.metas)

}
