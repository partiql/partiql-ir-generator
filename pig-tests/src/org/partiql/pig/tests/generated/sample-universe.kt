/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
    "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
    "USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class ToyLang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNode> build(block: Builder.() -> T) =
            Builder.block()
    
        fun transform(element: AnyElement): ToyLangNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNode =
            Transformer().transform(element)
    }
    
    object Builder {
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [ToyLang.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Lit =
            ToyLang.Expr.Lit(
                value = value.asAnyElement(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Variable].
         */
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Variable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Variable =
            ToyLang.Expr.Variable(
                name = name,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Not =
            ToyLang.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Plus =
            ToyLang.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Minus =
            ToyLang.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Times =
            ToyLang.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Divide =
            ToyLang.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Modulo =
            ToyLang.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Call].
         */
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Call =
            ToyLang.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Let].
         */
        fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Let].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Let =
            ToyLang.Expr.Let(
                name = name,
                value = value,
                body = body,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLang.Expr.Function].
         */
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLang.Expr.Function].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLang.Expr.Function =
            ToyLang.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLang types. */
    abstract class ToyLangNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNode() {
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                metas: MetaContainer = this.metas) =
                Variable(
                    name,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                argument: Expr = this.argument,
                metas: MetaContainer = this.metas) =
                Call(
                    name,
                    argument,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                value: Expr = this.value,
                body: Expr = this.body,
                metas: MetaContainer = this.metas) =
                Let(
                    name,
                    value,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                varName: org.partiql.pig.runtime.SymbolPrimitive = this.varName,
                body: Expr = this.body,
                metas: MetaContainer = this.metas) =
                Function(
                    varName,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLang.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    ToyLang.Expr.Variable(
                        name,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLang.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLang.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLang.Expr.Let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLang.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: ToyLang.Expr) { }
        protected open fun visitExprLit(node: ToyLang.Expr.Lit) { }
        protected open fun visitExprVariable(node: ToyLang.Expr.Variable) { }
        protected open fun visitExprNot(node: ToyLang.Expr.Not) { }
        protected open fun visitExprPlus(node: ToyLang.Expr.Plus) { }
        protected open fun visitExprMinus(node: ToyLang.Expr.Minus) { }
        protected open fun visitExprTimes(node: ToyLang.Expr.Times) { }
        protected open fun visitExprDivide(node: ToyLang.Expr.Divide) { }
        protected open fun visitExprModulo(node: ToyLang.Expr.Modulo) { }
        protected open fun visitExprCall(node: ToyLang.Expr.Call) { }
        protected open fun visitExprLet(node: ToyLang.Expr.Let) { }
        protected open fun visitExprFunction(node: ToyLang.Expr.Function) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLang.Expr) {
            visitExpr(node)
            when(node) {
                is ToyLang.Expr.Lit -> walkExprLit(node)
                is ToyLang.Expr.Variable -> walkExprVariable(node)
                is ToyLang.Expr.Not -> walkExprNot(node)
                is ToyLang.Expr.Plus -> walkExprPlus(node)
                is ToyLang.Expr.Minus -> walkExprMinus(node)
                is ToyLang.Expr.Times -> walkExprTimes(node)
                is ToyLang.Expr.Divide -> walkExprDivide(node)
                is ToyLang.Expr.Modulo -> walkExprModulo(node)
                is ToyLang.Expr.Call -> walkExprCall(node)
                is ToyLang.Expr.Let -> walkExprLet(node)
                is ToyLang.Expr.Function -> walkExprFunction(node)
            }
        }
    
        open fun walkExprLit(node: ToyLang.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLang.Expr.Variable) {
            visitExprVariable(node)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLang.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLang.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLang.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLang.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLang.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLang.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLang.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLang.Expr.Let) {
            visitExprLet(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLang.Expr.Function) {
            visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: ToyLang.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: ToyLang.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprVariable(node: ToyLang.Expr.Variable, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: ToyLang.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: ToyLang.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: ToyLang.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: ToyLang.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: ToyLang.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: ToyLang.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: ToyLang.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprLet(node: ToyLang.Expr.Let, accumulator: T): T = accumulator
        open protected fun visitExprFunction(node: ToyLang.Expr.Function, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLang.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is ToyLang.Expr.Lit -> walkExprLit(node, current)
                is ToyLang.Expr.Variable -> walkExprVariable(node, current)
                is ToyLang.Expr.Not -> walkExprNot(node, current)
                is ToyLang.Expr.Plus -> walkExprPlus(node, current)
                is ToyLang.Expr.Minus -> walkExprMinus(node, current)
                is ToyLang.Expr.Times -> walkExprTimes(node, current)
                is ToyLang.Expr.Divide -> walkExprDivide(node, current)
                is ToyLang.Expr.Modulo -> walkExprModulo(node, current)
                is ToyLang.Expr.Call -> walkExprCall(node, current)
                is ToyLang.Expr.Let -> walkExprLet(node, current)
                is ToyLang.Expr.Function -> walkExprFunction(node, current)
            }
        }
    
        open fun walkExprLit(node: ToyLang.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprVariable(node: ToyLang.Expr.Variable, accumulator: T): T {
            var current = accumulator
            current = visitExprVariable(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: ToyLang.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: ToyLang.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: ToyLang.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: ToyLang.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: ToyLang.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: ToyLang.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: ToyLang.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.argument, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLet(node: ToyLang.Expr.Let, accumulator: T): T {
            var current = accumulator
            current = visitExprLet(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprFunction(node: ToyLang.Expr.Function, accumulator: T): T {
            var current = accumulator
            current = visitExprFunction(node, current)
            current = walkSymbolPrimitive(node.varName, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: ToyLang.Expr) =
            when(node) {
                is ToyLang.Expr.Lit -> transformExprLit(node)
                is ToyLang.Expr.Variable -> transformExprVariable(node)
                is ToyLang.Expr.Not -> transformExprNot(node)
                is ToyLang.Expr.Plus -> transformExprPlus(node)
                is ToyLang.Expr.Minus -> transformExprMinus(node)
                is ToyLang.Expr.Times -> transformExprTimes(node)
                is ToyLang.Expr.Divide -> transformExprDivide(node)
                is ToyLang.Expr.Modulo -> transformExprModulo(node)
                is ToyLang.Expr.Call -> transformExprCall(node)
                is ToyLang.Expr.Let -> transformExprLet(node)
                is ToyLang.Expr.Function -> transformExprFunction(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: ToyLang.Expr.Lit): ToyLang.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return build {
                Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLit_value(node: Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: Expr.Lit) =
            transformMetas(node.metas)
    
    
        // Variant ExprVariable
        open fun transformExprVariable(node: ToyLang.Expr.Variable): ToyLang.Expr {
            val new_name = transformExprVariable_name(node)
            val new_metas = transformExprVariable_metas(node)
            return build {
                Expr.Variable(
                    name = new_name,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprVariable_name(node: Expr.Variable) =
            transformSymbolPrimitive(node.name)
        open fun transformExprVariable_metas(node: Expr.Variable) =
            transformMetas(node.metas)
    
    
        // Variant ExprNot
        open fun transformExprNot(node: ToyLang.Expr.Not): ToyLang.Expr {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return build {
                Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprNot_expr(node: Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: Expr.Not) =
            transformMetas(node.metas)
    
    
        // Variant ExprPlus
        open fun transformExprPlus(node: ToyLang.Expr.Plus): ToyLang.Expr {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return build {
                Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprPlus_operands(node: Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: Expr.Plus) =
            transformMetas(node.metas)
    
    
        // Variant ExprMinus
        open fun transformExprMinus(node: ToyLang.Expr.Minus): ToyLang.Expr {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return build {
                Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprMinus_operands(node: Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: Expr.Minus) =
            transformMetas(node.metas)
    
    
        // Variant ExprTimes
        open fun transformExprTimes(node: ToyLang.Expr.Times): ToyLang.Expr {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return build {
                Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprTimes_operands(node: Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: Expr.Times) =
            transformMetas(node.metas)
    
    
        // Variant ExprDivide
        open fun transformExprDivide(node: ToyLang.Expr.Divide): ToyLang.Expr {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return build {
                Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprDivide_operands(node: Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: Expr.Divide) =
            transformMetas(node.metas)
    
    
        // Variant ExprModulo
        open fun transformExprModulo(node: ToyLang.Expr.Modulo): ToyLang.Expr {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return build {
                Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprModulo_operands(node: Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: Expr.Modulo) =
            transformMetas(node.metas)
    
    
        // Variant ExprCall
        open fun transformExprCall(node: ToyLang.Expr.Call): ToyLang.Expr {
            val new_name = transformExprCall_name(node)
            val new_argument = transformExprCall_argument(node)
            val new_metas = transformExprCall_metas(node)
            return build {
                Expr.Call(
                    name = new_name,
                    argument = new_argument,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprCall_name(node: Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_argument(node: Expr.Call) =
            transformExpr(node.argument)
        open fun transformExprCall_metas(node: Expr.Call) =
            transformMetas(node.metas)
    
    
        // Variant ExprLet
        open fun transformExprLet(node: ToyLang.Expr.Let): ToyLang.Expr {
            val new_name = transformExprLet_name(node)
            val new_value = transformExprLet_value(node)
            val new_body = transformExprLet_body(node)
            val new_metas = transformExprLet_metas(node)
            return build {
                Expr.Let(
                    name = new_name,
                    value = new_value,
                    body = new_body,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLet_name(node: Expr.Let) =
            transformSymbolPrimitive(node.name)
        open fun transformExprLet_value(node: Expr.Let) =
            transformExpr(node.value)
        open fun transformExprLet_body(node: Expr.Let) =
            transformExpr(node.body)
        open fun transformExprLet_metas(node: Expr.Let) =
            transformMetas(node.metas)
    
    
        // Variant ExprFunction
        open fun transformExprFunction(node: ToyLang.Expr.Function): ToyLang.Expr {
            val new_varName = transformExprFunction_varName(node)
            val new_body = transformExprFunction_body(node)
            val new_metas = transformExprFunction_metas(node)
            return build {
                Expr.Function(
                    varName = new_varName,
                    body = new_body,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprFunction_varName(node: Expr.Function) =
            transformSymbolPrimitive(node.varName)
        open fun transformExprFunction_body(node: Expr.Function) =
            transformExpr(node.body)
        open fun transformExprFunction_metas(node: Expr.Function) =
            transformMetas(node.metas)
    
    
    }
}

class ToyLangNameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: ToyLangNamelessNode> build(block: Builder.() -> T) =
            Builder.block()
    
        fun transform(element: AnyElement): ToyLangNamelessNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): ToyLangNamelessNode =
            Transformer().transform(element)
    }
    
    object Builder {
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [ToyLangNameless.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Lit =
            ToyLangNameless.Expr.Lit(
                value = value.asAnyElement(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Not =
            ToyLangNameless.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Plus =
            ToyLangNameless.Expr.Plus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Plus =
            ToyLangNameless.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Minus =
            ToyLangNameless.Expr.Minus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Minus =
            ToyLangNameless.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Times =
            ToyLangNameless.Expr.Times(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Times =
            ToyLangNameless.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Divide =
            ToyLangNameless.Expr.Divide(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Divide =
            ToyLangNameless.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Modulo =
            ToyLangNameless.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Modulo =
            ToyLangNameless.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Call].
         */
        fun call(
            name: String,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Call =
            ToyLangNameless.Expr.Call(
                name = name.asPrimitive(),
                argument = argument,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            argument: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Call =
            ToyLangNameless.Expr.Call(
                name = name,
                argument = argument,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Function].
         */
        fun function(
            varName: String,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Function =
            ToyLangNameless.Expr.Function(
                varName = varName.asPrimitive(),
                body = body,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Function].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun function_(
            varName: org.partiql.pig.runtime.SymbolPrimitive,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Function =
            ToyLangNameless.Expr.Function(
                varName = varName,
                body = body,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Variable].
         */
        fun variable(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Variable =
            ToyLangNameless.Expr.Variable(
                index = index.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Variable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variable_(
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Variable =
            ToyLangNameless.Expr.Variable(
                index = index,
                metas = metas)
        
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Let].
         */
        fun let(
            index: Long,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Let =
            ToyLangNameless.Expr.Let(
                index = index.asPrimitive(),
                value = value,
                body = body,
                metas = metas)
        
        /**
         * Creates an instance of [ToyLangNameless.Expr.Let].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun let_(
            index: org.partiql.pig.runtime.LongPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): ToyLangNameless.Expr.Let =
            ToyLangNameless.Expr.Let(
                index = index,
                value = value,
                body = body,
                metas = metas)
    }
    
    /** Base class for all ToyLangNameless types. */
    abstract class ToyLangNamelessNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): ToyLangNamelessNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr : ToyLangNamelessNode() {
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val argument: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    argument = argument,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    argument.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                argument: Expr = this.argument,
                metas: MetaContainer = this.metas) =
                Call(
                    name,
                    argument,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (argument != other.argument) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + argument.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Function(
            val varName: org.partiql.pig.runtime.SymbolPrimitive,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Function =
                Function(
                    varName = varName,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    varName.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                varName: org.partiql.pig.runtime.SymbolPrimitive = this.varName,
                body: Expr = this.body,
                metas: MetaContainer = this.metas) =
                Function(
                    varName,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Function::class.java) return false
        
                other as Function
                if (varName != other.varName) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = varName.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                metas: MetaContainer = this.metas) =
                Variable(
                    index,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val index: org.partiql.pig.runtime.LongPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    index = index,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    index.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                value: Expr = this.value,
                body: Expr = this.body,
                metas: MetaContainer = this.metas) =
                Let(
                    index,
                    value,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (index != other.index) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<ToyLangNamelessNode>() {
    
        override fun innerTransform(sexp: SexpElement): ToyLangNamelessNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    ToyLangNameless.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    ToyLangNameless.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    ToyLangNameless.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val argument = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Call(
                        name,
                        argument,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val varName = sexp.getRequired(0).toSymbolPrimitive()
                    val body = sexp.getRequired(1).transformExpect<Expr>()
                    ToyLangNameless.Expr.Function(
                        varName,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    ToyLangNameless.Expr.Variable(
                        index,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    ToyLangNameless.Expr.Let(
                        index,
                        value,
                        body,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_nameless'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: ToyLangNameless.Expr) { }
        protected open fun visitExprLit(node: ToyLangNameless.Expr.Lit) { }
        protected open fun visitExprNot(node: ToyLangNameless.Expr.Not) { }
        protected open fun visitExprPlus(node: ToyLangNameless.Expr.Plus) { }
        protected open fun visitExprMinus(node: ToyLangNameless.Expr.Minus) { }
        protected open fun visitExprTimes(node: ToyLangNameless.Expr.Times) { }
        protected open fun visitExprDivide(node: ToyLangNameless.Expr.Divide) { }
        protected open fun visitExprModulo(node: ToyLangNameless.Expr.Modulo) { }
        protected open fun visitExprCall(node: ToyLangNameless.Expr.Call) { }
        protected open fun visitExprFunction(node: ToyLangNameless.Expr.Function) { }
        protected open fun visitExprVariable(node: ToyLangNameless.Expr.Variable) { }
        protected open fun visitExprLet(node: ToyLangNameless.Expr.Let) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLangNameless.Expr) {
            visitExpr(node)
            when(node) {
                is ToyLangNameless.Expr.Lit -> walkExprLit(node)
                is ToyLangNameless.Expr.Not -> walkExprNot(node)
                is ToyLangNameless.Expr.Plus -> walkExprPlus(node)
                is ToyLangNameless.Expr.Minus -> walkExprMinus(node)
                is ToyLangNameless.Expr.Times -> walkExprTimes(node)
                is ToyLangNameless.Expr.Divide -> walkExprDivide(node)
                is ToyLangNameless.Expr.Modulo -> walkExprModulo(node)
                is ToyLangNameless.Expr.Call -> walkExprCall(node)
                is ToyLangNameless.Expr.Function -> walkExprFunction(node)
                is ToyLangNameless.Expr.Variable -> walkExprVariable(node)
                is ToyLangNameless.Expr.Let -> walkExprLet(node)
            }
        }
    
        open fun walkExprLit(node: ToyLangNameless.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: ToyLangNameless.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: ToyLangNameless.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: ToyLangNameless.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: ToyLangNameless.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: ToyLangNameless.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: ToyLangNameless.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: ToyLangNameless.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.argument)
            walkMetas(node.metas)
        }
    
        open fun walkExprFunction(node: ToyLangNameless.Expr.Function) {
            visitExprFunction(node)
            walkSymbolPrimitive(node.varName)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
        open fun walkExprVariable(node: ToyLangNameless.Expr.Variable) {
            visitExprVariable(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprLet(node: ToyLangNameless.Expr.Let) {
            visitExprLet(node)
            walkLongPrimitive(node.index)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: ToyLangNameless.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: ToyLangNameless.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: ToyLangNameless.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: ToyLangNameless.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: ToyLangNameless.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: ToyLangNameless.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: ToyLangNameless.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: ToyLangNameless.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: ToyLangNameless.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprFunction(node: ToyLangNameless.Expr.Function, accumulator: T): T = accumulator
        open protected fun visitExprVariable(node: ToyLangNameless.Expr.Variable, accumulator: T): T = accumulator
        open protected fun visitExprLet(node: ToyLangNameless.Expr.Let, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: ToyLangNameless.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is ToyLangNameless.Expr.Lit -> walkExprLit(node, current)
                is ToyLangNameless.Expr.Not -> walkExprNot(node, current)
                is ToyLangNameless.Expr.Plus -> walkExprPlus(node, current)
                is ToyLangNameless.Expr.Minus -> walkExprMinus(node, current)
                is ToyLangNameless.Expr.Times -> walkExprTimes(node, current)
                is ToyLangNameless.Expr.Divide -> walkExprDivide(node, current)
                is ToyLangNameless.Expr.Modulo -> walkExprModulo(node, current)
                is ToyLangNameless.Expr.Call -> walkExprCall(node, current)
                is ToyLangNameless.Expr.Function -> walkExprFunction(node, current)
                is ToyLangNameless.Expr.Variable -> walkExprVariable(node, current)
                is ToyLangNameless.Expr.Let -> walkExprLet(node, current)
            }
        }
    
        open fun walkExprLit(node: ToyLangNameless.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: ToyLangNameless.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: ToyLangNameless.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: ToyLangNameless.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: ToyLangNameless.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: ToyLangNameless.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: ToyLangNameless.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: ToyLangNameless.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.argument, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprFunction(node: ToyLangNameless.Expr.Function, accumulator: T): T {
            var current = accumulator
            current = visitExprFunction(node, current)
            current = walkSymbolPrimitive(node.varName, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprVariable(node: ToyLangNameless.Expr.Variable, accumulator: T): T {
            var current = accumulator
            current = visitExprVariable(node, current)
            current = walkLongPrimitive(node.index, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLet(node: ToyLangNameless.Expr.Let, accumulator: T): T {
            var current = accumulator
            current = visitExprLet(node, current)
            current = walkLongPrimitive(node.index, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: ToyLangNameless.Expr) =
            when(node) {
                is ToyLangNameless.Expr.Lit -> transformExprLit(node)
                is ToyLangNameless.Expr.Not -> transformExprNot(node)
                is ToyLangNameless.Expr.Plus -> transformExprPlus(node)
                is ToyLangNameless.Expr.Minus -> transformExprMinus(node)
                is ToyLangNameless.Expr.Times -> transformExprTimes(node)
                is ToyLangNameless.Expr.Divide -> transformExprDivide(node)
                is ToyLangNameless.Expr.Modulo -> transformExprModulo(node)
                is ToyLangNameless.Expr.Call -> transformExprCall(node)
                is ToyLangNameless.Expr.Function -> transformExprFunction(node)
                is ToyLangNameless.Expr.Variable -> transformExprVariable(node)
                is ToyLangNameless.Expr.Let -> transformExprLet(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: ToyLangNameless.Expr.Lit): ToyLangNameless.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return build {
                Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLit_value(node: Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: Expr.Lit) =
            transformMetas(node.metas)
    
    
        // Variant ExprNot
        open fun transformExprNot(node: ToyLangNameless.Expr.Not): ToyLangNameless.Expr {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return build {
                Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprNot_expr(node: Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: Expr.Not) =
            transformMetas(node.metas)
    
    
        // Variant ExprPlus
        open fun transformExprPlus(node: ToyLangNameless.Expr.Plus): ToyLangNameless.Expr {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return build {
                Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprPlus_operands(node: Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: Expr.Plus) =
            transformMetas(node.metas)
    
    
        // Variant ExprMinus
        open fun transformExprMinus(node: ToyLangNameless.Expr.Minus): ToyLangNameless.Expr {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return build {
                Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprMinus_operands(node: Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: Expr.Minus) =
            transformMetas(node.metas)
    
    
        // Variant ExprTimes
        open fun transformExprTimes(node: ToyLangNameless.Expr.Times): ToyLangNameless.Expr {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return build {
                Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprTimes_operands(node: Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: Expr.Times) =
            transformMetas(node.metas)
    
    
        // Variant ExprDivide
        open fun transformExprDivide(node: ToyLangNameless.Expr.Divide): ToyLangNameless.Expr {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return build {
                Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprDivide_operands(node: Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: Expr.Divide) =
            transformMetas(node.metas)
    
    
        // Variant ExprModulo
        open fun transformExprModulo(node: ToyLangNameless.Expr.Modulo): ToyLangNameless.Expr {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return build {
                Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprModulo_operands(node: Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: Expr.Modulo) =
            transformMetas(node.metas)
    
    
        // Variant ExprCall
        open fun transformExprCall(node: ToyLangNameless.Expr.Call): ToyLangNameless.Expr {
            val new_name = transformExprCall_name(node)
            val new_argument = transformExprCall_argument(node)
            val new_metas = transformExprCall_metas(node)
            return build {
                Expr.Call(
                    name = new_name,
                    argument = new_argument,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprCall_name(node: Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_argument(node: Expr.Call) =
            transformExpr(node.argument)
        open fun transformExprCall_metas(node: Expr.Call) =
            transformMetas(node.metas)
    
    
        // Variant ExprFunction
        open fun transformExprFunction(node: ToyLangNameless.Expr.Function): ToyLangNameless.Expr {
            val new_varName = transformExprFunction_varName(node)
            val new_body = transformExprFunction_body(node)
            val new_metas = transformExprFunction_metas(node)
            return build {
                Expr.Function(
                    varName = new_varName,
                    body = new_body,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprFunction_varName(node: Expr.Function) =
            transformSymbolPrimitive(node.varName)
        open fun transformExprFunction_body(node: Expr.Function) =
            transformExpr(node.body)
        open fun transformExprFunction_metas(node: Expr.Function) =
            transformMetas(node.metas)
    
    
        // Variant ExprVariable
        open fun transformExprVariable(node: ToyLangNameless.Expr.Variable): ToyLangNameless.Expr {
            val new_index = transformExprVariable_index(node)
            val new_metas = transformExprVariable_metas(node)
            return build {
                Expr.Variable(
                    index = new_index,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprVariable_index(node: Expr.Variable) =
            transformLongPrimitive(node.index)
        open fun transformExprVariable_metas(node: Expr.Variable) =
            transformMetas(node.metas)
    
    
        // Variant ExprLet
        open fun transformExprLet(node: ToyLangNameless.Expr.Let): ToyLangNameless.Expr {
            val new_index = transformExprLet_index(node)
            val new_value = transformExprLet_value(node)
            val new_body = transformExprLet_body(node)
            val new_metas = transformExprLet_metas(node)
            return build {
                Expr.Let(
                    index = new_index,
                    value = new_value,
                    body = new_body,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLet_index(node: Expr.Let) =
            transformLongPrimitive(node.index)
        open fun transformExprLet_value(node: Expr.Let) =
            transformExpr(node.value)
        open fun transformExprLet_body(node: Expr.Let) =
            transformExpr(node.body)
        open fun transformExprLet_metas(node: Expr.Let) =
            transformMetas(node.metas)
    
    
    }
}

class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: TestDomainNode> build(block: Builder.() -> T) =
            Builder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            Transformer().transform(element)
    }
    
    object Builder {
                // Tuples
        /**
         * Creates an instance of [TestDomain.IntPair].
         */
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         */
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IonPair].
         */
        fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPair =
            TestDomain.IonPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         */
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         */
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         */
        fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IonSymbolPair].
         */
        fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonSymbolPair =
            TestDomain.IonSymbolPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IntPairPair].
         */
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPairPair].
         */
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IonPairPair].
         */
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         */
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.AnswerPair].
         */
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         */
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         */
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         */
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         */
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         */
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         */
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive? = null,
            second: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         */
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         */
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.TestSumTriplet].
         */
        fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSumTriplet =
            TestDomain.TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.EntityPair].
         */
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = metas)
        
        
        // Variants for Sum: Answer 
        /**
         * Creates an instance of [TestDomain.Answer.No].
         */
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.No =
            TestDomain.Answer.No(
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.Answer.Yes].
         */
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.Yes =
            TestDomain.Answer.Yes(
                metas = metas)
        
        
        // Variants for Sum: SumWithRecord 
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         */
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        // Variants for Sum: TestSum 
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         */
        fun one(
            a: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         */
        fun two(
            a: Long,
            b: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a,
                b = b,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         */
        fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                c = c.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        // Variants for Sum: Entity 
        /**
         * Creates an instance of [TestDomain.Entity.Slug].
         */
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Slug =
            TestDomain.Entity.Slug(
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         */
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id,
                metas = metas)
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         */
        fun human(
            firstName: String,
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class IntPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            IntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            SymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas) =
            IonPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            IntSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            SymbolIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            IonIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas) =
            IonSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IntPair = this.first,
            second: IntPair = this.second,
            metas: MetaContainer = this.metas) =
            IntPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: SymbolPair = this.first,
            second: SymbolPair = this.second,
            metas: MetaContainer = this.metas) =
            SymbolPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IonPair = this.first,
            second: IonPair = this.second,
            metas: MetaContainer = this.metas) =
            IonPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: RecursivePair? = this.second,
            metas: MetaContainer = this.metas) =
            RecursivePair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas) =
            AnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            AnswerIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas) =
            IntAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas) =
            SymbolAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas) =
            AnswerSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas) =
            VariadicMin0(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas) =
            VariadicMin1(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas) =
            ElementVariadic(
                name,
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive? = this.value,
            metas: MetaContainer = this.metas) =
            Optional1(
                value,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: org.partiql.pig.runtime.LongPrimitive?,
        val second: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive? = this.first,
            second: org.partiql.pig.runtime.LongPrimitive? = this.second,
            metas: MetaContainer = this.metas) =
            Optional2(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: org.partiql.pig.runtime.LongPrimitive,
        val anotherField: org.partiql.pig.runtime.SymbolPrimitive,
        val optionalField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            someField: org.partiql.pig.runtime.LongPrimitive = this.someField,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive = this.anotherField,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = this.optionalField,
            metas: MetaContainer = this.metas) =
            DomainLevelRecord(
                someField,
                anotherField,
                optionalField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: org.partiql.pig.runtime.LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive = this.value,
            dlr: DomainLevelRecord = this.dlr,
            metas: MetaContainer = this.metas) =
            ProductWithRecord(
                value,
                dlr,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class TestSumTriplet(
        val a: TestSum,
        val b: TestSum,
        val c: TestSum,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("test_sum_triplet"),
                a.toIonElement(),
                b.toIonElement(),
                c.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            a: TestSum = this.a,
            b: TestSum = this.b,
            c: TestSum = this.c,
            metas: MetaContainer = this.metas) =
            TestSumTriplet(
                a,
                b,
                c,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TestSumTriplet::class.java) return false
    
            other as TestSumTriplet
            if (a != other.a) return false
            if (b != other.b) return false
            if (c != other.c) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = a.hashCode()
            hc = 31 * hc + b.hashCode()
            hc = 31 * hc + c.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Entity = this.first,
            second: Entity = this.second,
            metas: MetaContainer = this.metas) =
            EntityPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer : TestDomainNode() {
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                No(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Yes(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class SumWithRecord : TestDomainNode() {
    
        class VariantWithRecord(
            val value: org.partiql.pig.runtime.LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                dlr: DomainLevelRecord = this.dlr,
                metas: MetaContainer = this.metas) =
                VariantWithRecord(
                    value,
                    dlr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class TestSum : TestDomainNode() {
    
        class One(
            val a: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): One =
                One(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("one"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                metas: MetaContainer = this.metas) =
                One(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != One::class.java) return false
        
                other as One
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Two(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("two"),
                    a.toIonElement(),
                    b.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                metas: MetaContainer = this.metas) =
                Two(
                    a,
                    b,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Two::class.java) return false
        
                other as Two
                if (a != other.a) return false
                if (b != other.b) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Three(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            val c: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("three"),
                    a.toIonElement(),
                    b.toIonElement(),
                    c.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                c: org.partiql.pig.runtime.LongPrimitive = this.c,
                metas: MetaContainer = this.metas) =
                Three(
                    a,
                    b,
                    c,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Three::class.java) return false
        
                other as Three
                if (a != other.a) return false
                if (b != other.b) return false
                if (c != other.c) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc = 31 * hc + c.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class Entity : TestDomainNode() {
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Slug(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class Android(
            val id: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                id: org.partiql.pig.runtime.LongPrimitive = this.id,
                metas: MetaContainer = this.metas) =
                Android(
                    id,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: org.partiql.pig.runtime.SymbolPrimitive,
            val lastName: org.partiql.pig.runtime.SymbolPrimitive,
            val title: org.partiql.pig.runtime.SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                firstName: org.partiql.pig.runtime.SymbolPrimitive = this.firstName,
                lastName: org.partiql.pig.runtime.SymbolPrimitive = this.lastName,
                title: org.partiql.pig.runtime.SymbolPrimitive? = this.title,
                parent: Entity? = this.parent,
                metas: MetaContainer = this.metas) =
                Human(
                    firstName,
                    lastName,
                    title,
                    parent,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = firstName.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "test_sum_triplet" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).transformExpect<TestSum>()
                    val b = sexp.getRequired(1).transformExpect<TestSum>()
                    val c = sexp.getRequired(2).transformExpect<TestSum>()
                    TestDomain.TestSumTriplet(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'TestSum'
                //////////////////////////////////////
                "one" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.TestSum.One(
                        a,
                        metas = sexp.metas)
                }
                "two" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.TestSum.Two(
                        a,
                        b,
                        metas = sexp.metas)
                }
                "three" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    val c = sexp.getRequired(2).toLongPrimitive()
                    TestDomain.TestSum.Three(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitIntPair(node: TestDomain.IntPair) { }
        open fun visitSymbolPair(node: TestDomain.SymbolPair) { }
        open fun visitIonPair(node: TestDomain.IonPair) { }
        open fun visitIntSymbolPair(node: TestDomain.IntSymbolPair) { }
        open fun visitSymbolIntPair(node: TestDomain.SymbolIntPair) { }
        open fun visitIonIntPair(node: TestDomain.IonIntPair) { }
        open fun visitIonSymbolPair(node: TestDomain.IonSymbolPair) { }
        open fun visitIntPairPair(node: TestDomain.IntPairPair) { }
        open fun visitSymbolPairPair(node: TestDomain.SymbolPairPair) { }
        open fun visitIonPairPair(node: TestDomain.IonPairPair) { }
        open fun visitRecursivePair(node: TestDomain.RecursivePair) { }
        open fun visitAnswerPair(node: TestDomain.AnswerPair) { }
        open fun visitAnswerIntPair(node: TestDomain.AnswerIntPair) { }
        open fun visitIntAnswerPair(node: TestDomain.IntAnswerPair) { }
        open fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) { }
        open fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) { }
        open fun visitVariadicMin0(node: TestDomain.VariadicMin0) { }
        open fun visitVariadicMin1(node: TestDomain.VariadicMin1) { }
        open fun visitElementVariadic(node: TestDomain.ElementVariadic) { }
        open fun visitOptional1(node: TestDomain.Optional1) { }
        open fun visitOptional2(node: TestDomain.Optional2) { }
        open fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord) { }
        open fun visitProductWithRecord(node: TestDomain.ProductWithRecord) { }
        open fun visitTestSumTriplet(node: TestDomain.TestSumTriplet) { }
        open fun visitEntityPair(node: TestDomain.EntityPair) { }
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        protected open fun visitAnswer(node: TestDomain.Answer) { }
        protected open fun visitAnswerNo(node: TestDomain.Answer.No) { }
        protected open fun visitAnswerYes(node: TestDomain.Answer.Yes) { }
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        protected open fun visitSumWithRecord(node: TestDomain.SumWithRecord) { }
        protected open fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) { }
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        protected open fun visitTestSum(node: TestDomain.TestSum) { }
        protected open fun visitTestSumOne(node: TestDomain.TestSum.One) { }
        protected open fun visitTestSumTwo(node: TestDomain.TestSum.Two) { }
        protected open fun visitTestSumThree(node: TestDomain.TestSum.Three) { }
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        protected open fun visitEntity(node: TestDomain.Entity) { }
        protected open fun visitEntitySlug(node: TestDomain.Entity.Slug) { }
        protected open fun visitEntityAndroid(node: TestDomain.Entity.Android) { }
        protected open fun visitEntityHuman(node: TestDomain.Entity.Human) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkIntPair(node: TestDomain.IntPair) {
            visitIntPair(node)
            walkLongPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair) {
            visitSymbolPair(node)
            walkSymbolPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPair(node: TestDomain.IonPair) {
            visitIonPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair) {
            visitIntSymbolPair(node)
            walkLongPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair) {
            visitSymbolIntPair(node)
            walkSymbolPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair) {
            visitIonIntPair(node)
            walkAnyElement(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair) {
            visitIonSymbolPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair) {
            visitIntPairPair(node)
            walkIntPair(node.first)
            walkIntPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair) {
            visitSymbolPairPair(node)
            walkSymbolPair(node.first)
            walkSymbolPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair) {
            visitIonPairPair(node)
            walkIonPair(node.first)
            walkIonPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair) {
            visitRecursivePair(node)
            walkLongPrimitive(node.first)
            node.second?.let { walkRecursivePair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair) {
            visitAnswerPair(node)
            walkAnswer(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair) {
            visitAnswerIntPair(node)
            walkAnswer(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair) {
            visitIntAnswerPair(node)
            walkLongPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) {
            visitSymbolAnswerPair(node)
            walkSymbolPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) {
            visitAnswerSymbolPair(node)
            walkAnswer(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0) {
            visitVariadicMin0(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1) {
            visitVariadicMin1(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic) {
            visitElementVariadic(node)
            walkSymbolPrimitive(node.name)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional1(node: TestDomain.Optional1) {
            visitOptional1(node)
            node.value?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional2(node: TestDomain.Optional2) {
            visitOptional2(node)
            node.first?.let { walkLongPrimitive(it) }
            node.second?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord) {
            visitDomainLevelRecord(node)
            walkLongPrimitive(node.someField)
            walkSymbolPrimitive(node.anotherField)
            node.optionalField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord) {
            visitProductWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet) {
            visitTestSumTriplet(node)
            walkTestSum(node.a)
            walkTestSum(node.b)
            walkTestSum(node.c)
            walkMetas(node.metas)
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair) {
            visitEntityPair(node)
            walkEntity(node.first)
            walkEntity(node.second)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer) {
            visitAnswer(node)
            when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node)
                is TestDomain.Answer.Yes -> walkAnswerYes(node)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No) {
            visitAnswerNo(node)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes) {
            visitAnswerYes(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord) {
            visitSumWithRecord(node)
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) {
            visitSumWithRecordVariantWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum) {
            visitTestSum(node)
            when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node)
                is TestDomain.TestSum.Three -> walkTestSumThree(node)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One) {
            visitTestSumOne(node)
            walkLongPrimitive(node.a)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two) {
            visitTestSumTwo(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three) {
            visitTestSumThree(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkLongPrimitive(node.c)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity) {
            visitEntity(node)
            when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node)
                is TestDomain.Entity.Android -> walkEntityAndroid(node)
                is TestDomain.Entity.Human -> walkEntityHuman(node)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug) {
            visitEntitySlug(node)
            walkMetas(node.metas)
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android) {
            visitEntityAndroid(node)
            walkLongPrimitive(node.id)
            walkMetas(node.metas)
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human) {
            visitEntityHuman(node)
            walkSymbolPrimitive(node.firstName)
            walkSymbolPrimitive(node.lastName)
            node.title?.let { walkSymbolPrimitive(it) }
            node.parent?.let { walkEntity(it) }
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitIntPair(node: TestDomain.IntPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T = accumulator
        open protected fun visitIonPair(node: TestDomain.IonPair, accumulator: T): T = accumulator
        open protected fun visitIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T = accumulator
        open protected fun visitSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T = accumulator
        open protected fun visitIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T = accumulator
        open protected fun visitIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T = accumulator
        open protected fun visitIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T = accumulator
        open protected fun visitIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T = accumulator
        open protected fun visitRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T = accumulator
        open protected fun visitAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T = accumulator
        open protected fun visitIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T = accumulator
        open protected fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T = accumulator
        open protected fun visitVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T = accumulator
        open protected fun visitVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T = accumulator
        open protected fun visitElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T = accumulator
        open protected fun visitOptional1(node: TestDomain.Optional1, accumulator: T): T = accumulator
        open protected fun visitOptional2(node: TestDomain.Optional2, accumulator: T): T = accumulator
        open protected fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T = accumulator
        open protected fun visitProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T = accumulator
        open protected fun visitTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T = accumulator
        open protected fun visitEntityPair(node: TestDomain.EntityPair, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open protected fun visitAnswer(node: TestDomain.Answer, accumulator: T): T = accumulator
        open protected fun visitAnswerNo(node: TestDomain.Answer.No, accumulator: T): T = accumulator
        open protected fun visitAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open protected fun visitSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T = accumulator
        open protected fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open protected fun visitTestSum(node: TestDomain.TestSum, accumulator: T): T = accumulator
        open protected fun visitTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T = accumulator
        open protected fun visitTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T = accumulator
        open protected fun visitTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open protected fun visitEntity(node: TestDomain.Entity, accumulator: T): T = accumulator
        open protected fun visitEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T = accumulator
        open protected fun visitEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T = accumulator
        open protected fun visitEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkIntPair(node: TestDomain.IntPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPair(node: TestDomain.IonPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIntSymbolPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolIntPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T {
            var current = accumulator
            current = visitIonIntPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIonSymbolPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPairPair(node, current)
            current = walkIntPair(node.first, current)
            current = walkIntPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPairPair(node, current)
            current = walkSymbolPair(node.first, current)
            current = walkSymbolPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPairPair(node, current)
            current = walkIonPair(node.first, current)
            current = walkIonPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T {
            var current = accumulator
            current = visitRecursivePair(node, current)
            current = walkLongPrimitive(node.first, current)
            node.second?.let { current = walkRecursivePair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerIntPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitIntAnswerPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolAnswerPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerSymbolPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin0(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin1(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T {
            var current = accumulator
            current = visitElementVariadic(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional1(node: TestDomain.Optional1, accumulator: T): T {
            var current = accumulator
            current = visitOptional1(node, current)
            node.value?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional2(node: TestDomain.Optional2, accumulator: T): T {
            var current = accumulator
            current = visitOptional2(node, current)
            node.first?.let { current = walkLongPrimitive(it, current) }
            node.second?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T {
            var current = accumulator
            current = visitDomainLevelRecord(node, current)
            current = walkLongPrimitive(node.someField, current)
            current = walkSymbolPrimitive(node.anotherField, current)
            node.optionalField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitProductWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTriplet(node, current)
            current = walkTestSum(node.a, current)
            current = walkTestSum(node.b, current)
            current = walkTestSum(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair, accumulator: T): T {
            var current = accumulator
            current = visitEntityPair(node, current)
            current = walkEntity(node.first, current)
            current = walkEntity(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer, accumulator: T): T {
            val current = visitAnswer(node, accumulator)
            return when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node, current)
                is TestDomain.Answer.Yes -> walkAnswerYes(node, current)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No, accumulator: T): T {
            var current = accumulator
            current = visitAnswerNo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T {
            var current = accumulator
            current = visitAnswerYes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T {
            val current = visitSumWithRecord(node, accumulator)
            return when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node, current)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitSumWithRecordVariantWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum, accumulator: T): T {
            val current = visitTestSum(node, accumulator)
            return when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node, current)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node, current)
                is TestDomain.TestSum.Three -> walkTestSumThree(node, current)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T {
            var current = accumulator
            current = visitTestSumOne(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTwo(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T {
            var current = accumulator
            current = visitTestSumThree(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkLongPrimitive(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity, accumulator: T): T {
            val current = visitEntity(node, accumulator)
            return when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node, current)
                is TestDomain.Entity.Android -> walkEntityAndroid(node, current)
                is TestDomain.Entity.Human -> walkEntityHuman(node, current)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T {
            var current = accumulator
            current = visitEntitySlug(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T {
            var current = accumulator
            current = visitEntityAndroid(node, current)
            current = walkLongPrimitive(node.id, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T {
            var current = accumulator
            current = visitEntityHuman(node, current)
            current = walkSymbolPrimitive(node.firstName, current)
            current = walkSymbolPrimitive(node.lastName, current)
            node.title?.let { current = walkSymbolPrimitive(it, current) }
            node.parent?.let { current = walkEntity(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple IntPair
        open fun transformIntPair(node: IntPair): IntPair {
            val new_first = transformIntPair_first(node)
            val new_second = transformIntPair_second(node)
            val new_metas = transformIntPair_metas(node)
            return build {
                IntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntPair_first(node: IntPair) =
            transformLongPrimitive(node.first)
        open fun transformIntPair_second(node: IntPair) =
            transformLongPrimitive(node.second)
        open fun transformIntPair_metas(node: IntPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPair
        open fun transformSymbolPair(node: SymbolPair): SymbolPair {
            val new_first = transformSymbolPair_first(node)
            val new_second = transformSymbolPair_second(node)
            val new_metas = transformSymbolPair_metas(node)
            return build {
                SymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolPair_first(node: SymbolPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolPair_second(node: SymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformSymbolPair_metas(node: SymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IonPair
        open fun transformIonPair(node: IonPair): IonPair {
            val new_first = transformIonPair_first(node)
            val new_second = transformIonPair_second(node)
            val new_metas = transformIonPair_metas(node)
            return build {
                IonPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonPair_first(node: IonPair) =
            transformAnyElement(node.first)
        open fun transformIonPair_second(node: IonPair) =
            transformAnyElement(node.second)
        open fun transformIonPair_metas(node: IonPair) =
            transformMetas(node.metas)
    
        // Tuple IntSymbolPair
        open fun transformIntSymbolPair(node: IntSymbolPair): IntSymbolPair {
            val new_first = transformIntSymbolPair_first(node)
            val new_second = transformIntSymbolPair_second(node)
            val new_metas = transformIntSymbolPair_metas(node)
            return build {
                IntSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntSymbolPair_first(node: IntSymbolPair) =
            transformLongPrimitive(node.first)
        open fun transformIntSymbolPair_second(node: IntSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformIntSymbolPair_metas(node: IntSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolIntPair
        open fun transformSymbolIntPair(node: SymbolIntPair): SymbolIntPair {
            val new_first = transformSymbolIntPair_first(node)
            val new_second = transformSymbolIntPair_second(node)
            val new_metas = transformSymbolIntPair_metas(node)
            return build {
                SymbolIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolIntPair_first(node: SymbolIntPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolIntPair_second(node: SymbolIntPair) =
            transformLongPrimitive(node.second)
        open fun transformSymbolIntPair_metas(node: SymbolIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonIntPair
        open fun transformIonIntPair(node: IonIntPair): IonIntPair {
            val new_first = transformIonIntPair_first(node)
            val new_second = transformIonIntPair_second(node)
            val new_metas = transformIonIntPair_metas(node)
            return build {
                IonIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonIntPair_first(node: IonIntPair) =
            transformAnyElement(node.first)
        open fun transformIonIntPair_second(node: IonIntPair) =
            transformLongPrimitive(node.second)
        open fun transformIonIntPair_metas(node: IonIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonSymbolPair
        open fun transformIonSymbolPair(node: IonSymbolPair): IonSymbolPair {
            val new_first = transformIonSymbolPair_first(node)
            val new_second = transformIonSymbolPair_second(node)
            val new_metas = transformIonSymbolPair_metas(node)
            return build {
                IonSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonSymbolPair_first(node: IonSymbolPair) =
            transformAnyElement(node.first)
        open fun transformIonSymbolPair_second(node: IonSymbolPair) =
            transformAnyElement(node.second)
        open fun transformIonSymbolPair_metas(node: IonSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPairPair
        open fun transformIntPairPair(node: IntPairPair): IntPairPair {
            val new_first = transformIntPairPair_first(node)
            val new_second = transformIntPairPair_second(node)
            val new_metas = transformIntPairPair_metas(node)
            return build {
                IntPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntPairPair_first(node: IntPairPair) =
            transformIntPair(node.first)
        open fun transformIntPairPair_second(node: IntPairPair) =
            transformIntPair(node.second)
        open fun transformIntPairPair_metas(node: IntPairPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPairPair
        open fun transformSymbolPairPair(node: SymbolPairPair): SymbolPairPair {
            val new_first = transformSymbolPairPair_first(node)
            val new_second = transformSymbolPairPair_second(node)
            val new_metas = transformSymbolPairPair_metas(node)
            return build {
                SymbolPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolPairPair_first(node: SymbolPairPair) =
            transformSymbolPair(node.first)
        open fun transformSymbolPairPair_second(node: SymbolPairPair) =
            transformSymbolPair(node.second)
        open fun transformSymbolPairPair_metas(node: SymbolPairPair) =
            transformMetas(node.metas)
    
        // Tuple IonPairPair
        open fun transformIonPairPair(node: IonPairPair): IonPairPair {
            val new_first = transformIonPairPair_first(node)
            val new_second = transformIonPairPair_second(node)
            val new_metas = transformIonPairPair_metas(node)
            return build {
                IonPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonPairPair_first(node: IonPairPair) =
            transformIonPair(node.first)
        open fun transformIonPairPair_second(node: IonPairPair) =
            transformIonPair(node.second)
        open fun transformIonPairPair_metas(node: IonPairPair) =
            transformMetas(node.metas)
    
        // Tuple RecursivePair
        open fun transformRecursivePair(node: RecursivePair): RecursivePair {
            val new_first = transformRecursivePair_first(node)
            val new_second = transformRecursivePair_second(node)
            val new_metas = transformRecursivePair_metas(node)
            return build {
                RecursivePair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformRecursivePair_first(node: RecursivePair) =
            transformLongPrimitive(node.first)
        open fun transformRecursivePair_second(node: RecursivePair) =
            node.second?.let { transformRecursivePair(it) }
        open fun transformRecursivePair_metas(node: RecursivePair) =
            transformMetas(node.metas)
    
        // Tuple AnswerPair
        open fun transformAnswerPair(node: AnswerPair): AnswerPair {
            val new_first = transformAnswerPair_first(node)
            val new_second = transformAnswerPair_second(node)
            val new_metas = transformAnswerPair_metas(node)
            return build {
                AnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerPair_first(node: AnswerPair) =
            transformAnswer(node.first)
        open fun transformAnswerPair_second(node: AnswerPair) =
            transformAnswer(node.second)
        open fun transformAnswerPair_metas(node: AnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerIntPair
        open fun transformAnswerIntPair(node: AnswerIntPair): AnswerIntPair {
            val new_first = transformAnswerIntPair_first(node)
            val new_second = transformAnswerIntPair_second(node)
            val new_metas = transformAnswerIntPair_metas(node)
            return build {
                AnswerIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerIntPair_first(node: AnswerIntPair) =
            transformAnswer(node.first)
        open fun transformAnswerIntPair_second(node: AnswerIntPair) =
            transformLongPrimitive(node.second)
        open fun transformAnswerIntPair_metas(node: AnswerIntPair) =
            transformMetas(node.metas)
    
        // Tuple IntAnswerPair
        open fun transformIntAnswerPair(node: IntAnswerPair): IntAnswerPair {
            val new_first = transformIntAnswerPair_first(node)
            val new_second = transformIntAnswerPair_second(node)
            val new_metas = transformIntAnswerPair_metas(node)
            return build {
                IntAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntAnswerPair_first(node: IntAnswerPair) =
            transformLongPrimitive(node.first)
        open fun transformIntAnswerPair_second(node: IntAnswerPair) =
            transformAnswer(node.second)
        open fun transformIntAnswerPair_metas(node: IntAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolAnswerPair
        open fun transformSymbolAnswerPair(node: SymbolAnswerPair): SymbolAnswerPair {
            val new_first = transformSymbolAnswerPair_first(node)
            val new_second = transformSymbolAnswerPair_second(node)
            val new_metas = transformSymbolAnswerPair_metas(node)
            return build {
                SymbolAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolAnswerPair_first(node: SymbolAnswerPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolAnswerPair_second(node: SymbolAnswerPair) =
            transformAnswer(node.second)
        open fun transformSymbolAnswerPair_metas(node: SymbolAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerSymbolPair
        open fun transformAnswerSymbolPair(node: AnswerSymbolPair): AnswerSymbolPair {
            val new_first = transformAnswerSymbolPair_first(node)
            val new_second = transformAnswerSymbolPair_second(node)
            val new_metas = transformAnswerSymbolPair_metas(node)
            return build {
                AnswerSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerSymbolPair_first(node: AnswerSymbolPair) =
            transformAnswer(node.first)
        open fun transformAnswerSymbolPair_second(node: AnswerSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformAnswerSymbolPair_metas(node: AnswerSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin0
        open fun transformVariadicMin0(node: VariadicMin0): VariadicMin0 {
            val new_ints = transformVariadicMin0_ints(node)
            val new_metas = transformVariadicMin0_metas(node)
            return build {
                VariadicMin0(
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformVariadicMin0_ints(node: VariadicMin0) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin0_metas(node: VariadicMin0) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin1
        open fun transformVariadicMin1(node: VariadicMin1): VariadicMin1 {
            val new_ints = transformVariadicMin1_ints(node)
            val new_metas = transformVariadicMin1_metas(node)
            return build {
                VariadicMin1(
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformVariadicMin1_ints(node: VariadicMin1) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin1_metas(node: VariadicMin1) =
            transformMetas(node.metas)
    
        // Tuple ElementVariadic
        open fun transformElementVariadic(node: ElementVariadic): ElementVariadic {
            val new_name = transformElementVariadic_name(node)
            val new_ints = transformElementVariadic_ints(node)
            val new_metas = transformElementVariadic_metas(node)
            return build {
                ElementVariadic(
                    name = new_name,
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformElementVariadic_name(node: ElementVariadic) =
            transformSymbolPrimitive(node.name)
        open fun transformElementVariadic_ints(node: ElementVariadic) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformElementVariadic_metas(node: ElementVariadic) =
            transformMetas(node.metas)
    
        // Tuple Optional1
        open fun transformOptional1(node: Optional1): Optional1 {
            val new_value = transformOptional1_value(node)
            val new_metas = transformOptional1_metas(node)
            return build {
                Optional1(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
        open fun transformOptional1_value(node: Optional1) =
            node.value?.let { transformLongPrimitive(it) }
        open fun transformOptional1_metas(node: Optional1) =
            transformMetas(node.metas)
    
        // Tuple Optional2
        open fun transformOptional2(node: Optional2): Optional2 {
            val new_first = transformOptional2_first(node)
            val new_second = transformOptional2_second(node)
            val new_metas = transformOptional2_metas(node)
            return build {
                Optional2(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformOptional2_first(node: Optional2) =
            node.first?.let { transformLongPrimitive(it) }
        open fun transformOptional2_second(node: Optional2) =
            node.second?.let { transformLongPrimitive(it) }
        open fun transformOptional2_metas(node: Optional2) =
            transformMetas(node.metas)
    
        // Tuple DomainLevelRecord
        open fun transformDomainLevelRecord(node: DomainLevelRecord): DomainLevelRecord {
            val new_someField = transformDomainLevelRecord_someField(node)
            val new_anotherField = transformDomainLevelRecord_anotherField(node)
            val new_optionalField = transformDomainLevelRecord_optionalField(node)
            val new_metas = transformDomainLevelRecord_metas(node)
            return build {
                DomainLevelRecord(
                    someField = new_someField,
                    anotherField = new_anotherField,
                    optionalField = new_optionalField,
                    metas = new_metas
                )
            }
        }
        open fun transformDomainLevelRecord_someField(node: DomainLevelRecord) =
            transformLongPrimitive(node.someField)
        open fun transformDomainLevelRecord_anotherField(node: DomainLevelRecord) =
            transformSymbolPrimitive(node.anotherField)
        open fun transformDomainLevelRecord_optionalField(node: DomainLevelRecord) =
            node.optionalField?.let { transformLongPrimitive(it) }
        open fun transformDomainLevelRecord_metas(node: DomainLevelRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductWithRecord
        open fun transformProductWithRecord(node: ProductWithRecord): ProductWithRecord {
            val new_value = transformProductWithRecord_value(node)
            val new_dlr = transformProductWithRecord_dlr(node)
            val new_metas = transformProductWithRecord_metas(node)
            return build {
                ProductWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            }
        }
        open fun transformProductWithRecord_value(node: ProductWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformProductWithRecord_dlr(node: ProductWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformProductWithRecord_metas(node: ProductWithRecord) =
            transformMetas(node.metas)
    
        // Tuple TestSumTriplet
        open fun transformTestSumTriplet(node: TestSumTriplet): TestSumTriplet {
            val new_a = transformTestSumTriplet_a(node)
            val new_b = transformTestSumTriplet_b(node)
            val new_c = transformTestSumTriplet_c(node)
            val new_metas = transformTestSumTriplet_metas(node)
            return build {
                TestSumTriplet(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            }
        }
        open fun transformTestSumTriplet_a(node: TestSumTriplet) =
            transformTestSum(node.a)
        open fun transformTestSumTriplet_b(node: TestSumTriplet) =
            transformTestSum(node.b)
        open fun transformTestSumTriplet_c(node: TestSumTriplet) =
            transformTestSum(node.c)
        open fun transformTestSumTriplet_metas(node: TestSumTriplet) =
            transformMetas(node.metas)
    
        // Tuple EntityPair
        open fun transformEntityPair(node: EntityPair): EntityPair {
            val new_first = transformEntityPair_first(node)
            val new_second = transformEntityPair_second(node)
            val new_metas = transformEntityPair_metas(node)
            return build {
                EntityPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformEntityPair_first(node: EntityPair) =
            transformEntity(node.first)
        open fun transformEntityPair_second(node: EntityPair) =
            transformEntity(node.second)
        open fun transformEntityPair_metas(node: EntityPair) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun transformAnswer(node: TestDomain.Answer) =
            when(node) {
                is TestDomain.Answer.No -> transformAnswerNo(node)
                is TestDomain.Answer.Yes -> transformAnswerYes(node)
            }
        // Variant AnswerNo
        open fun transformAnswerNo(node: TestDomain.Answer.No): TestDomain.Answer {
            val new_metas = transformAnswerNo_metas(node)
            return build {
                Answer.No(
                    metas = new_metas
                )
            }
        }
    
        open fun transformAnswerNo_metas(node: Answer.No) =
            transformMetas(node.metas)
    
    
        // Variant AnswerYes
        open fun transformAnswerYes(node: TestDomain.Answer.Yes): TestDomain.Answer {
            val new_metas = transformAnswerYes_metas(node)
            return build {
                Answer.Yes(
                    metas = new_metas
                )
            }
        }
    
        open fun transformAnswerYes_metas(node: Answer.Yes) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun transformSumWithRecord(node: TestDomain.SumWithRecord) =
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> transformSumWithRecordVariantWithRecord(node)
            }
        // Variant SumWithRecordVariantWithRecord
        open fun transformSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): TestDomain.SumWithRecord {
            val new_value = transformSumWithRecordVariantWithRecord_value(node)
            val new_dlr = transformSumWithRecordVariantWithRecord_dlr(node)
            val new_metas = transformSumWithRecordVariantWithRecord_metas(node)
            return build {
                SumWithRecord.VariantWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSumWithRecordVariantWithRecord_value(node: SumWithRecord.VariantWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformSumWithRecordVariantWithRecord_dlr(node: SumWithRecord.VariantWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformSumWithRecordVariantWithRecord_metas(node: SumWithRecord.VariantWithRecord) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun transformTestSum(node: TestDomain.TestSum) =
            when(node) {
                is TestDomain.TestSum.One -> transformTestSumOne(node)
                is TestDomain.TestSum.Two -> transformTestSumTwo(node)
                is TestDomain.TestSum.Three -> transformTestSumThree(node)
            }
        // Variant TestSumOne
        open fun transformTestSumOne(node: TestDomain.TestSum.One): TestDomain.TestSum {
            val new_a = transformTestSumOne_a(node)
            val new_metas = transformTestSumOne_metas(node)
            return build {
                TestSum.One(
                    a = new_a,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumOne_a(node: TestSum.One) =
            transformLongPrimitive(node.a)
        open fun transformTestSumOne_metas(node: TestSum.One) =
            transformMetas(node.metas)
    
    
        // Variant TestSumTwo
        open fun transformTestSumTwo(node: TestDomain.TestSum.Two): TestDomain.TestSum {
            val new_a = transformTestSumTwo_a(node)
            val new_b = transformTestSumTwo_b(node)
            val new_metas = transformTestSumTwo_metas(node)
            return build {
                TestSum.Two(
                    a = new_a,
                    b = new_b,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumTwo_a(node: TestSum.Two) =
            transformLongPrimitive(node.a)
        open fun transformTestSumTwo_b(node: TestSum.Two) =
            transformLongPrimitive(node.b)
        open fun transformTestSumTwo_metas(node: TestSum.Two) =
            transformMetas(node.metas)
    
    
        // Variant TestSumThree
        open fun transformTestSumThree(node: TestDomain.TestSum.Three): TestDomain.TestSum {
            val new_a = transformTestSumThree_a(node)
            val new_b = transformTestSumThree_b(node)
            val new_c = transformTestSumThree_c(node)
            val new_metas = transformTestSumThree_metas(node)
            return build {
                TestSum.Three(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumThree_a(node: TestSum.Three) =
            transformLongPrimitive(node.a)
        open fun transformTestSumThree_b(node: TestSum.Three) =
            transformLongPrimitive(node.b)
        open fun transformTestSumThree_c(node: TestSum.Three) =
            transformLongPrimitive(node.c)
        open fun transformTestSumThree_metas(node: TestSum.Three) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun transformEntity(node: TestDomain.Entity) =
            when(node) {
                is TestDomain.Entity.Slug -> transformEntitySlug(node)
                is TestDomain.Entity.Android -> transformEntityAndroid(node)
                is TestDomain.Entity.Human -> transformEntityHuman(node)
            }
        // Variant EntitySlug
        open fun transformEntitySlug(node: TestDomain.Entity.Slug): TestDomain.Entity {
            val new_metas = transformEntitySlug_metas(node)
            return build {
                Entity.Slug(
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntitySlug_metas(node: Entity.Slug) =
            transformMetas(node.metas)
    
    
        // Variant EntityAndroid
        open fun transformEntityAndroid(node: TestDomain.Entity.Android): TestDomain.Entity {
            val new_id = transformEntityAndroid_id(node)
            val new_metas = transformEntityAndroid_metas(node)
            return build {
                Entity.Android(
                    id = new_id,
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntityAndroid_id(node: Entity.Android) =
            transformLongPrimitive(node.id)
        open fun transformEntityAndroid_metas(node: Entity.Android) =
            transformMetas(node.metas)
    
    
        // Variant EntityHuman
        open fun transformEntityHuman(node: TestDomain.Entity.Human): TestDomain.Entity {
            val new_firstName = transformEntityHuman_firstName(node)
            val new_lastName = transformEntityHuman_lastName(node)
            val new_title = transformEntityHuman_title(node)
            val new_parent = transformEntityHuman_parent(node)
            val new_metas = transformEntityHuman_metas(node)
            return build {
                Entity.Human(
                    firstName = new_firstName,
                    lastName = new_lastName,
                    title = new_title,
                    parent = new_parent,
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntityHuman_firstName(node: Entity.Human) =
            transformSymbolPrimitive(node.firstName)
        open fun transformEntityHuman_lastName(node: Entity.Human) =
            transformSymbolPrimitive(node.lastName)
        open fun transformEntityHuman_title(node: Entity.Human) =
            node.title?.let { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_parent(node: Entity.Human) =
            node.parent?.let { transformEntity(it) }
        open fun transformEntityHuman_metas(node: Entity.Human) =
            transformMetas(node.metas)
    
    
    }
}

class MultiWordDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: MultiWordDomainNode> build(block: Builder.() -> T) =
            Builder.block()
    
        fun transform(element: AnyElement): MultiWordDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): MultiWordDomainNode =
            Transformer().transform(element)
    }
    
    object Builder {
                // Tuples
        /**
         * Creates an instance of [MultiWordDomain.AaaAaa].
         */
        fun aaaAaa(
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAaa =
            MultiWordDomain.AaaAaa(
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         */
        fun aaaAab(
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAab_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         */
        fun aaaAac(
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAac_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField,
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField,
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         */
        fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAaa_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField,
                cField = cField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         */
        fun aabAab(
            bField: Long,
            cField: String,
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAab_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         */
        fun aabAac(
            bField: Long,
            cField: String,
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAac_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         */
        fun rrr(
            aField: Long,
            bbbField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField.asPrimitive(),
                bbbField = bbbField.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun rrr_(
            aField: org.partiql.pig.runtime.LongPrimitive,
            bbbField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas)
        
        
        // Variants for Sum: SssTtt 
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         */
        fun lll(
            uField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun lll_(
            uField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField,
                metas = metas)
        
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         */
        fun mmm(
            vField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun mmm_(
            vField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField,
                metas = metas)
    }
    
    /** Base class for all MultiWordDomain types. */
    abstract class MultiWordDomainNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): MultiWordDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class AaaAaa(
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAaa =
            AaaAaa(
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aaa"),
                metas = metas)
            return elements
        }
    
        fun copy(
            metas: MetaContainer = this.metas) =
            AaaAaa(
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAaa::class.java) return false
    
            return true
        }
    
        override fun hashCode(): Int = 0
    }
    
    class AaaAab(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aab"),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas) =
            AaaAab(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAab::class.java) return false
    
            other as AaaAab
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAac(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aac"),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas) =
            AaaAac(
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAac::class.java) return false
    
            other as AaaAac
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAad(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aad"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas) =
            AaaAad(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAad::class.java) return false
    
            other as AaaAad
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAae(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aae"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas) =
            AaaAae(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAae::class.java) return false
    
            other as AaaAae
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAaa(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aaa"),
                bField.toIonElement(),
                cField.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            metas: MetaContainer = this.metas) =
            AabAaa(
                bField,
                cField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAaa::class.java) return false
    
            other as AabAaa
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAab(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aab"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas) =
            AabAab(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAab::class.java) return false
    
            other as AabAab
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAac(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aac"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas) =
            AabAac(
                bField,
                cField,
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAac::class.java) return false
    
            other as AabAac
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAad(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aad"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas) =
            AabAad(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAad::class.java) return false
    
            other as AabAad
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAae(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aae"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas) =
            AabAae(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAae::class.java) return false
    
            other as AabAae
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Rrr(
        val aField: org.partiql.pig.runtime.LongPrimitive,
        val bbbField: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("rrr"),
                aField?.let { ionSexpOf(ionSymbol("a_field"), it.toIonElement()) },
                bbbField?.let { ionSexpOf(ionSymbol("b_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            aField: org.partiql.pig.runtime.LongPrimitive = this.aField,
            bbbField: org.partiql.pig.runtime.LongPrimitive = this.bbbField,
            metas: MetaContainer = this.metas) =
            Rrr(
                aField,
                bbbField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Rrr::class.java) return false
    
            other as Rrr
            if (aField != other.aField) return false
            if (bbbField != other.bbbField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = aField.hashCode()
            hc = 31 * hc + bbbField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SssTtt : MultiWordDomainNode() {
    
        class Lll(
            val uField: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lll =
                Lll(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lll"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                uField: org.partiql.pig.runtime.LongPrimitive = this.uField,
                metas: MetaContainer = this.metas) =
                Lll(
                    uField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lll::class.java) return false
        
                other as Lll
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Mmm(
            val vField: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("mmm"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                vField: org.partiql.pig.runtime.SymbolPrimitive = this.vField,
                metas: MetaContainer = this.metas) =
                Mmm(
                    vField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Mmm::class.java) return false
        
                other as Mmm
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<MultiWordDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): MultiWordDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "aaa_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    MultiWordDomain.AaaAaa(
                        metas = sexp.metas)
                }
                "aaa_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    MultiWordDomain.AaaAab(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    val eField = sexp.getOptional(1)?.toSymbolPrimitive()
                    MultiWordDomain.AaaAac(
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aaa_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAad(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAae(
                        dField,
                        metas = sexp.metas)
                }
                "aab_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    MultiWordDomain.AabAaa(
                        bField,
                        cField,
                        metas = sexp.metas)
                }
                "aab_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    MultiWordDomain.AabAab(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    val eField = sexp.getOptional(3)?.toSymbolPrimitive()
                    MultiWordDomain.AabAac(
                        bField,
                        cField,
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aab_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAad(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAae(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "rrr" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val aField = ir.processRequiredField("a_field") { it.toLongPrimitive() }
                    val bbbField = ir.processRequiredField("bbb_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Rrr(aField, bbbField, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtt'
                //////////////////////////////////////
                "lll" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).toLongPrimitive()
                    MultiWordDomain.SssTtt.Lll(
                        uField,
                        metas = sexp.metas)
                }
                "mmm" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).toSymbolPrimitive()
                    MultiWordDomain.SssTtt.Mmm(
                        vField,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'multi_word_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitAaaAaa(node: MultiWordDomain.AaaAaa) { }
        open fun visitAaaAab(node: MultiWordDomain.AaaAab) { }
        open fun visitAaaAac(node: MultiWordDomain.AaaAac) { }
        open fun visitAaaAad(node: MultiWordDomain.AaaAad) { }
        open fun visitAaaAae(node: MultiWordDomain.AaaAae) { }
        open fun visitAabAaa(node: MultiWordDomain.AabAaa) { }
        open fun visitAabAab(node: MultiWordDomain.AabAab) { }
        open fun visitAabAac(node: MultiWordDomain.AabAac) { }
        open fun visitAabAad(node: MultiWordDomain.AabAad) { }
        open fun visitAabAae(node: MultiWordDomain.AabAae) { }
        open fun visitRrr(node: MultiWordDomain.Rrr) { }
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        protected open fun visitSssTtt(node: MultiWordDomain.SssTtt) { }
        protected open fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll) { }
        protected open fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa) {
            visitAaaAaa(node)
            walkMetas(node.metas)
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab) {
            visitAaaAab(node)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac) {
            visitAaaAac(node)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad) {
            visitAaaAad(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae) {
            visitAaaAae(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa) {
            visitAabAaa(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            walkMetas(node.metas)
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab) {
            visitAabAab(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac) {
            visitAabAac(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad) {
            visitAabAad(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae) {
            visitAabAae(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr) {
            visitRrr(node)
            walkLongPrimitive(node.aField)
            walkLongPrimitive(node.bbbField)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt) {
            visitSssTtt(node)
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll) {
            visitSssTttLll(node)
            walkLongPrimitive(node.uField)
            walkMetas(node.metas)
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) {
            visitSssTttMmm(node)
            walkSymbolPrimitive(node.vField)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T = accumulator
        open protected fun visitAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T = accumulator
        open protected fun visitAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T = accumulator
        open protected fun visitAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T = accumulator
        open protected fun visitAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T = accumulator
        open protected fun visitAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T = accumulator
        open protected fun visitAabAab(node: MultiWordDomain.AabAab, accumulator: T): T = accumulator
        open protected fun visitAabAac(node: MultiWordDomain.AabAac, accumulator: T): T = accumulator
        open protected fun visitAabAad(node: MultiWordDomain.AabAad, accumulator: T): T = accumulator
        open protected fun visitAabAae(node: MultiWordDomain.AabAae, accumulator: T): T = accumulator
        open protected fun visitRrr(node: MultiWordDomain.Rrr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open protected fun visitSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T = accumulator
        open protected fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T = accumulator
        open protected fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T {
            var current = accumulator
            current = visitAaaAaa(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T {
            var current = accumulator
            current = visitAaaAab(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T {
            var current = accumulator
            current = visitAaaAac(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T {
            var current = accumulator
            current = visitAaaAad(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T {
            var current = accumulator
            current = visitAaaAae(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T {
            var current = accumulator
            current = visitAabAaa(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab, accumulator: T): T {
            var current = accumulator
            current = visitAabAab(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac, accumulator: T): T {
            var current = accumulator
            current = visitAabAac(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad, accumulator: T): T {
            var current = accumulator
            current = visitAabAad(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae, accumulator: T): T {
            var current = accumulator
            current = visitAabAae(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr, accumulator: T): T {
            var current = accumulator
            current = visitRrr(node, current)
            current = walkLongPrimitive(node.aField, current)
            current = walkLongPrimitive(node.bbbField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T {
            val current = visitSssTtt(node, accumulator)
            return when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node, current)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node, current)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T {
            var current = accumulator
            current = visitSssTttLll(node, current)
            current = walkLongPrimitive(node.uField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T {
            var current = accumulator
            current = visitSssTttMmm(node, current)
            current = walkSymbolPrimitive(node.vField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple AaaAaa
        open fun transformAaaAaa(node: AaaAaa): AaaAaa {
            val new_metas = transformAaaAaa_metas(node)
            return build {
                AaaAaa(
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAaa_metas(node: AaaAaa) =
            transformMetas(node.metas)
    
        // Tuple AaaAab
        open fun transformAaaAab(node: AaaAab): AaaAab {
            val new_dField = transformAaaAab_dField(node)
            val new_metas = transformAaaAab_metas(node)
            return build {
                AaaAab(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAab_dField(node: AaaAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAab_metas(node: AaaAab) =
            transformMetas(node.metas)
    
        // Tuple AaaAac
        open fun transformAaaAac(node: AaaAac): AaaAac {
            val new_dField = transformAaaAac_dField(node)
            val new_eField = transformAaaAac_eField(node)
            val new_metas = transformAaaAac_metas(node)
            return build {
                AaaAac(
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAac_dField(node: AaaAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAac_eField(node: AaaAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAaaAac_metas(node: AaaAac) =
            transformMetas(node.metas)
    
        // Tuple AaaAad
        open fun transformAaaAad(node: AaaAad): AaaAad {
            val new_dField = transformAaaAad_dField(node)
            val new_metas = transformAaaAad_metas(node)
            return build {
                AaaAad(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAad_dField(node: AaaAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAad_metas(node: AaaAad) =
            transformMetas(node.metas)
    
        // Tuple AaaAae
        open fun transformAaaAae(node: AaaAae): AaaAae {
            val new_dField = transformAaaAae_dField(node)
            val new_metas = transformAaaAae_metas(node)
            return build {
                AaaAae(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAae_dField(node: AaaAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAae_metas(node: AaaAae) =
            transformMetas(node.metas)
    
        // Tuple AabAaa
        open fun transformAabAaa(node: AabAaa): AabAaa {
            val new_bField = transformAabAaa_bField(node)
            val new_cField = transformAabAaa_cField(node)
            val new_metas = transformAabAaa_metas(node)
            return build {
                AabAaa(
                    bField = new_bField,
                    cField = new_cField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAaa_bField(node: AabAaa) =
            transformLongPrimitive(node.bField)
        open fun transformAabAaa_cField(node: AabAaa) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAaa_metas(node: AabAaa) =
            transformMetas(node.metas)
    
        // Tuple AabAab
        open fun transformAabAab(node: AabAab): AabAab {
            val new_bField = transformAabAab_bField(node)
            val new_cField = transformAabAab_cField(node)
            val new_dField = transformAabAab_dField(node)
            val new_metas = transformAabAab_metas(node)
            return build {
                AabAab(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAab_bField(node: AabAab) =
            transformLongPrimitive(node.bField)
        open fun transformAabAab_cField(node: AabAab) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAab_dField(node: AabAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAab_metas(node: AabAab) =
            transformMetas(node.metas)
    
        // Tuple AabAac
        open fun transformAabAac(node: AabAac): AabAac {
            val new_bField = transformAabAac_bField(node)
            val new_cField = transformAabAac_cField(node)
            val new_dField = transformAabAac_dField(node)
            val new_eField = transformAabAac_eField(node)
            val new_metas = transformAabAac_metas(node)
            return build {
                AabAac(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAac_bField(node: AabAac) =
            transformLongPrimitive(node.bField)
        open fun transformAabAac_cField(node: AabAac) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAac_dField(node: AabAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAac_eField(node: AabAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAabAac_metas(node: AabAac) =
            transformMetas(node.metas)
    
        // Tuple AabAad
        open fun transformAabAad(node: AabAad): AabAad {
            val new_bField = transformAabAad_bField(node)
            val new_cField = transformAabAad_cField(node)
            val new_dField = transformAabAad_dField(node)
            val new_metas = transformAabAad_metas(node)
            return build {
                AabAad(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAad_bField(node: AabAad) =
            transformLongPrimitive(node.bField)
        open fun transformAabAad_cField(node: AabAad) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAad_dField(node: AabAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAad_metas(node: AabAad) =
            transformMetas(node.metas)
    
        // Tuple AabAae
        open fun transformAabAae(node: AabAae): AabAae {
            val new_bField = transformAabAae_bField(node)
            val new_cField = transformAabAae_cField(node)
            val new_dField = transformAabAae_dField(node)
            val new_metas = transformAabAae_metas(node)
            return build {
                AabAae(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAae_bField(node: AabAae) =
            transformLongPrimitive(node.bField)
        open fun transformAabAae_cField(node: AabAae) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAae_dField(node: AabAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAae_metas(node: AabAae) =
            transformMetas(node.metas)
    
        // Tuple Rrr
        open fun transformRrr(node: Rrr): Rrr {
            val new_aField = transformRrr_aField(node)
            val new_bbbField = transformRrr_bbbField(node)
            val new_metas = transformRrr_metas(node)
            return build {
                Rrr(
                    aField = new_aField,
                    bbbField = new_bbbField,
                    metas = new_metas
                )
            }
        }
        open fun transformRrr_aField(node: Rrr) =
            transformLongPrimitive(node.aField)
        open fun transformRrr_bbbField(node: Rrr) =
            transformLongPrimitive(node.bbbField)
        open fun transformRrr_metas(node: Rrr) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun transformSssTtt(node: MultiWordDomain.SssTtt) =
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> transformSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> transformSssTttMmm(node)
            }
        // Variant SssTttLll
        open fun transformSssTttLll(node: MultiWordDomain.SssTtt.Lll): MultiWordDomain.SssTtt {
            val new_uField = transformSssTttLll_uField(node)
            val new_metas = transformSssTttLll_metas(node)
            return build {
                SssTtt.Lll(
                    uField = new_uField,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSssTttLll_uField(node: SssTtt.Lll) =
            transformLongPrimitive(node.uField)
        open fun transformSssTttLll_metas(node: SssTtt.Lll) =
            transformMetas(node.metas)
    
    
        // Variant SssTttMmm
        open fun transformSssTttMmm(node: MultiWordDomain.SssTtt.Mmm): MultiWordDomain.SssTtt {
            val new_vField = transformSssTttMmm_vField(node)
            val new_metas = transformSssTttMmm_metas(node)
            return build {
                SssTtt.Mmm(
                    vField = new_vField,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSssTttMmm_vField(node: SssTtt.Mmm) =
            transformSymbolPrimitive(node.vField)
        open fun transformSssTttMmm_metas(node: SssTtt.Mmm) =
            transformMetas(node.metas)
    
    
    }
}

class PartiqlBasic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: PartiqlBasicNode> build(block: Builder.() -> T) =
            Builder.block()
    
        fun transform(element: AnyElement): PartiqlBasicNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): PartiqlBasicNode =
            Transformer().transform(element)
    }
    
    object Builder {
                // Tuples
        /**
         * Creates an instance of [PartiqlBasic.ExprPair].
         */
        fun exprPair(
            first: Expr,
            second: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ExprPair =
            PartiqlBasic.ExprPair(
                first = first,
                second = second,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByItem].
         */
        fun groupByItem(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByItem].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupByItem_(
            value: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByList].
         */
        fun groupByList(
            items: kotlin.collections.List<GroupByItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = items,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByList].
         */
        fun groupByList(
            items0: GroupByItem,
            vararg items: GroupByItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupBy].
         */
        fun groupBy(
            items: GroupByList,
            groupAsAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.GroupBy].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupBy_(
            items: GroupByList,
            groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas)
        
        
        // Variants for Sum: Projection 
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectList].
         */
        fun projectList(
            items: kotlin.collections.List<ProjectItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = items,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectList].
         */
        fun projectList(
            items0: ProjectItem,
            vararg items: ProjectItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = listOf(items0) + items.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectValue].
         */
        fun projectValue(
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectValue =
            PartiqlBasic.Projection.ProjectValue(
                value = value,
                metas = metas)
        
        
        // Variants for Sum: ProjectItem 
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectAll].
         */
        fun projectAll(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectAll =
            PartiqlBasic.ProjectItem.ProjectAll(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectExpr].
         */
        fun projectExpr(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectExpr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun projectExpr_(
            value: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias,
                metas = metas)
        
        
        // Variants for Sum: JoinType 
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Inner].
         */
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Inner =
            PartiqlBasic.JoinType.Inner(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Left].
         */
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Left =
            PartiqlBasic.JoinType.Left(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Right].
         */
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Right =
            PartiqlBasic.JoinType.Right(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Outer].
         */
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Outer =
            PartiqlBasic.JoinType.Outer(
                metas = metas)
        
        
        // Variants for Sum: FromSource 
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Scan].
         */
        fun scan(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Scan].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun scan_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            atAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            byAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Join].
         */
        fun join(
            type: JoinType,
            left: FromSource,
            right: FromSource,
            predicate: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Join =
            PartiqlBasic.FromSource.Join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = metas)
        
        
        // Variants for Sum: CaseSensitivity 
        /**
         * Creates an instance of [PartiqlBasic.CaseSensitivity.CaseSensitive].
         */
        fun caseSensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseSensitive =
            PartiqlBasic.CaseSensitivity.CaseSensitive(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.CaseSensitivity.CaseInsensitive].
         */
        fun caseInsensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseInsensitive =
            PartiqlBasic.CaseSensitivity.CaseInsensitive(
                metas = metas)
        
        
        // Variants for Sum: ScopeQualifier 
        /**
         * Creates an instance of [PartiqlBasic.ScopeQualifier.Unqualified].
         */
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Unqualified =
            PartiqlBasic.ScopeQualifier.Unqualified(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.ScopeQualifier.Qualified].
         */
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Qualified =
            PartiqlBasic.ScopeQualifier.Qualified(
                metas = metas)
        
        
        // Variants for Sum: SetQuantifier 
        /**
         * Creates an instance of [PartiqlBasic.SetQuantifier.All].
         */
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.All =
            PartiqlBasic.SetQuantifier.All(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.SetQuantifier.Distinct].
         */
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.Distinct =
            PartiqlBasic.SetQuantifier.Distinct(
                metas = metas)
        
        
        // Variants for Sum: PathElement 
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathExpr].
         */
        fun pathExpr(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathExpr =
            PartiqlBasic.PathElement.PathExpr(
                expr = expr,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathWildcard].
         */
        fun pathWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathWildcard =
            PartiqlBasic.PathElement.PathWildcard(
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathUnpivot].
         */
        fun pathUnpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathUnpivot =
            PartiqlBasic.PathElement.PathUnpivot(
                metas = metas)
        
        
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [PartiqlBasic.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Lit =
            PartiqlBasic.Expr.Lit(
                value = value.asAnyElement(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Id].
         */
        fun id(
            name: String,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name.asPrimitive(),
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Id].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun id_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name,
                case = case,
                scopeQualifier = scopeQualifier,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Parameter].
         */
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index.asPrimitive(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Parameter].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun parameter_(
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Not =
            PartiqlBasic.Expr.Not(
                expr = expr,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Concat].
         */
        fun concat(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = operands,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Concat].
         */
        fun concat(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Like].
         */
        fun like(
            left: Expr,
            right: Expr,
            escape: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Like =
            PartiqlBasic.Expr.Like(
                left = left,
                right = right,
                escape = escape,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Between].
         */
        fun between(
            value: Expr,
            from: Expr,
            to: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Between =
            PartiqlBasic.Expr.Between(
                value = value,
                from = from,
                to = to,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Path].
         */
        fun path(
            root: Expr,
            elements: kotlin.collections.List<PathElement>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = elements,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Path].
         */
        fun path(
            root: Expr,
            elements0: PathElement,
            vararg elements: PathElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = listOf(elements0) + elements.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         */
        fun call(
            name: String,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = args,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = args,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         */
        fun call(
            name: String,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = listOf(args0) + args.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.CallAgg].
         */
        fun callAgg(
            name: String,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name.asPrimitive(),
                setQuantifier = setQuantifier,
                arg = arg,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.CallAgg].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun callAgg_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name,
                setQuantifier = setQuantifier,
                arg = arg,
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SimpleCase].
         */
        fun simpleCase(
            value: Expr,
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = branches,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SimpleCase].
         */
        fun simpleCase(
            value: Expr,
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SearchedCase].
         */
        fun searchedCase(
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = branches,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SearchedCase].
         */
        fun searchedCase(
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = listOf(branches0) + branches.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Struct].
         */
        fun struct(
            fields: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Struct].
         */
        fun struct(
            vararg fields: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Bag].
         */
        fun bag(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Bag].
         */
        fun bag(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.List].
         */
        fun list(
            values: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values,
                metas = metas)
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.List].
         */
        fun list(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values.toList(),
                metas = metas)
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Select].
         */
        fun select(
            setq: SetQuantifier? = null,
            project: Projection,
            from: FromSource,
            where: Expr? = null,
            group: GroupBy? = null,
            having: Expr? = null,
            limit: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Select =
            PartiqlBasic.Expr.Select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = metas)
    }
    
    /** Base class for all PartiqlBasic types. */
    abstract class PartiqlBasicNode : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): PartiqlBasicNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ExprPair(
        val first: Expr,
        val second: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {

        override fun withMeta(metaKey: String, metaValue: Any): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Expr = this.first,
            second: Expr = this.second,
            metas: MetaContainer = this.metas) =
            ExprPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPair::class.java) return false
    
            other as ExprPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByItem(
        val value: Expr,
        val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByItem =
            GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                value.toIonElement(),
                asAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: Expr = this.value,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
            metas: MetaContainer = this.metas) =
            GroupByItem(
                value,
                asAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByItem::class.java) return false
    
            other as GroupByItem
            if (value != other.value) return false
            if (asAlias != other.asAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + asAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByList(
        val items: kotlin.collections.List<GroupByItem>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByList =
            GroupByList(
                items = items,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *items.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            items: kotlin.collections.List<GroupByItem> = this.items,
            metas: MetaContainer = this.metas) =
            GroupByList(
                items,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByList::class.java) return false
    
            other as GroupByList
            if (items != other.items) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupBy(
        val items: GroupByList,
        val groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupBy =
            GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                items.toIonElement(),
                groupAsAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            items: GroupByList = this.items,
            groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.groupAsAlias,
            metas: MetaContainer = this.metas) =
            GroupBy(
                items,
                groupAsAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupBy::class.java) return false
    
            other as GroupBy
            if (items != other.items) return false
            if (groupAsAlias != other.groupAsAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = items.hashCode()
            hc = 31 * hc + groupAsAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Projection : PartiqlBasicNode() {
    
        class ProjectList(
            val items: kotlin.collections.List<ProjectItem>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectList =
                ProjectList(
                    items = items,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *items.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                items: kotlin.collections.List<ProjectItem> = this.items,
                metas: MetaContainer = this.metas) =
                ProjectList(
                    items,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectList::class.java) return false
        
                other as ProjectList
                if (items != other.items) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = items.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectValue(
            val value: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                metas: MetaContainer = this.metas) =
                ProjectValue(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectValue::class.java) return false
        
                other as ProjectValue
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class ProjectItem : PartiqlBasicNode() {
    
        class ProjectAll(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectAll =
                ProjectAll(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                ProjectAll(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectAll::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class ProjectExpr(
            val value: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectExpr =
                ProjectExpr(
                    value = value,
                    asAlias = asAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    value.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
                metas: MetaContainer = this.metas) =
                ProjectExpr(
                    value,
                    asAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectExpr::class.java) return false
        
                other as ProjectExpr
                if (value != other.value) return false
                if (asAlias != other.asAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class JoinType : PartiqlBasicNode() {
    
        class Inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Inner =
                Inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Inner(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Left =
                Left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Left(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class Right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Right =
                Right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Right(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class Outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Outer =
                Outer(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Outer(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
    }
    
    sealed class FromSource : PartiqlBasicNode() {
    
        class Scan(
            val expr: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val atAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val byAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
                atAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.atAlias,
                byAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.byAlias,
                metas: MetaContainer = this.metas) =
                Scan(
                    expr,
                    asAlias,
                    atAlias,
                    byAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Scan::class.java) return false
        
                other as Scan
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Join(
            val type: JoinType,
            val left: FromSource,
            val right: FromSource,
            val predicate: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                type: JoinType = this.type,
                left: FromSource = this.left,
                right: FromSource = this.right,
                predicate: Expr? = this.predicate,
                metas: MetaContainer = this.metas) =
                Join(
                    type,
                    left,
                    right,
                    predicate,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Join::class.java) return false
        
                other as Join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class CaseSensitivity : PartiqlBasicNode() {
    
        class CaseSensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseSensitive =
                CaseSensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                CaseSensitive(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseSensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class CaseInsensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseInsensitive =
                CaseInsensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                CaseInsensitive(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseInsensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class ScopeQualifier : PartiqlBasicNode() {
    
        class Unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Unqualified =
                Unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Unqualified(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class Qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Qualified =
                Qualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Qualified(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
    }
    
    sealed class SetQuantifier : PartiqlBasicNode() {
    
        class All(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): All =
                All(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                All(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != All::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class Distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Distinct =
                Distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                Distinct(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
    }
    
    sealed class PathElement : PartiqlBasicNode() {
    
        class PathExpr(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathExpr =
                PathExpr(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas) =
                PathExpr(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathExpr::class.java) return false
        
                other as PathExpr
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class PathWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathWildcard =
                PathWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                PathWildcard(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class PathUnpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun withMeta(metaKey: String, metaValue: Any): PathUnpivot =
                PathUnpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas) =
                PathUnpivot(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathUnpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
    }
    
    sealed class Expr : PartiqlBasicNode() {

        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Id(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val case: CaseSensitivity,
            val scopeQualifier: ScopeQualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Id =
                Id(
                    name = name,
                    case = case,
                    scopeQualifier = scopeQualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    scopeQualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                case: CaseSensitivity = this.case,
                scopeQualifier: ScopeQualifier = this.scopeQualifier,
                metas: MetaContainer = this.metas) =
                Id(
                    name,
                    case,
                    scopeQualifier,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Id::class.java) return false
        
                other as Id
                if (name != other.name) return false
                if (case != other.case) return false
                if (scopeQualifier != other.scopeQualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + scopeQualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Parameter(
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Parameter =
                Parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                metas: MetaContainer = this.metas) =
                Parameter(
                    index,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Parameter::class.java) return false
        
                other as Parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Concat(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Concat =
                Concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas) =
                Concat(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Concat::class.java) return false
        
                other as Concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Like(
            val left: Expr,
            val right: Expr,
            val escape: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Like =
                Like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    left.toIonElement(),
                    right.toIonElement(),
                    escape.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                left: Expr = this.left,
                right: Expr = this.right,
                escape: Expr = this.escape,
                metas: MetaContainer = this.metas) =
                Like(
                    left,
                    right,
                    escape,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Like::class.java) return false
        
                other as Like
                if (left != other.left) return false
                if (right != other.right) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Between(
            val value: Expr,
            val from: Expr,
            val to: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                from: Expr = this.from,
                to: Expr = this.to,
                metas: MetaContainer = this.metas) =
                Between(
                    value,
                    from,
                    to,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Between::class.java) return false
        
                other as Between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Path(
            val root: Expr,
            val elements: kotlin.collections.List<PathElement>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Path =
                Path(
                    root = root,
                    elements = elements,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *elements.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                root: Expr = this.root,
                elements: kotlin.collections.List<PathElement> = this.elements,
                metas: MetaContainer = this.metas) =
                Path(
                    root,
                    elements,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Path::class.java) return false
        
                other as Path
                if (root != other.root) return false
                if (elements != other.elements) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = root.hashCode()
                hc = 31 * hc + elements.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                args: kotlin.collections.List<Expr> = this.args,
                metas: MetaContainer = this.metas) =
                Call(
                    name,
                    args,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CallAgg(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val setQuantifier: SetQuantifier,
            val arg: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): CallAgg =
                CallAgg(
                    name = name,
                    setQuantifier = setQuantifier,
                    arg = arg,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    name.toIonElement(),
                    setQuantifier.toIonElement(),
                    arg.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                setQuantifier: SetQuantifier = this.setQuantifier,
                arg: Expr = this.arg,
                metas: MetaContainer = this.metas) =
                CallAgg(
                    name,
                    setQuantifier,
                    arg,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CallAgg::class.java) return false
        
                other as CallAgg
                if (name != other.name) return false
                if (setQuantifier != other.setQuantifier) return false
                if (arg != other.arg) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = name.hashCode()
                hc = 31 * hc + setQuantifier.hashCode()
                hc = 31 * hc + arg.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SimpleCase(
            val value: Expr,
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SimpleCase =
                SimpleCase(
                    value = value,
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    value.toIonElement(),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                branches: kotlin.collections.List<ExprPair> = this.branches,
                metas: MetaContainer = this.metas) =
                SimpleCase(
                    value,
                    branches,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SimpleCase::class.java) return false
        
                other as SimpleCase
                if (value != other.value) return false
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SearchedCase(
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): SearchedCase =
                SearchedCase(
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                branches: kotlin.collections.List<ExprPair> = this.branches,
                metas: MetaContainer = this.metas) =
                SearchedCase(
                    branches,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SearchedCase::class.java) return false
        
                other as SearchedCase
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Struct(
            val fields: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Struct =
                Struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                fields: kotlin.collections.List<ExprPair> = this.fields,
                metas: MetaContainer = this.metas) =
                Struct(
                    fields,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Struct::class.java) return false
        
                other as Struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Bag(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Bag =
                Bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas) =
                Bag(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Bag::class.java) return false
        
                other as Bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class List(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): List =
                List(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas) =
                List(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != List::class.java) return false
        
                other as List
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Select(
            val setq: SetQuantifier?,
            val project: Projection,
            val from: FromSource,
            val where: Expr?,
            val group: GroupBy?,
            val having: Expr?,
            val limit: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun withMeta(metaKey: String, metaValue: Any): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                setq: SetQuantifier? = this.setq,
                project: Projection = this.project,
                from: FromSource = this.from,
                where: Expr? = this.where,
                group: GroupBy? = this.group,
                having: Expr? = this.having,
                limit: Expr? = this.limit,
                metas: MetaContainer = this.metas) =
                Select(
                    setq,
                    project,
                    from,
                    where,
                    group,
                    having,
                    limit,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Select::class.java) return false
        
                other as Select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<PartiqlBasicNode>() {
    
        override fun innerTransform(sexp: SexpElement): PartiqlBasicNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Expr>()
                    val second = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlBasic.ExprPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupByItem(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<GroupByItem>() }
                    PartiqlBasic.GroupByList(
                        items,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val items = sexp.getRequired(0).transformExpect<GroupByList>()
                    val groupAsAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupBy(
                        items,
                        groupAsAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<ProjectItem>() }
                    PartiqlBasic.Projection.ProjectList(
                        items,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Projection.ProjectValue(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ProjectItem'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ProjectItem.ProjectAll(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.ProjectItem.ProjectExpr(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'JoinType'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'FromSource'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlBasic.FromSource.Scan(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<JoinType>()
                    val left = sexp.getRequired(1).transformExpect<FromSource>()
                    val right = sexp.getRequired(2).transformExpect<FromSource>()
                    val predicate = sexp.getOptional(3)?.transformExpect<Expr>()
                    PartiqlBasic.FromSource.Join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'CaseSensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseSensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseInsensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ScopeQualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SetQuantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.All(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.Distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'PathElement'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.PathElement.PathExpr(
                        expr,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathWildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathUnpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    PartiqlBasic.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    val scopeQualifier = sexp.getRequired(2).transformExpect<ScopeQualifier>()
                    PartiqlBasic.Expr.Id(
                        name,
                        case,
                        scopeQualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    PartiqlBasic.Expr.Parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Concat(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val left = sexp.getRequired(0).transformExpect<Expr>()
                    val right = sexp.getRequired(1).transformExpect<Expr>()
                    val escape = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Like(
                        left,
                        right,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val from = sexp.getRequired(1).transformExpect<Expr>()
                    val to = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<Expr>()
                    val elements = sexp.values.drop(2).map { it.transformExpect<PathElement>() }
                    PartiqlBasic.Expr.Path(
                        root,
                        elements,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Call(
                        name,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val setQuantifier = sexp.getRequired(1).transformExpect<SetQuantifier>()
                    val arg = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.CallAgg(
                        name,
                        setQuantifier,
                        arg,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val branches = sexp.values.drop(2).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SimpleCase(
                        value,
                        branches,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val branches = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SearchedCase(
                        branches,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.Struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.List(
                        values,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<SetQuantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<Projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<FromSource>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<GroupBy>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<Expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<Expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Expr.Select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitExprPair(node: PartiqlBasic.ExprPair) { }
        open fun visitGroupByItem(node: PartiqlBasic.GroupByItem) { }
        open fun visitGroupByList(node: PartiqlBasic.GroupByList) { }
        open fun visitGroupBy(node: PartiqlBasic.GroupBy) { }
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        protected open fun visitProjection(node: PartiqlBasic.Projection) { }
        protected open fun visitProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) { }
        protected open fun visitProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) { }
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        protected open fun visitProjectItem(node: PartiqlBasic.ProjectItem) { }
        protected open fun visitProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) { }
        protected open fun visitProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) { }
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        protected open fun visitJoinType(node: PartiqlBasic.JoinType) { }
        protected open fun visitJoinTypeInner(node: PartiqlBasic.JoinType.Inner) { }
        protected open fun visitJoinTypeLeft(node: PartiqlBasic.JoinType.Left) { }
        protected open fun visitJoinTypeRight(node: PartiqlBasic.JoinType.Right) { }
        protected open fun visitJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) { }
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        protected open fun visitFromSource(node: PartiqlBasic.FromSource) { }
        protected open fun visitFromSourceScan(node: PartiqlBasic.FromSource.Scan) { }
        protected open fun visitFromSourceJoin(node: PartiqlBasic.FromSource.Join) { }
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        protected open fun visitCaseSensitivity(node: PartiqlBasic.CaseSensitivity) { }
        protected open fun visitCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) { }
        protected open fun visitCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) { }
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        protected open fun visitScopeQualifier(node: PartiqlBasic.ScopeQualifier) { }
        protected open fun visitScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) { }
        protected open fun visitScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) { }
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        protected open fun visitSetQuantifier(node: PartiqlBasic.SetQuantifier) { }
        protected open fun visitSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) { }
        protected open fun visitSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) { }
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        protected open fun visitPathElement(node: PartiqlBasic.PathElement) { }
        protected open fun visitPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) { }
        protected open fun visitPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) { }
        protected open fun visitPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) { }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: PartiqlBasic.Expr) { }
        protected open fun visitExprLit(node: PartiqlBasic.Expr.Lit) { }
        protected open fun visitExprId(node: PartiqlBasic.Expr.Id) { }
        protected open fun visitExprParameter(node: PartiqlBasic.Expr.Parameter) { }
        protected open fun visitExprNot(node: PartiqlBasic.Expr.Not) { }
        protected open fun visitExprPlus(node: PartiqlBasic.Expr.Plus) { }
        protected open fun visitExprMinus(node: PartiqlBasic.Expr.Minus) { }
        protected open fun visitExprTimes(node: PartiqlBasic.Expr.Times) { }
        protected open fun visitExprDivide(node: PartiqlBasic.Expr.Divide) { }
        protected open fun visitExprModulo(node: PartiqlBasic.Expr.Modulo) { }
        protected open fun visitExprConcat(node: PartiqlBasic.Expr.Concat) { }
        protected open fun visitExprLike(node: PartiqlBasic.Expr.Like) { }
        protected open fun visitExprBetween(node: PartiqlBasic.Expr.Between) { }
        protected open fun visitExprPath(node: PartiqlBasic.Expr.Path) { }
        protected open fun visitExprCall(node: PartiqlBasic.Expr.Call) { }
        protected open fun visitExprCallAgg(node: PartiqlBasic.Expr.CallAgg) { }
        protected open fun visitExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) { }
        protected open fun visitExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) { }
        protected open fun visitExprStruct(node: PartiqlBasic.Expr.Struct) { }
        protected open fun visitExprBag(node: PartiqlBasic.Expr.Bag) { }
        protected open fun visitExprList(node: PartiqlBasic.Expr.List) { }
        protected open fun visitExprSelect(node: PartiqlBasic.Expr.Select) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkExprPair(node: PartiqlBasic.ExprPair) {
            visitExprPair(node)
            walkExpr(node.first)
            walkExpr(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkGroupByItem(node: PartiqlBasic.GroupByItem) {
            visitGroupByItem(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupByList(node: PartiqlBasic.GroupByList) {
            visitGroupByList(node)
            node.items.map { walkGroupByItem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupBy(node: PartiqlBasic.GroupBy) {
            visitGroupBy(node)
            walkGroupByList(node.items)
            node.groupAsAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlBasic.Projection) {
            visitProjection(node)
            when(node) {
                is PartiqlBasic.Projection.ProjectList -> walkProjectionProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> walkProjectionProjectValue(node)
            }
        }
    
        open fun walkProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) {
            visitProjectionProjectList(node)
            node.items.map { walkProjectItem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) {
            visitProjectionProjectValue(node)
            walkExpr(node.value)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlBasic.ProjectItem) {
            visitProjectItem(node)
            when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) {
            visitProjectItemProjectAll(node)
            walkMetas(node.metas)
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) {
            visitProjectItemProjectExpr(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlBasic.JoinType) {
            visitJoinType(node)
            when(node) {
                is PartiqlBasic.JoinType.Inner -> walkJoinTypeInner(node)
                is PartiqlBasic.JoinType.Left -> walkJoinTypeLeft(node)
                is PartiqlBasic.JoinType.Right -> walkJoinTypeRight(node)
                is PartiqlBasic.JoinType.Outer -> walkJoinTypeOuter(node)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlBasic.JoinType.Inner) {
            visitJoinTypeInner(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeLeft(node: PartiqlBasic.JoinType.Left) {
            visitJoinTypeLeft(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeRight(node: PartiqlBasic.JoinType.Right) {
            visitJoinTypeRight(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) {
            visitJoinTypeOuter(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlBasic.FromSource) {
            visitFromSource(node)
            when(node) {
                is PartiqlBasic.FromSource.Scan -> walkFromSourceScan(node)
                is PartiqlBasic.FromSource.Join -> walkFromSourceJoin(node)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlBasic.FromSource.Scan) {
            visitFromSourceScan(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            node.atAlias?.let { walkSymbolPrimitive(it) }
            node.byAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkFromSourceJoin(node: PartiqlBasic.FromSource.Join) {
            visitFromSourceJoin(node)
            walkJoinType(node.type)
            walkFromSource(node.left)
            walkFromSource(node.right)
            node.predicate?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlBasic.CaseSensitivity) {
            visitCaseSensitivity(node)
            when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) {
            visitCaseSensitivityCaseSensitive(node)
            walkMetas(node.metas)
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) {
            visitCaseSensitivityCaseInsensitive(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlBasic.ScopeQualifier) {
            visitScopeQualifier(node)
            when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> walkScopeQualifierQualified(node)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) {
            visitScopeQualifierUnqualified(node)
            walkMetas(node.metas)
        }
    
        open fun walkScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) {
            visitScopeQualifierQualified(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlBasic.SetQuantifier) {
            visitSetQuantifier(node)
            when(node) {
                is PartiqlBasic.SetQuantifier.All -> walkSetQuantifierAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) {
            visitSetQuantifierAll(node)
            walkMetas(node.metas)
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) {
            visitSetQuantifierDistinct(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun walkPathElement(node: PartiqlBasic.PathElement) {
            visitPathElement(node)
            when(node) {
                is PartiqlBasic.PathElement.PathExpr -> walkPathElementPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> walkPathElementPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> walkPathElementPathUnpivot(node)
            }
        }
    
        open fun walkPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) {
            visitPathElementPathExpr(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) {
            visitPathElementPathWildcard(node)
            walkMetas(node.metas)
        }
    
        open fun walkPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) {
            visitPathElementPathUnpivot(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlBasic.Expr) {
            visitExpr(node)
            when(node) {
                is PartiqlBasic.Expr.Lit -> walkExprLit(node)
                is PartiqlBasic.Expr.Id -> walkExprId(node)
                is PartiqlBasic.Expr.Parameter -> walkExprParameter(node)
                is PartiqlBasic.Expr.Not -> walkExprNot(node)
                is PartiqlBasic.Expr.Plus -> walkExprPlus(node)
                is PartiqlBasic.Expr.Minus -> walkExprMinus(node)
                is PartiqlBasic.Expr.Times -> walkExprTimes(node)
                is PartiqlBasic.Expr.Divide -> walkExprDivide(node)
                is PartiqlBasic.Expr.Modulo -> walkExprModulo(node)
                is PartiqlBasic.Expr.Concat -> walkExprConcat(node)
                is PartiqlBasic.Expr.Like -> walkExprLike(node)
                is PartiqlBasic.Expr.Between -> walkExprBetween(node)
                is PartiqlBasic.Expr.Path -> walkExprPath(node)
                is PartiqlBasic.Expr.Call -> walkExprCall(node)
                is PartiqlBasic.Expr.CallAgg -> walkExprCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> walkExprSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> walkExprSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> walkExprStruct(node)
                is PartiqlBasic.Expr.Bag -> walkExprBag(node)
                is PartiqlBasic.Expr.List -> walkExprList(node)
                is PartiqlBasic.Expr.Select -> walkExprSelect(node)
            }
        }
    
        open fun walkExprLit(node: PartiqlBasic.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprId(node: PartiqlBasic.Expr.Id) {
            visitExprId(node)
            walkSymbolPrimitive(node.name)
            walkCaseSensitivity(node.case)
            walkScopeQualifier(node.scopeQualifier)
            walkMetas(node.metas)
        }
    
        open fun walkExprParameter(node: PartiqlBasic.Expr.Parameter) {
            visitExprParameter(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: PartiqlBasic.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: PartiqlBasic.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: PartiqlBasic.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: PartiqlBasic.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: PartiqlBasic.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: PartiqlBasic.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprConcat(node: PartiqlBasic.Expr.Concat) {
            visitExprConcat(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprLike(node: PartiqlBasic.Expr.Like) {
            visitExprLike(node)
            walkExpr(node.left)
            walkExpr(node.right)
            walkExpr(node.escape)
            walkMetas(node.metas)
        }
    
        open fun walkExprBetween(node: PartiqlBasic.Expr.Between) {
            visitExprBetween(node)
            walkExpr(node.value)
            walkExpr(node.from)
            walkExpr(node.to)
            walkMetas(node.metas)
        }
    
        open fun walkExprPath(node: PartiqlBasic.Expr.Path) {
            visitExprPath(node)
            walkExpr(node.root)
            node.elements.map { walkPathElement(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: PartiqlBasic.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCallAgg(node: PartiqlBasic.Expr.CallAgg) {
            visitExprCallAgg(node)
            walkSymbolPrimitive(node.name)
            walkSetQuantifier(node.setQuantifier)
            walkExpr(node.arg)
            walkMetas(node.metas)
        }
    
        open fun walkExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) {
            visitExprSimpleCase(node)
            walkExpr(node.value)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) {
            visitExprSearchedCase(node)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprStruct(node: PartiqlBasic.Expr.Struct) {
            visitExprStruct(node)
            node.fields.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprBag(node: PartiqlBasic.Expr.Bag) {
            visitExprBag(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprList(node: PartiqlBasic.Expr.List) {
            visitExprList(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSelect(node: PartiqlBasic.Expr.Select) {
            visitExprSelect(node)
            node.setq?.let { walkSetQuantifier(it) }
            walkProjection(node.project)
            walkFromSource(node.from)
            node.where?.let { walkExpr(it) }
            node.group?.let { walkGroupBy(it) }
            node.having?.let { walkExpr(it) }
            node.limit?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitExprPair(node: PartiqlBasic.ExprPair, accumulator: T): T = accumulator
        open protected fun visitGroupByItem(node: PartiqlBasic.GroupByItem, accumulator: T): T = accumulator
        open protected fun visitGroupByList(node: PartiqlBasic.GroupByList, accumulator: T): T = accumulator
        open protected fun visitGroupBy(node: PartiqlBasic.GroupBy, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open protected fun visitProjection(node: PartiqlBasic.Projection, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectList(node: PartiqlBasic.Projection.ProjectList, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open protected fun visitProjectItem(node: PartiqlBasic.ProjectItem, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open protected fun visitJoinType(node: PartiqlBasic.JoinType, accumulator: T): T = accumulator
        open protected fun visitJoinTypeInner(node: PartiqlBasic.JoinType.Inner, accumulator: T): T = accumulator
        open protected fun visitJoinTypeLeft(node: PartiqlBasic.JoinType.Left, accumulator: T): T = accumulator
        open protected fun visitJoinTypeRight(node: PartiqlBasic.JoinType.Right, accumulator: T): T = accumulator
        open protected fun visitJoinTypeOuter(node: PartiqlBasic.JoinType.Outer, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open protected fun visitFromSource(node: PartiqlBasic.FromSource, accumulator: T): T = accumulator
        open protected fun visitFromSourceScan(node: PartiqlBasic.FromSource.Scan, accumulator: T): T = accumulator
        open protected fun visitFromSourceJoin(node: PartiqlBasic.FromSource.Join, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open protected fun visitCaseSensitivity(node: PartiqlBasic.CaseSensitivity, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open protected fun visitScopeQualifier(node: PartiqlBasic.ScopeQualifier, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open protected fun visitSetQuantifier(node: PartiqlBasic.SetQuantifier, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open protected fun visitPathElement(node: PartiqlBasic.PathElement, accumulator: T): T = accumulator
        open protected fun visitPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr, accumulator: T): T = accumulator
        open protected fun visitPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard, accumulator: T): T = accumulator
        open protected fun visitPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: PartiqlBasic.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: PartiqlBasic.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprId(node: PartiqlBasic.Expr.Id, accumulator: T): T = accumulator
        open protected fun visitExprParameter(node: PartiqlBasic.Expr.Parameter, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: PartiqlBasic.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: PartiqlBasic.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: PartiqlBasic.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: PartiqlBasic.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: PartiqlBasic.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: PartiqlBasic.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprConcat(node: PartiqlBasic.Expr.Concat, accumulator: T): T = accumulator
        open protected fun visitExprLike(node: PartiqlBasic.Expr.Like, accumulator: T): T = accumulator
        open protected fun visitExprBetween(node: PartiqlBasic.Expr.Between, accumulator: T): T = accumulator
        open protected fun visitExprPath(node: PartiqlBasic.Expr.Path, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: PartiqlBasic.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprCallAgg(node: PartiqlBasic.Expr.CallAgg, accumulator: T): T = accumulator
        open protected fun visitExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase, accumulator: T): T = accumulator
        open protected fun visitExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase, accumulator: T): T = accumulator
        open protected fun visitExprStruct(node: PartiqlBasic.Expr.Struct, accumulator: T): T = accumulator
        open protected fun visitExprBag(node: PartiqlBasic.Expr.Bag, accumulator: T): T = accumulator
        open protected fun visitExprList(node: PartiqlBasic.Expr.List, accumulator: T): T = accumulator
        open protected fun visitExprSelect(node: PartiqlBasic.Expr.Select, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkExprPair(node: PartiqlBasic.ExprPair, accumulator: T): T {
            var current = accumulator
            current = visitExprPair(node, current)
            current = walkExpr(node.first, current)
            current = walkExpr(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupByItem(node: PartiqlBasic.GroupByItem, accumulator: T): T {
            var current = accumulator
            current = visitGroupByItem(node, current)
            current = walkExpr(node.value, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupByList(node: PartiqlBasic.GroupByList, accumulator: T): T {
            var current = accumulator
            current = visitGroupByList(node, current)
            node.items.map { current = walkGroupByItem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupBy(node: PartiqlBasic.GroupBy, accumulator: T): T {
            var current = accumulator
            current = visitGroupBy(node, current)
            current = walkGroupByList(node.items, current)
            node.groupAsAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlBasic.Projection, accumulator: T): T {
            val current = visitProjection(node, accumulator)
            return when(node) {
                is PartiqlBasic.Projection.ProjectList -> walkProjectionProjectList(node, current)
                is PartiqlBasic.Projection.ProjectValue -> walkProjectionProjectValue(node, current)
            }
        }
    
        open fun walkProjectionProjectList(node: PartiqlBasic.Projection.ProjectList, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectList(node, current)
            node.items.map { current = walkProjectItem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectValue(node, current)
            current = walkExpr(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlBasic.ProjectItem, accumulator: T): T {
            val current = visitProjectItem(node, accumulator)
            return when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node, current)
                is PartiqlBasic.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node, current)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectAll(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectExpr(node, current)
            current = walkExpr(node.value, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlBasic.JoinType, accumulator: T): T {
            val current = visitJoinType(node, accumulator)
            return when(node) {
                is PartiqlBasic.JoinType.Inner -> walkJoinTypeInner(node, current)
                is PartiqlBasic.JoinType.Left -> walkJoinTypeLeft(node, current)
                is PartiqlBasic.JoinType.Right -> walkJoinTypeRight(node, current)
                is PartiqlBasic.JoinType.Outer -> walkJoinTypeOuter(node, current)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlBasic.JoinType.Inner, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeInner(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeLeft(node: PartiqlBasic.JoinType.Left, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeLeft(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeRight(node: PartiqlBasic.JoinType.Right, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeRight(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeOuter(node: PartiqlBasic.JoinType.Outer, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeOuter(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlBasic.FromSource, accumulator: T): T {
            val current = visitFromSource(node, accumulator)
            return when(node) {
                is PartiqlBasic.FromSource.Scan -> walkFromSourceScan(node, current)
                is PartiqlBasic.FromSource.Join -> walkFromSourceJoin(node, current)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlBasic.FromSource.Scan, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceScan(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.atAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.byAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkFromSourceJoin(node: PartiqlBasic.FromSource.Join, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceJoin(node, current)
            current = walkJoinType(node.type, current)
            current = walkFromSource(node.left, current)
            current = walkFromSource(node.right, current)
            node.predicate?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlBasic.CaseSensitivity, accumulator: T): T {
            val current = visitCaseSensitivity(node, accumulator)
            return when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node, current)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node, current)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseSensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseInsensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlBasic.ScopeQualifier, accumulator: T): T {
            val current = visitScopeQualifier(node, accumulator)
            return when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node, current)
                is PartiqlBasic.ScopeQualifier.Qualified -> walkScopeQualifierQualified(node, current)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierUnqualified(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierQualified(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlBasic.SetQuantifier, accumulator: T): T {
            val current = visitSetQuantifier(node, accumulator)
            return when(node) {
                is PartiqlBasic.SetQuantifier.All -> walkSetQuantifierAll(node, current)
                is PartiqlBasic.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node, current)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierAll(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierDistinct(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun walkPathElement(node: PartiqlBasic.PathElement, accumulator: T): T {
            val current = visitPathElement(node, accumulator)
            return when(node) {
                is PartiqlBasic.PathElement.PathExpr -> walkPathElementPathExpr(node, current)
                is PartiqlBasic.PathElement.PathWildcard -> walkPathElementPathWildcard(node, current)
                is PartiqlBasic.PathElement.PathUnpivot -> walkPathElementPathUnpivot(node, current)
            }
        }
    
        open fun walkPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathExpr(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathWildcard(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathUnpivot(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlBasic.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is PartiqlBasic.Expr.Lit -> walkExprLit(node, current)
                is PartiqlBasic.Expr.Id -> walkExprId(node, current)
                is PartiqlBasic.Expr.Parameter -> walkExprParameter(node, current)
                is PartiqlBasic.Expr.Not -> walkExprNot(node, current)
                is PartiqlBasic.Expr.Plus -> walkExprPlus(node, current)
                is PartiqlBasic.Expr.Minus -> walkExprMinus(node, current)
                is PartiqlBasic.Expr.Times -> walkExprTimes(node, current)
                is PartiqlBasic.Expr.Divide -> walkExprDivide(node, current)
                is PartiqlBasic.Expr.Modulo -> walkExprModulo(node, current)
                is PartiqlBasic.Expr.Concat -> walkExprConcat(node, current)
                is PartiqlBasic.Expr.Like -> walkExprLike(node, current)
                is PartiqlBasic.Expr.Between -> walkExprBetween(node, current)
                is PartiqlBasic.Expr.Path -> walkExprPath(node, current)
                is PartiqlBasic.Expr.Call -> walkExprCall(node, current)
                is PartiqlBasic.Expr.CallAgg -> walkExprCallAgg(node, current)
                is PartiqlBasic.Expr.SimpleCase -> walkExprSimpleCase(node, current)
                is PartiqlBasic.Expr.SearchedCase -> walkExprSearchedCase(node, current)
                is PartiqlBasic.Expr.Struct -> walkExprStruct(node, current)
                is PartiqlBasic.Expr.Bag -> walkExprBag(node, current)
                is PartiqlBasic.Expr.List -> walkExprList(node, current)
                is PartiqlBasic.Expr.Select -> walkExprSelect(node, current)
            }
        }
    
        open fun walkExprLit(node: PartiqlBasic.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprId(node: PartiqlBasic.Expr.Id, accumulator: T): T {
            var current = accumulator
            current = visitExprId(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkCaseSensitivity(node.case, current)
            current = walkScopeQualifier(node.scopeQualifier, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprParameter(node: PartiqlBasic.Expr.Parameter, accumulator: T): T {
            var current = accumulator
            current = visitExprParameter(node, current)
            current = walkLongPrimitive(node.index, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: PartiqlBasic.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: PartiqlBasic.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: PartiqlBasic.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: PartiqlBasic.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: PartiqlBasic.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: PartiqlBasic.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprConcat(node: PartiqlBasic.Expr.Concat, accumulator: T): T {
            var current = accumulator
            current = visitExprConcat(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLike(node: PartiqlBasic.Expr.Like, accumulator: T): T {
            var current = accumulator
            current = visitExprLike(node, current)
            current = walkExpr(node.left, current)
            current = walkExpr(node.right, current)
            current = walkExpr(node.escape, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBetween(node: PartiqlBasic.Expr.Between, accumulator: T): T {
            var current = accumulator
            current = visitExprBetween(node, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.from, current)
            current = walkExpr(node.to, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPath(node: PartiqlBasic.Expr.Path, accumulator: T): T {
            var current = accumulator
            current = visitExprPath(node, current)
            current = walkExpr(node.root, current)
            node.elements.map { current = walkPathElement(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: PartiqlBasic.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.args.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCallAgg(node: PartiqlBasic.Expr.CallAgg, accumulator: T): T {
            var current = accumulator
            current = visitExprCallAgg(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkSetQuantifier(node.setQuantifier, current)
            current = walkExpr(node.arg, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSimpleCase(node, current)
            current = walkExpr(node.value, current)
            node.branches.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSearchedCase(node, current)
            node.branches.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprStruct(node: PartiqlBasic.Expr.Struct, accumulator: T): T {
            var current = accumulator
            current = visitExprStruct(node, current)
            node.fields.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBag(node: PartiqlBasic.Expr.Bag, accumulator: T): T {
            var current = accumulator
            current = visitExprBag(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprList(node: PartiqlBasic.Expr.List, accumulator: T): T {
            var current = accumulator
            current = visitExprList(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSelect(node: PartiqlBasic.Expr.Select, accumulator: T): T {
            var current = accumulator
            current = visitExprSelect(node, current)
            node.setq?.let { current = walkSetQuantifier(it, current) }
            current = walkProjection(node.project, current)
            current = walkFromSource(node.from, current)
            node.where?.let { current = walkExpr(it, current) }
            node.group?.let { current = walkGroupBy(it, current) }
            node.having?.let { current = walkExpr(it, current) }
            node.limit?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple ExprPair
        open fun transformExprPair(node: ExprPair): ExprPair {
            val new_first = transformExprPair_first(node)
            val new_second = transformExprPair_second(node)
            val new_metas = transformExprPair_metas(node)
            return build {
                ExprPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformExprPair_first(node: ExprPair) =
            transformExpr(node.first)
        open fun transformExprPair_second(node: ExprPair) =
            transformExpr(node.second)
        open fun transformExprPair_metas(node: ExprPair) =
            transformMetas(node.metas)
    
        // Tuple GroupByItem
        open fun transformGroupByItem(node: GroupByItem): GroupByItem {
            val new_value = transformGroupByItem_value(node)
            val new_asAlias = transformGroupByItem_asAlias(node)
            val new_metas = transformGroupByItem_metas(node)
            return build {
                GroupByItem(
                    value = new_value,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            }
        }
        open fun transformGroupByItem_value(node: GroupByItem) =
            transformExpr(node.value)
        open fun transformGroupByItem_asAlias(node: GroupByItem) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupByItem_metas(node: GroupByItem) =
            transformMetas(node.metas)
    
        // Tuple GroupByList
        open fun transformGroupByList(node: GroupByList): GroupByList {
            val new_items = transformGroupByList_items(node)
            val new_metas = transformGroupByList_metas(node)
            return build {
                GroupByList(
                    items = new_items,
                    metas = new_metas
                )
            }
        }
        open fun transformGroupByList_items(node: GroupByList) =
            node.items.map { transformGroupByItem(it) }
        open fun transformGroupByList_metas(node: GroupByList) =
            transformMetas(node.metas)
    
        // Tuple GroupBy
        open fun transformGroupBy(node: GroupBy): GroupBy {
            val new_items = transformGroupBy_items(node)
            val new_groupAsAlias = transformGroupBy_groupAsAlias(node)
            val new_metas = transformGroupBy_metas(node)
            return build {
                GroupBy(
                    items = new_items,
                    groupAsAlias = new_groupAsAlias,
                    metas = new_metas
                )
            }
        }
        open fun transformGroupBy_items(node: GroupBy) =
            transformGroupByList(node.items)
        open fun transformGroupBy_groupAsAlias(node: GroupBy) =
            node.groupAsAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupBy_metas(node: GroupBy) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun transformProjection(node: PartiqlBasic.Projection) =
            when(node) {
                is PartiqlBasic.Projection.ProjectList -> transformProjectionProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> transformProjectionProjectValue(node)
            }
        // Variant ProjectionProjectList
        open fun transformProjectionProjectList(node: PartiqlBasic.Projection.ProjectList): PartiqlBasic.Projection {
            val new_items = transformProjectionProjectList_items(node)
            val new_metas = transformProjectionProjectList_metas(node)
            return build {
                Projection.ProjectList(
                    items = new_items,
                    metas = new_metas
                )
            }
        }
    
        open fun transformProjectionProjectList_items(node: Projection.ProjectList) =
            node.items.map { transformProjectItem(it) }
        open fun transformProjectionProjectList_metas(node: Projection.ProjectList) =
            transformMetas(node.metas)
    
    
        // Variant ProjectionProjectValue
        open fun transformProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue): PartiqlBasic.Projection {
            val new_value = transformProjectionProjectValue_value(node)
            val new_metas = transformProjectionProjectValue_metas(node)
            return build {
                Projection.ProjectValue(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
    
        open fun transformProjectionProjectValue_value(node: Projection.ProjectValue) =
            transformExpr(node.value)
        open fun transformProjectionProjectValue_metas(node: Projection.ProjectValue) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun transformProjectItem(node: PartiqlBasic.ProjectItem) =
            when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> transformProjectItemProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> transformProjectItemProjectExpr(node)
            }
        // Variant ProjectItemProjectAll
        open fun transformProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll): PartiqlBasic.ProjectItem {
            val new_metas = transformProjectItemProjectAll_metas(node)
            return build {
                ProjectItem.ProjectAll(
                    metas = new_metas
                )
            }
        }
    
        open fun transformProjectItemProjectAll_metas(node: ProjectItem.ProjectAll) =
            transformMetas(node.metas)
    
    
        // Variant ProjectItemProjectExpr
        open fun transformProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr): PartiqlBasic.ProjectItem {
            val new_value = transformProjectItemProjectExpr_value(node)
            val new_asAlias = transformProjectItemProjectExpr_asAlias(node)
            val new_metas = transformProjectItemProjectExpr_metas(node)
            return build {
                ProjectItem.ProjectExpr(
                    value = new_value,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            }
        }
    
        open fun transformProjectItemProjectExpr_value(node: ProjectItem.ProjectExpr) =
            transformExpr(node.value)
        open fun transformProjectItemProjectExpr_asAlias(node: ProjectItem.ProjectExpr) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformProjectItemProjectExpr_metas(node: ProjectItem.ProjectExpr) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun transformJoinType(node: PartiqlBasic.JoinType) =
            when(node) {
                is PartiqlBasic.JoinType.Inner -> transformJoinTypeInner(node)
                is PartiqlBasic.JoinType.Left -> transformJoinTypeLeft(node)
                is PartiqlBasic.JoinType.Right -> transformJoinTypeRight(node)
                is PartiqlBasic.JoinType.Outer -> transformJoinTypeOuter(node)
            }
        // Variant JoinTypeInner
        open fun transformJoinTypeInner(node: PartiqlBasic.JoinType.Inner): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeInner_metas(node)
            return build {
                JoinType.Inner(
                    metas = new_metas
                )
            }
        }
    
        open fun transformJoinTypeInner_metas(node: JoinType.Inner) =
            transformMetas(node.metas)
    
    
        // Variant JoinTypeLeft
        open fun transformJoinTypeLeft(node: PartiqlBasic.JoinType.Left): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeLeft_metas(node)
            return build {
                JoinType.Left(
                    metas = new_metas
                )
            }
        }
    
        open fun transformJoinTypeLeft_metas(node: JoinType.Left) =
            transformMetas(node.metas)
    
    
        // Variant JoinTypeRight
        open fun transformJoinTypeRight(node: PartiqlBasic.JoinType.Right): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeRight_metas(node)
            return build {
                JoinType.Right(
                    metas = new_metas
                )
            }
        }
    
        open fun transformJoinTypeRight_metas(node: JoinType.Right) =
            transformMetas(node.metas)
    
    
        // Variant JoinTypeOuter
        open fun transformJoinTypeOuter(node: PartiqlBasic.JoinType.Outer): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeOuter_metas(node)
            return build {
                JoinType.Outer(
                    metas = new_metas
                )
            }
        }
    
        open fun transformJoinTypeOuter_metas(node: JoinType.Outer) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun transformFromSource(node: PartiqlBasic.FromSource) =
            when(node) {
                is PartiqlBasic.FromSource.Scan -> transformFromSourceScan(node)
                is PartiqlBasic.FromSource.Join -> transformFromSourceJoin(node)
            }
        // Variant FromSourceScan
        open fun transformFromSourceScan(node: PartiqlBasic.FromSource.Scan): PartiqlBasic.FromSource {
            val new_expr = transformFromSourceScan_expr(node)
            val new_asAlias = transformFromSourceScan_asAlias(node)
            val new_atAlias = transformFromSourceScan_atAlias(node)
            val new_byAlias = transformFromSourceScan_byAlias(node)
            val new_metas = transformFromSourceScan_metas(node)
            return build {
                FromSource.Scan(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    atAlias = new_atAlias,
                    byAlias = new_byAlias,
                    metas = new_metas
                )
            }
        }
    
        open fun transformFromSourceScan_expr(node: FromSource.Scan) =
            transformExpr(node.expr)
        open fun transformFromSourceScan_asAlias(node: FromSource.Scan) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_atAlias(node: FromSource.Scan) =
            node.atAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_byAlias(node: FromSource.Scan) =
            node.byAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_metas(node: FromSource.Scan) =
            transformMetas(node.metas)
    
    
        // Variant FromSourceJoin
        open fun transformFromSourceJoin(node: PartiqlBasic.FromSource.Join): PartiqlBasic.FromSource {
            val new_type = transformFromSourceJoin_type(node)
            val new_left = transformFromSourceJoin_left(node)
            val new_right = transformFromSourceJoin_right(node)
            val new_predicate = transformFromSourceJoin_predicate(node)
            val new_metas = transformFromSourceJoin_metas(node)
            return build {
                FromSource.Join(
                    type = new_type,
                    left = new_left,
                    right = new_right,
                    predicate = new_predicate,
                    metas = new_metas
                )
            }
        }
    
        open fun transformFromSourceJoin_type(node: FromSource.Join) =
            transformJoinType(node.type)
        open fun transformFromSourceJoin_left(node: FromSource.Join) =
            transformFromSource(node.left)
        open fun transformFromSourceJoin_right(node: FromSource.Join) =
            transformFromSource(node.right)
        open fun transformFromSourceJoin_predicate(node: FromSource.Join) =
            node.predicate?.let { transformExpr(it) }
        open fun transformFromSourceJoin_metas(node: FromSource.Join) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun transformCaseSensitivity(node: PartiqlBasic.CaseSensitivity) =
            when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> transformCaseSensitivityCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> transformCaseSensitivityCaseInsensitive(node)
            }
        // Variant CaseSensitivityCaseSensitive
        open fun transformCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive): PartiqlBasic.CaseSensitivity {
            val new_metas = transformCaseSensitivityCaseSensitive_metas(node)
            return build {
                CaseSensitivity.CaseSensitive(
                    metas = new_metas
                )
            }
        }
    
        open fun transformCaseSensitivityCaseSensitive_metas(node: CaseSensitivity.CaseSensitive) =
            transformMetas(node.metas)
    
    
        // Variant CaseSensitivityCaseInsensitive
        open fun transformCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive): PartiqlBasic.CaseSensitivity {
            val new_metas = transformCaseSensitivityCaseInsensitive_metas(node)
            return build {
                CaseSensitivity.CaseInsensitive(
                    metas = new_metas
                )
            }
        }
    
        open fun transformCaseSensitivityCaseInsensitive_metas(node: CaseSensitivity.CaseInsensitive) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun transformScopeQualifier(node: PartiqlBasic.ScopeQualifier) =
            when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> transformScopeQualifierUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> transformScopeQualifierQualified(node)
            }
        // Variant ScopeQualifierUnqualified
        open fun transformScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified): PartiqlBasic.ScopeQualifier {
            val new_metas = transformScopeQualifierUnqualified_metas(node)
            return build {
                ScopeQualifier.Unqualified(
                    metas = new_metas
                )
            }
        }
    
        open fun transformScopeQualifierUnqualified_metas(node: ScopeQualifier.Unqualified) =
            transformMetas(node.metas)
    
    
        // Variant ScopeQualifierQualified
        open fun transformScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified): PartiqlBasic.ScopeQualifier {
            val new_metas = transformScopeQualifierQualified_metas(node)
            return build {
                ScopeQualifier.Qualified(
                    metas = new_metas
                )
            }
        }
    
        open fun transformScopeQualifierQualified_metas(node: ScopeQualifier.Qualified) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun transformSetQuantifier(node: PartiqlBasic.SetQuantifier) =
            when(node) {
                is PartiqlBasic.SetQuantifier.All -> transformSetQuantifierAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> transformSetQuantifierDistinct(node)
            }
        // Variant SetQuantifierAll
        open fun transformSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All): PartiqlBasic.SetQuantifier {
            val new_metas = transformSetQuantifierAll_metas(node)
            return build {
                SetQuantifier.All(
                    metas = new_metas
                )
            }
        }
    
        open fun transformSetQuantifierAll_metas(node: SetQuantifier.All) =
            transformMetas(node.metas)
    
    
        // Variant SetQuantifierDistinct
        open fun transformSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct): PartiqlBasic.SetQuantifier {
            val new_metas = transformSetQuantifierDistinct_metas(node)
            return build {
                SetQuantifier.Distinct(
                    metas = new_metas
                )
            }
        }
    
        open fun transformSetQuantifierDistinct_metas(node: SetQuantifier.Distinct) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun transformPathElement(node: PartiqlBasic.PathElement) =
            when(node) {
                is PartiqlBasic.PathElement.PathExpr -> transformPathElementPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> transformPathElementPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> transformPathElementPathUnpivot(node)
            }
        // Variant PathElementPathExpr
        open fun transformPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr): PartiqlBasic.PathElement {
            val new_expr = transformPathElementPathExpr_expr(node)
            val new_metas = transformPathElementPathExpr_metas(node)
            return build {
                PathElement.PathExpr(
                    expr = new_expr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformPathElementPathExpr_expr(node: PathElement.PathExpr) =
            transformExpr(node.expr)
        open fun transformPathElementPathExpr_metas(node: PathElement.PathExpr) =
            transformMetas(node.metas)
    
    
        // Variant PathElementPathWildcard
        open fun transformPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard): PartiqlBasic.PathElement {
            val new_metas = transformPathElementPathWildcard_metas(node)
            return build {
                PathElement.PathWildcard(
                    metas = new_metas
                )
            }
        }
    
        open fun transformPathElementPathWildcard_metas(node: PathElement.PathWildcard) =
            transformMetas(node.metas)
    
    
        // Variant PathElementPathUnpivot
        open fun transformPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot): PartiqlBasic.PathElement {
            val new_metas = transformPathElementPathUnpivot_metas(node)
            return build {
                PathElement.PathUnpivot(
                    metas = new_metas
                )
            }
        }
    
        open fun transformPathElementPathUnpivot_metas(node: PathElement.PathUnpivot) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: PartiqlBasic.Expr) =
            when(node) {
                is PartiqlBasic.Expr.Lit -> transformExprLit(node)
                is PartiqlBasic.Expr.Id -> transformExprId(node)
                is PartiqlBasic.Expr.Parameter -> transformExprParameter(node)
                is PartiqlBasic.Expr.Not -> transformExprNot(node)
                is PartiqlBasic.Expr.Plus -> transformExprPlus(node)
                is PartiqlBasic.Expr.Minus -> transformExprMinus(node)
                is PartiqlBasic.Expr.Times -> transformExprTimes(node)
                is PartiqlBasic.Expr.Divide -> transformExprDivide(node)
                is PartiqlBasic.Expr.Modulo -> transformExprModulo(node)
                is PartiqlBasic.Expr.Concat -> transformExprConcat(node)
                is PartiqlBasic.Expr.Like -> transformExprLike(node)
                is PartiqlBasic.Expr.Between -> transformExprBetween(node)
                is PartiqlBasic.Expr.Path -> transformExprPath(node)
                is PartiqlBasic.Expr.Call -> transformExprCall(node)
                is PartiqlBasic.Expr.CallAgg -> transformExprCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> transformExprSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> transformExprSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> transformExprStruct(node)
                is PartiqlBasic.Expr.Bag -> transformExprBag(node)
                is PartiqlBasic.Expr.List -> transformExprList(node)
                is PartiqlBasic.Expr.Select -> transformExprSelect(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: PartiqlBasic.Expr.Lit): PartiqlBasic.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return build {
                Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLit_value(node: Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: Expr.Lit) =
            transformMetas(node.metas)
    
    
        // Variant ExprId
        open fun transformExprId(node: PartiqlBasic.Expr.Id): PartiqlBasic.Expr {
            val new_name = transformExprId_name(node)
            val new_case = transformExprId_case(node)
            val new_scopeQualifier = transformExprId_scopeQualifier(node)
            val new_metas = transformExprId_metas(node)
            return build {
                Expr.Id(
                    name = new_name,
                    case = new_case,
                    scopeQualifier = new_scopeQualifier,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprId_name(node: Expr.Id) =
            transformSymbolPrimitive(node.name)
        open fun transformExprId_case(node: Expr.Id) =
            transformCaseSensitivity(node.case)
        open fun transformExprId_scopeQualifier(node: Expr.Id) =
            transformScopeQualifier(node.scopeQualifier)
        open fun transformExprId_metas(node: Expr.Id) =
            transformMetas(node.metas)
    
    
        // Variant ExprParameter
        open fun transformExprParameter(node: PartiqlBasic.Expr.Parameter): PartiqlBasic.Expr {
            val new_index = transformExprParameter_index(node)
            val new_metas = transformExprParameter_metas(node)
            return build {
                Expr.Parameter(
                    index = new_index,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprParameter_index(node: Expr.Parameter) =
            transformLongPrimitive(node.index)
        open fun transformExprParameter_metas(node: Expr.Parameter) =
            transformMetas(node.metas)
    
    
        // Variant ExprNot
        open fun transformExprNot(node: PartiqlBasic.Expr.Not): PartiqlBasic.Expr {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return build {
                Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprNot_expr(node: Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: Expr.Not) =
            transformMetas(node.metas)
    
    
        // Variant ExprPlus
        open fun transformExprPlus(node: PartiqlBasic.Expr.Plus): PartiqlBasic.Expr {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return build {
                Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprPlus_operands(node: Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: Expr.Plus) =
            transformMetas(node.metas)
    
    
        // Variant ExprMinus
        open fun transformExprMinus(node: PartiqlBasic.Expr.Minus): PartiqlBasic.Expr {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return build {
                Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprMinus_operands(node: Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: Expr.Minus) =
            transformMetas(node.metas)
    
    
        // Variant ExprTimes
        open fun transformExprTimes(node: PartiqlBasic.Expr.Times): PartiqlBasic.Expr {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return build {
                Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprTimes_operands(node: Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: Expr.Times) =
            transformMetas(node.metas)
    
    
        // Variant ExprDivide
        open fun transformExprDivide(node: PartiqlBasic.Expr.Divide): PartiqlBasic.Expr {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return build {
                Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprDivide_operands(node: Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: Expr.Divide) =
            transformMetas(node.metas)
    
    
        // Variant ExprModulo
        open fun transformExprModulo(node: PartiqlBasic.Expr.Modulo): PartiqlBasic.Expr {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return build {
                Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprModulo_operands(node: Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: Expr.Modulo) =
            transformMetas(node.metas)
    
    
        // Variant ExprConcat
        open fun transformExprConcat(node: PartiqlBasic.Expr.Concat): PartiqlBasic.Expr {
            val new_operands = transformExprConcat_operands(node)
            val new_metas = transformExprConcat_metas(node)
            return build {
                Expr.Concat(
                    operands = new_operands,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprConcat_operands(node: Expr.Concat) =
            node.operands.map { transformExpr(it) }
        open fun transformExprConcat_metas(node: Expr.Concat) =
            transformMetas(node.metas)
    
    
        // Variant ExprLike
        open fun transformExprLike(node: PartiqlBasic.Expr.Like): PartiqlBasic.Expr {
            val new_left = transformExprLike_left(node)
            val new_right = transformExprLike_right(node)
            val new_escape = transformExprLike_escape(node)
            val new_metas = transformExprLike_metas(node)
            return build {
                Expr.Like(
                    left = new_left,
                    right = new_right,
                    escape = new_escape,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprLike_left(node: Expr.Like) =
            transformExpr(node.left)
        open fun transformExprLike_right(node: Expr.Like) =
            transformExpr(node.right)
        open fun transformExprLike_escape(node: Expr.Like) =
            transformExpr(node.escape)
        open fun transformExprLike_metas(node: Expr.Like) =
            transformMetas(node.metas)
    
    
        // Variant ExprBetween
        open fun transformExprBetween(node: PartiqlBasic.Expr.Between): PartiqlBasic.Expr {
            val new_value = transformExprBetween_value(node)
            val new_from = transformExprBetween_from(node)
            val new_to = transformExprBetween_to(node)
            val new_metas = transformExprBetween_metas(node)
            return build {
                Expr.Between(
                    value = new_value,
                    from = new_from,
                    to = new_to,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprBetween_value(node: Expr.Between) =
            transformExpr(node.value)
        open fun transformExprBetween_from(node: Expr.Between) =
            transformExpr(node.from)
        open fun transformExprBetween_to(node: Expr.Between) =
            transformExpr(node.to)
        open fun transformExprBetween_metas(node: Expr.Between) =
            transformMetas(node.metas)
    
    
        // Variant ExprPath
        open fun transformExprPath(node: PartiqlBasic.Expr.Path): PartiqlBasic.Expr {
            val new_root = transformExprPath_root(node)
            val new_elements = transformExprPath_elements(node)
            val new_metas = transformExprPath_metas(node)
            return build {
                Expr.Path(
                    root = new_root,
                    elements = new_elements,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprPath_root(node: Expr.Path) =
            transformExpr(node.root)
        open fun transformExprPath_elements(node: Expr.Path) =
            node.elements.map { transformPathElement(it) }
        open fun transformExprPath_metas(node: Expr.Path) =
            transformMetas(node.metas)
    
    
        // Variant ExprCall
        open fun transformExprCall(node: PartiqlBasic.Expr.Call): PartiqlBasic.Expr {
            val new_name = transformExprCall_name(node)
            val new_args = transformExprCall_args(node)
            val new_metas = transformExprCall_metas(node)
            return build {
                Expr.Call(
                    name = new_name,
                    args = new_args,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprCall_name(node: Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_args(node: Expr.Call) =
            node.args.map { transformExpr(it) }
        open fun transformExprCall_metas(node: Expr.Call) =
            transformMetas(node.metas)
    
    
        // Variant ExprCallAgg
        open fun transformExprCallAgg(node: PartiqlBasic.Expr.CallAgg): PartiqlBasic.Expr {
            val new_name = transformExprCallAgg_name(node)
            val new_setQuantifier = transformExprCallAgg_setQuantifier(node)
            val new_arg = transformExprCallAgg_arg(node)
            val new_metas = transformExprCallAgg_metas(node)
            return build {
                Expr.CallAgg(
                    name = new_name,
                    setQuantifier = new_setQuantifier,
                    arg = new_arg,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprCallAgg_name(node: Expr.CallAgg) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCallAgg_setQuantifier(node: Expr.CallAgg) =
            transformSetQuantifier(node.setQuantifier)
        open fun transformExprCallAgg_arg(node: Expr.CallAgg) =
            transformExpr(node.arg)
        open fun transformExprCallAgg_metas(node: Expr.CallAgg) =
            transformMetas(node.metas)
    
    
        // Variant ExprSimpleCase
        open fun transformExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase): PartiqlBasic.Expr {
            val new_value = transformExprSimpleCase_value(node)
            val new_branches = transformExprSimpleCase_branches(node)
            val new_metas = transformExprSimpleCase_metas(node)
            return build {
                Expr.SimpleCase(
                    value = new_value,
                    branches = new_branches,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprSimpleCase_value(node: Expr.SimpleCase) =
            transformExpr(node.value)
        open fun transformExprSimpleCase_branches(node: Expr.SimpleCase) =
            node.branches.map { transformExprPair(it) }
        open fun transformExprSimpleCase_metas(node: Expr.SimpleCase) =
            transformMetas(node.metas)
    
    
        // Variant ExprSearchedCase
        open fun transformExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase): PartiqlBasic.Expr {
            val new_branches = transformExprSearchedCase_branches(node)
            val new_metas = transformExprSearchedCase_metas(node)
            return build {
                Expr.SearchedCase(
                    branches = new_branches,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprSearchedCase_branches(node: Expr.SearchedCase) =
            node.branches.map { transformExprPair(it) }
        open fun transformExprSearchedCase_metas(node: Expr.SearchedCase) =
            transformMetas(node.metas)
    
    
        // Variant ExprStruct
        open fun transformExprStruct(node: PartiqlBasic.Expr.Struct): PartiqlBasic.Expr {
            val new_fields = transformExprStruct_fields(node)
            val new_metas = transformExprStruct_metas(node)
            return build {
                Expr.Struct(
                    fields = new_fields,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprStruct_fields(node: Expr.Struct) =
            node.fields.map { transformExprPair(it) }
        open fun transformExprStruct_metas(node: Expr.Struct) =
            transformMetas(node.metas)
    
    
        // Variant ExprBag
        open fun transformExprBag(node: PartiqlBasic.Expr.Bag): PartiqlBasic.Expr {
            val new_values = transformExprBag_values(node)
            val new_metas = transformExprBag_metas(node)
            return build {
                Expr.Bag(
                    values = new_values,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprBag_values(node: Expr.Bag) =
            node.values.map { transformExpr(it) }
        open fun transformExprBag_metas(node: Expr.Bag) =
            transformMetas(node.metas)
    
    
        // Variant ExprList
        open fun transformExprList(node: PartiqlBasic.Expr.List): PartiqlBasic.Expr {
            val new_values = transformExprList_values(node)
            val new_metas = transformExprList_metas(node)
            return build {
                Expr.List(
                    values = new_values,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprList_values(node: Expr.List) =
            node.values.map { transformExpr(it) }
        open fun transformExprList_metas(node: Expr.List) =
            transformMetas(node.metas)
    
    
        // Variant ExprSelect
        open fun transformExprSelect(node: PartiqlBasic.Expr.Select): PartiqlBasic.Expr {
            val new_setq = transformExprSelect_setq(node)
            val new_project = transformExprSelect_project(node)
            val new_from = transformExprSelect_from(node)
            val new_where = transformExprSelect_where(node)
            val new_group = transformExprSelect_group(node)
            val new_having = transformExprSelect_having(node)
            val new_limit = transformExprSelect_limit(node)
            val new_metas = transformExprSelect_metas(node)
            return build {
                Expr.Select(
                    setq = new_setq,
                    project = new_project,
                    from = new_from,
                    where = new_where,
                    group = new_group,
                    having = new_having,
                    limit = new_limit,
                    metas = new_metas
                )
            }
        }
    
        open fun transformExprSelect_setq(node: Expr.Select) =
            node.setq?.let { transformSetQuantifier(it) }
        open fun transformExprSelect_project(node: Expr.Select) =
            transformProjection(node.project)
        open fun transformExprSelect_from(node: Expr.Select) =
            transformFromSource(node.from)
        open fun transformExprSelect_where(node: Expr.Select) =
            node.where?.let { transformExpr(it) }
        open fun transformExprSelect_group(node: Expr.Select) =
            node.group?.let { transformGroupBy(it) }
        open fun transformExprSelect_having(node: Expr.Select) =
            node.having?.let { transformExpr(it) }
        open fun transformExprSelect_limit(node: Expr.Select) =
            node.limit?.let { transformExpr(it) }
        open fun transformExprSelect_metas(node: Expr.Select) =
            transformMetas(node.metas)
    
    
    }
}

