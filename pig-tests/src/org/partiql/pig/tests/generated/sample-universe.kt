/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "FunctionName", "ClassName", "MemberVisibilityCanBePrivate", "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL", "LocalVariableName", "USELESS_ELVIS")


package org.partiql.pig.tests.generated

import javax.annotation.*
import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class test_domain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: test_domain_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): test_domain_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun int_pair(
            int0: Long,
            int1: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair =
            test_domain.int_pair(
                int0 = int0.asPrimitive(),
                int1 = int1.asPrimitive(),
                metas = metas)
        
        fun int_pair_(
            int0: LongPrimitive,
            int1: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair =
            test_domain.int_pair(
                int0 = int0,
                int1 = int1,
                metas = metas)
        
        
        fun symbol_pair(
            symbol0: String,
            symbol1: String,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair =
            test_domain.symbol_pair(
                symbol0 = symbol0.asPrimitive(),
                symbol1 = symbol1.asPrimitive(),
                metas = metas)
        
        fun symbol_pair_(
            symbol0: SymbolPrimitive,
            symbol1: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair =
            test_domain.symbol_pair(
                symbol0 = symbol0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun ion_pair(
            ion0: IonElement,
            ion1: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_pair =
            test_domain.ion_pair(
                ion0 = ion0,
                ion1 = ion1,
                metas = metas)
        
        
        fun int_symbol_pair(
            int0: Long,
            symbol1: String,
            metas: MetaContainer = emptyMetaContainer()
        ): int_symbol_pair =
            test_domain.int_symbol_pair(
                int0 = int0.asPrimitive(),
                symbol1 = symbol1.asPrimitive(),
                metas = metas)
        
        fun int_symbol_pair_(
            int0: LongPrimitive,
            symbol1: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): int_symbol_pair =
            test_domain.int_symbol_pair(
                int0 = int0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun symbol_int_pair(
            symbol0: String,
            int1: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_int_pair =
            test_domain.symbol_int_pair(
                symbol0 = symbol0.asPrimitive(),
                int1 = int1.asPrimitive(),
                metas = metas)
        
        fun symbol_int_pair_(
            symbol0: SymbolPrimitive,
            int1: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_int_pair =
            test_domain.symbol_int_pair(
                symbol0 = symbol0,
                int1 = int1,
                metas = metas)
        
        
        fun ion_int_pair(
            ion0: IonElement,
            int1: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_int_pair =
            test_domain.ion_int_pair(
                ion0 = ion0,
                int1 = int1.asPrimitive(),
                metas = metas)
        
        fun ion_int_pair_(
            ion0: IonElement,
            int1: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_int_pair =
            test_domain.ion_int_pair(
                ion0 = ion0,
                int1 = int1,
                metas = metas)
        
        
        fun ion_symbol_pair(
            ion0: IonElement,
            ion1: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_symbol_pair =
            test_domain.ion_symbol_pair(
                ion0 = ion0,
                ion1 = ion1,
                metas = metas)
        
        
        fun int_pair_pair(
            int_pair0: int_pair,
            int_pair1: int_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): int_pair_pair =
            test_domain.int_pair_pair(
                int_pair0 = int_pair0,
                int_pair1 = int_pair1,
                metas = metas)
        
        
        fun symbol_pair_pair(
            symbol_pair0: symbol_pair,
            symbol_pair1: symbol_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_pair_pair =
            test_domain.symbol_pair_pair(
                symbol_pair0 = symbol_pair0,
                symbol_pair1 = symbol_pair1,
                metas = metas)
        
        
        fun ion_pair_pair(
            ion_pair0: ion_pair,
            ion_pair1: ion_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): ion_pair_pair =
            test_domain.ion_pair_pair(
                ion_pair0 = ion_pair0,
                ion_pair1 = ion_pair1,
                metas = metas)
        
        
        fun recursive_pair(
            int0: Long,
            recursive_pair1: recursive_pair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): recursive_pair =
            test_domain.recursive_pair(
                int0 = int0.asPrimitive(),
                recursive_pair1 = recursive_pair1,
                metas = metas)
        
        fun recursive_pair_(
            int0: LongPrimitive,
            recursive_pair1: recursive_pair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): recursive_pair =
            test_domain.recursive_pair(
                int0 = int0,
                recursive_pair1 = recursive_pair1,
                metas = metas)
        
        
        fun answer_pair(
            answer0: answer,
            answer1: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_pair =
            test_domain.answer_pair(
                answer0 = answer0,
                answer1 = answer1,
                metas = metas)
        
        
        fun answer_int_pair(
            answer0: answer,
            int1: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_int_pair =
            test_domain.answer_int_pair(
                answer0 = answer0,
                int1 = int1.asPrimitive(),
                metas = metas)
        
        fun answer_int_pair_(
            answer0: answer,
            int1: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_int_pair =
            test_domain.answer_int_pair(
                answer0 = answer0,
                int1 = int1,
                metas = metas)
        
        
        fun int_answer_pair(
            int0: Long,
            answer1: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): int_answer_pair =
            test_domain.int_answer_pair(
                int0 = int0.asPrimitive(),
                answer1 = answer1,
                metas = metas)
        
        fun int_answer_pair_(
            int0: LongPrimitive,
            answer1: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): int_answer_pair =
            test_domain.int_answer_pair(
                int0 = int0,
                answer1 = answer1,
                metas = metas)
        
        
        fun symbol_answer_pair(
            symbol0: String,
            answer1: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_answer_pair =
            test_domain.symbol_answer_pair(
                symbol0 = symbol0.asPrimitive(),
                answer1 = answer1,
                metas = metas)
        
        fun symbol_answer_pair_(
            symbol0: SymbolPrimitive,
            answer1: answer,
            metas: MetaContainer = emptyMetaContainer()
        ): symbol_answer_pair =
            test_domain.symbol_answer_pair(
                symbol0 = symbol0,
                answer1 = answer1,
                metas = metas)
        
        
        fun answer_symbol_pair(
            answer0: answer,
            symbol1: String,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_symbol_pair =
            test_domain.answer_symbol_pair(
                answer0 = answer0,
                symbol1 = symbol1.asPrimitive(),
                metas = metas)
        
        fun answer_symbol_pair_(
            answer0: answer,
            symbol1: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): answer_symbol_pair =
            test_domain.answer_symbol_pair(
                answer0 = answer0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun variadic_min_0(
            int0: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                int0 = int0.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_0_(
            int0: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                int0 = int0,
                metas = metas)
        
        fun variadic_min_0(
            vararg int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                int0 = int0.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_0_(
            vararg int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_0 =
            test_domain.variadic_min_0(
                int0 = int0.toList(),
                metas = metas)
        
        
        fun variadic_min_1(
            int0: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                int0 = int0.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_1_(
            int0: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                int0 = int0,
                metas = metas)
        
        fun variadic_min_1(
            int0_required_0: Long,
            vararg int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                int0 = listOfPrimitives(int0_required_0) + int0.map { it.asPrimitive() },
                metas = metas)
        
        fun variadic_min_1_(
            int0_required_0: LongPrimitive,
            vararg int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): variadic_min_1 =
            test_domain.variadic_min_1(
                int0 = listOfPrimitives(int0_required_0) + int0.toList(),
                metas = metas)
        
        
        fun element_variadic(
            symbol0: String,
            int1: List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                symbol0 = symbol0.asPrimitive(),
                int1 = int1.map { it.asPrimitive() },
                metas = metas)
        
        fun element_variadic_(
            symbol0: SymbolPrimitive,
            int1: List<LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                symbol0 = symbol0,
                int1 = int1,
                metas = metas)
        
        fun element_variadic(
            symbol0: String,
            vararg int1: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                symbol0 = symbol0.asPrimitive(),
                int1 = int1.map { it.asPrimitive() },
                metas = metas)
        
        fun element_variadic_(
            symbol0: SymbolPrimitive,
            vararg int1: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): element_variadic =
            test_domain.element_variadic(
                symbol0 = symbol0,
                int1 = int1.toList(),
                metas = metas)
        
        
        fun optional_1(
            int0: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_1 =
            test_domain.optional_1(
                int0 = int0?.asPrimitive(),
                metas = metas)
        
        fun optional_1_(
            int0: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_1 =
            test_domain.optional_1(
                int0 = int0,
                metas = metas)
        
        
        fun optional_2(
            int0: Long? = null,
            int1: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_2 =
            test_domain.optional_2(
                int0 = int0?.asPrimitive(),
                int1 = int1?.asPrimitive(),
                metas = metas)
        
        fun optional_2_(
            int0: LongPrimitive? = null,
            int1: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): optional_2 =
            test_domain.optional_2(
                int0 = int0,
                int1 = int1,
                metas = metas)
        
        
        fun domain_level_record(
            some_field: Long,
            another_field: String,
            optional_field: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): domain_level_record =
            test_domain.domain_level_record(
                some_field = some_field.asPrimitive(),
                another_field = another_field.asPrimitive(),
                optional_field = optional_field?.asPrimitive(),
                metas = metas)
        
        fun domain_level_record_(
            some_field: LongPrimitive,
            another_field: SymbolPrimitive,
            optional_field: LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): domain_level_record =
            test_domain.domain_level_record(
                some_field = some_field,
                another_field = another_field,
                optional_field = optional_field,
                metas = metas)
        
        
        fun entity_pair(
            entity0: entity,
            entity1: entity,
            metas: MetaContainer = emptyMetaContainer()
        ): entity_pair =
            test_domain.entity_pair(
                entity0 = entity0,
                entity1 = entity1,
                metas = metas)
        
        
        // Variants for Sum: answer 
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): answer =
            answer.no(
                metas = metas)
        
        
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): answer =
            answer.yes(
                metas = metas)
        
        
        // Variants for Sum: entity 
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            entity.slug(
                metas = metas)
        
        
        fun android(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            entity.android(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun android_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            entity.android(
                int0 = int0,
                metas = metas)
        
        
        fun human(
            first_name: String,
            last_name: String,
            title: String? = null,
            parent: entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            entity.human(
                first_name = first_name.asPrimitive(),
                last_name = last_name.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        fun human_(
            first_name: SymbolPrimitive,
            last_name: SymbolPrimitive,
            title: SymbolPrimitive? = null,
            parent: entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): entity =
            entity.human(
                first_name = first_name,
                last_name = last_name,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all test_domain types. */
    abstract class test_domain_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): test_domain_node
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class int_pair(
        val int0: LongPrimitive,
        val int1: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): int_pair =
            int_pair(
                int0 = int0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                int0.toIonElement(),
                int1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_pair::class.java) return false
    
            other as int_pair
            if (int0 != other.int0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_pair(
        val symbol0: SymbolPrimitive,
        val symbol1: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): symbol_pair =
            symbol_pair(
                symbol0 = symbol0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                symbol0.toIonElement(),
                symbol1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_pair::class.java) return false
    
            other as symbol_pair
            if (symbol0 != other.symbol0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_pair(
        val ion0: IonElement,
        val ion1: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): ion_pair =
            ion_pair(
                ion0 = ion0,
                ion1 = ion1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                ion0.toIonElement(),
                ion1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_pair::class.java) return false
    
            other as ion_pair
            if (ion0 != other.ion0) return false
            if (ion1 != other.ion1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ion0.hashCode()
            hc = 31 * hc + ion1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_symbol_pair(
        val int0: LongPrimitive,
        val symbol1: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): int_symbol_pair =
            int_symbol_pair(
                int0 = int0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                int0.toIonElement(),
                symbol1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_symbol_pair::class.java) return false
    
            other as int_symbol_pair
            if (int0 != other.int0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_int_pair(
        val symbol0: SymbolPrimitive,
        val int1: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): symbol_int_pair =
            symbol_int_pair(
                symbol0 = symbol0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                symbol0.toIonElement(),
                int1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_int_pair::class.java) return false
    
            other as symbol_int_pair
            if (symbol0 != other.symbol0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_int_pair(
        val ion0: IonElement,
        val int1: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): ion_int_pair =
            ion_int_pair(
                ion0 = ion0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                ion0.toIonElement(),
                int1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_int_pair::class.java) return false
    
            other as ion_int_pair
            if (ion0 != other.ion0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ion0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_symbol_pair(
        val ion0: IonElement,
        val ion1: IonElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): ion_symbol_pair =
            ion_symbol_pair(
                ion0 = ion0,
                ion1 = ion1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                ion0.toIonElement(),
                ion1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_symbol_pair::class.java) return false
    
            other as ion_symbol_pair
            if (ion0 != other.ion0) return false
            if (ion1 != other.ion1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ion0.hashCode()
            hc = 31 * hc + ion1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_pair_pair(
        val int_pair0: int_pair,
        val int_pair1: int_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): int_pair_pair =
            int_pair_pair(
                int_pair0 = int_pair0,
                int_pair1 = int_pair1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                int_pair0.toIonElement(),
                int_pair1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_pair_pair::class.java) return false
    
            other as int_pair_pair
            if (int_pair0 != other.int_pair0) return false
            if (int_pair1 != other.int_pair1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int_pair0.hashCode()
            hc = 31 * hc + int_pair1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_pair_pair(
        val symbol_pair0: symbol_pair,
        val symbol_pair1: symbol_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): symbol_pair_pair =
            symbol_pair_pair(
                symbol_pair0 = symbol_pair0,
                symbol_pair1 = symbol_pair1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                symbol_pair0.toIonElement(),
                symbol_pair1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_pair_pair::class.java) return false
    
            other as symbol_pair_pair
            if (symbol_pair0 != other.symbol_pair0) return false
            if (symbol_pair1 != other.symbol_pair1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol_pair0.hashCode()
            hc = 31 * hc + symbol_pair1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ion_pair_pair(
        val ion_pair0: ion_pair,
        val ion_pair1: ion_pair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): ion_pair_pair =
            ion_pair_pair(
                ion_pair0 = ion_pair0,
                ion_pair1 = ion_pair1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                ion_pair0.toIonElement(),
                ion_pair1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ion_pair_pair::class.java) return false
    
            other as ion_pair_pair
            if (ion_pair0 != other.ion_pair0) return false
            if (ion_pair1 != other.ion_pair1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ion_pair0.hashCode()
            hc = 31 * hc + ion_pair1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class recursive_pair(
        val int0: LongPrimitive,
        val recursive_pair1: recursive_pair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): recursive_pair =
            recursive_pair(
                int0 = int0,
                recursive_pair1 = recursive_pair1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                int0.toIonElement(),
                recursive_pair1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != recursive_pair::class.java) return false
    
            other as recursive_pair
            if (int0 != other.int0) return false
            if (recursive_pair1 != other.recursive_pair1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc = 31 * hc + recursive_pair1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_pair(
        val answer0: answer,
        val answer1: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): answer_pair =
            answer_pair(
                answer0 = answer0,
                answer1 = answer1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                answer0.toIonElement(),
                answer1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_pair::class.java) return false
    
            other as answer_pair
            if (answer0 != other.answer0) return false
            if (answer1 != other.answer1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = answer0.hashCode()
            hc = 31 * hc + answer1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_int_pair(
        val answer0: answer,
        val int1: LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): answer_int_pair =
            answer_int_pair(
                answer0 = answer0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                answer0.toIonElement(),
                int1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_int_pair::class.java) return false
    
            other as answer_int_pair
            if (answer0 != other.answer0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = answer0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class int_answer_pair(
        val int0: LongPrimitive,
        val answer1: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): int_answer_pair =
            int_answer_pair(
                int0 = int0,
                answer1 = answer1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                int0.toIonElement(),
                answer1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != int_answer_pair::class.java) return false
    
            other as int_answer_pair
            if (int0 != other.int0) return false
            if (answer1 != other.answer1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc = 31 * hc + answer1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class symbol_answer_pair(
        val symbol0: SymbolPrimitive,
        val answer1: answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): symbol_answer_pair =
            symbol_answer_pair(
                symbol0 = symbol0,
                answer1 = answer1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                symbol0.toIonElement(),
                answer1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != symbol_answer_pair::class.java) return false
    
            other as symbol_answer_pair
            if (symbol0 != other.symbol0) return false
            if (answer1 != other.answer1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc = 31 * hc + answer1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class answer_symbol_pair(
        val answer0: answer,
        val symbol1: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): answer_symbol_pair =
            answer_symbol_pair(
                answer0 = answer0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                answer0.toIonElement(),
                symbol1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != answer_symbol_pair::class.java) return false
    
            other as answer_symbol_pair
            if (answer0 != other.answer0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = answer0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class variadic_min_0(
        val int0: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): variadic_min_0 =
            variadic_min_0(
                int0 = int0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *int0.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != variadic_min_0::class.java) return false
    
            other as variadic_min_0
            if (int0 != other.int0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class variadic_min_1(
        val int0: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): variadic_min_1 =
            variadic_min_1(
                int0 = int0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *int0.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != variadic_min_1::class.java) return false
    
            other as variadic_min_1
            if (int0 != other.int0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class element_variadic(
        val symbol0: SymbolPrimitive,
        val int1: List<LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): element_variadic =
            element_variadic(
                symbol0 = symbol0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                symbol0.toIonElement(),
                *int1.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != element_variadic::class.java) return false
    
            other as element_variadic
            if (symbol0 != other.symbol0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class optional_1(
        val int0: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): optional_1 =
            optional_1(
                int0 = int0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                int0?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != optional_1::class.java) return false
    
            other as optional_1
            if (int0 != other.int0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class optional_2(
        val int0: LongPrimitive?,
        val int1: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): optional_2 =
            optional_2(
                int0 = int0,
                int1 = int1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                int0?.toIonElement() ?: ionNull(),
                int1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != optional_2::class.java) return false
    
            other as optional_2
            if (int0 != other.int0) return false
            if (int1 != other.int1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = int0.hashCode()
            hc = 31 * hc + int1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class domain_level_record(
        val some_field: LongPrimitive,
        val another_field: SymbolPrimitive,
        val optional_field: LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): domain_level_record =
            domain_level_record(
                some_field = some_field,
                another_field = another_field,
                optional_field = optional_field,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
    
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                some_field?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                another_field?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optional_field?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas)
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != domain_level_record::class.java) return false
    
            other as domain_level_record
            if (some_field != other.some_field) return false
            if (another_field != other.another_field) return false
            if (optional_field != other.optional_field) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = some_field.hashCode()
            hc = 31 * hc + another_field.hashCode()
            hc = 31 * hc + optional_field.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class entity_pair(
        val entity0: entity,
        val entity1: entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): test_domain_node() {
    
        override fun withMeta(key: String, value: Any): entity_pair =
            entity_pair(
                entity0 = entity0,
                entity1 = entity1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                entity0.toIonElement(),
                entity1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != entity_pair::class.java) return false
    
            other as entity_pair
            if (entity0 != other.entity0) return false
            if (entity1 != other.entity1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = entity0.hashCode()
            hc = 31 * hc + entity1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class answer : test_domain_node() {
    
        class no(
            override val metas: MetaContainer = emptyMetaContainer()
        ): answer() {
        
            override fun withMeta(key: String, value: Any): no =
                no(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != no::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): answer() {
        
            override fun withMeta(key: String, value: Any): yes =
                yes(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class entity : test_domain_node() {
    
        class slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(key: String, value: Any): slug =
                slug(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class android(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(key: String, value: Any): android =
                android(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != android::class.java) return false
        
                other as android
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class human(
            val first_name: SymbolPrimitive,
            val last_name: SymbolPrimitive,
            val title: SymbolPrimitive?,
            val parent: entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): entity() {
        
            override fun withMeta(key: String, value: Any): human =
                human(
                    first_name = first_name,
                    last_name = last_name,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
        
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    first_name?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    last_name?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != human::class.java) return false
        
                other as human
                if (first_name != other.first_name) return false
                if (last_name != other.last_name) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = first_name.hashCode()
                hc = 31 * hc + last_name.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<test_domain_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): test_domain_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    val int1 = sexp.getRequired(1).toLongPrimitive()
                    int_pair(
                        int0,
                        int1,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val symbol1 = sexp.getRequired(1).toSymbolPrimitive()
                    symbol_pair(
                        symbol0,
                        symbol1,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val ion0 = sexp.getRequiredIon(0)
                    val ion1 = sexp.getRequiredIon(1)
                    ion_pair(
                        ion0,
                        ion1,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    val symbol1 = sexp.getRequired(1).toSymbolPrimitive()
                    int_symbol_pair(
                        int0,
                        symbol1,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val int1 = sexp.getRequired(1).toLongPrimitive()
                    symbol_int_pair(
                        symbol0,
                        int1,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val ion0 = sexp.getRequiredIon(0)
                    val int1 = sexp.getRequired(1).toLongPrimitive()
                    ion_int_pair(
                        ion0,
                        int1,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val ion0 = sexp.getRequiredIon(0)
                    val ion1 = sexp.getRequiredIon(1)
                    ion_symbol_pair(
                        ion0,
                        ion1,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val int_pair0 = sexp.getRequired(0).transformExpect<int_pair>()
                    val int_pair1 = sexp.getRequired(1).transformExpect<int_pair>()
                    int_pair_pair(
                        int_pair0,
                        int_pair1,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol_pair0 = sexp.getRequired(0).transformExpect<symbol_pair>()
                    val symbol_pair1 = sexp.getRequired(1).transformExpect<symbol_pair>()
                    symbol_pair_pair(
                        symbol_pair0,
                        symbol_pair1,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val ion_pair0 = sexp.getRequired(0).transformExpect<ion_pair>()
                    val ion_pair1 = sexp.getRequired(1).transformExpect<ion_pair>()
                    ion_pair_pair(
                        ion_pair0,
                        ion_pair1,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    val recursive_pair1 = sexp.getOptional(1)?.transformExpect<recursive_pair>()
                    recursive_pair(
                        int0,
                        recursive_pair1,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val answer0 = sexp.getRequired(0).transformExpect<answer>()
                    val answer1 = sexp.getRequired(1).transformExpect<answer>()
                    answer_pair(
                        answer0,
                        answer1,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val answer0 = sexp.getRequired(0).transformExpect<answer>()
                    val int1 = sexp.getRequired(1).toLongPrimitive()
                    answer_int_pair(
                        answer0,
                        int1,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    val answer1 = sexp.getRequired(1).transformExpect<answer>()
                    int_answer_pair(
                        int0,
                        answer1,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val answer1 = sexp.getRequired(1).transformExpect<answer>()
                    symbol_answer_pair(
                        symbol0,
                        answer1,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val answer0 = sexp.getRequired(0).transformExpect<answer>()
                    val symbol1 = sexp.getRequired(1).toSymbolPrimitive()
                    answer_symbol_pair(
                        answer0,
                        symbol1,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val int0 = sexp.drop(1).map { it.toLongPrimitive() }
                    variadic_min_0(
                        int0,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val int0 = sexp.drop(1).map { it.toLongPrimitive() }
                    variadic_min_1(
                        int0,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val int1 = sexp.drop(2).map { it.toLongPrimitive() }
                    element_variadic(
                        symbol0,
                        int1,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val int0 = sexp.getOptional(0)?.toLongPrimitive()
                    optional_1(
                        int0,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val int0 = sexp.getOptional(0)?.toLongPrimitive()
                    val int1 = sexp.getOptional(1)?.toLongPrimitive()
                    optional_2(
                        int0,
                        int1,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val some_field = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val another_field = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optional_field = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    domain_level_record(some_field, another_field, optional_field, metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val entity0 = sexp.getRequired(0).transformExpect<entity>()
                    val entity1 = sexp.getRequired(1).transformExpect<entity>()
                    entity_pair(
                        entity0,
                        entity1,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    answer.no(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    answer.yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    entity.slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    entity.android(
                        int0,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val first_name = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val last_name = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    entity.human(first_name, last_name, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
}

class toy_lang private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: toy_lang_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): toy_lang_node =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: expr 
        fun lit(
            ion0: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.lit(
                ion0 = ion0,
                metas = metas)
        
        
        fun variable(
            symbol0: String,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.variable(
                symbol0 = symbol0.asPrimitive(),
                metas = metas)
        
        fun variable_(
            symbol0: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.variable(
                symbol0 = symbol0,
                metas = metas)
        
        
        fun not(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.not(
                expr0 = expr0,
                metas = metas)
        
        
        fun plus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = expr0,
                metas = metas)
        
        fun plus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun minus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = expr0,
                metas = metas)
        
        fun minus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun times(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = expr0,
                metas = metas)
        
        fun times(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun divide(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = expr0,
                metas = metas)
        
        fun divide(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun modulo(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = expr0,
                metas = metas)
        
        fun modulo(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun call(
            symbol0: String,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        
        fun let(
            symbol0: String,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.let(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        fun let_(
            symbol0: SymbolPrimitive,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.let(
                symbol0 = symbol0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun function(
            symbol0: String,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.function(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun function_(
            symbol0: SymbolPrimitive,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.function(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
    }
    
    /** Base class for all toy_lang types. */
    abstract class toy_lang_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): toy_lang_node
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class expr : toy_lang_node() {
    
        class lit(
            val ion0: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): lit =
                lit(
                    ion0 = ion0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    ion0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (ion0 != other.ion0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = ion0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class variable(
            val symbol0: SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): variable =
                variable(
                    symbol0 = symbol0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    symbol0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != variable::class.java) return false
        
                other as variable
                if (symbol0 != other.symbol0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): not =
                not(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): plus =
                plus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): minus =
                minus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): times =
                times(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): divide =
                divide(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): modulo =
                modulo(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val symbol0: SymbolPrimitive,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call =
                call(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    symbol0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class let(
            val symbol0: SymbolPrimitive,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): let =
                let(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    symbol0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != let::class.java) return false
        
                other as let
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class function(
            val symbol0: SymbolPrimitive,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): function =
                function(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    symbol0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != function::class.java) return false
        
                other as function
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<toy_lang_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): toy_lang_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val ion0 = sexp.getRequiredIon(0)
                    expr.lit(
                        ion0,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    expr.variable(
                        symbol0,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    expr.not(
                        expr0,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.plus(
                        expr0,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.minus(
                        expr0,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.times(
                        expr0,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.divide(
                        expr0,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.modulo(
                        expr0,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.call(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.let(
                        symbol0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.function(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang'")
            }
        }
    }
}

class toy_lang_nameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: toy_lang_nameless_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): toy_lang_nameless_node =
            Transformer().transform(element)
    }
    
    object builder {
        // Variants for Sum: expr 
        fun lit(
            ion0: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.lit(
                ion0 = ion0,
                metas = metas)
        
        
        fun not(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.not(
                expr0 = expr0,
                metas = metas)
        
        
        fun plus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = expr0,
                metas = metas)
        
        fun plus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun minus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = expr0,
                metas = metas)
        
        fun minus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun times(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = expr0,
                metas = metas)
        
        fun times(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun divide(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = expr0,
                metas = metas)
        
        fun divide(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun modulo(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = expr0,
                metas = metas)
        
        fun modulo(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun call(
            symbol0: String,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        
        fun function(
            symbol0: String,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.function(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun function_(
            symbol0: SymbolPrimitive,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.function(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        
        fun variable(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.variable(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun variable_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.variable(
                int0 = int0,
                metas = metas)
        
        
        fun let(
            int0: Long,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.let(
                int0 = int0.asPrimitive(),
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        fun let_(
            int0: LongPrimitive,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.let(
                int0 = int0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
    }
    
    /** Base class for all toy_lang_nameless types. */
    abstract class toy_lang_nameless_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): toy_lang_nameless_node
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class expr : toy_lang_nameless_node() {
    
        class lit(
            val ion0: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): lit =
                lit(
                    ion0 = ion0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    ion0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (ion0 != other.ion0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = ion0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): not =
                not(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): plus =
                plus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): minus =
                minus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): times =
                times(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): divide =
                divide(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): modulo =
                modulo(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val symbol0: SymbolPrimitive,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call =
                call(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    symbol0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class function(
            val symbol0: SymbolPrimitive,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): function =
                function(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("function"),
                    symbol0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != function::class.java) return false
        
                other as function
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class variable(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): variable =
                variable(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != variable::class.java) return false
        
                other as variable
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class let(
            val int0: LongPrimitive,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): let =
                let(
                    int0 = int0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    int0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != let::class.java) return false
        
                other as let
                if (int0 != other.int0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<toy_lang_nameless_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): toy_lang_nameless_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val ion0 = sexp.getRequiredIon(0)
                    expr.lit(
                        ion0,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    expr.not(
                        expr0,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.plus(
                        expr0,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.minus(
                        expr0,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.times(
                        expr0,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.divide(
                        expr0,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.modulo(
                        expr0,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.call(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "function" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.function(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    expr.variable(
                        int0,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.let(
                        int0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'toy_lang_nameless'")
            }
        }
    }
}

class partiql_basic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: partiql_basic_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): partiql_basic_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun expr_pair(
            expr0: expr,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr_pair =
            partiql_basic.expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas)
        
        
        fun group_by_item(
            expr0: expr,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_item_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun group_by_list(
            group_by_item0: List<group_by_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic.group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas)
        
        fun group_by_list(
            group_by_item0_required_0: group_by_item,
            vararg group_by_item0: group_by_item,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic.group_by_list(
                group_by_item0 = listOf(group_by_item0_required_0) + group_by_item0.toList(),
                metas = metas)
        
        
        fun group_by(
            group_by_list0: group_by_list,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_(
            group_by_list0: group_by_list,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas)
        
        
        // Variants for Sum: projection 
        fun project_list(
            project_item0: List<project_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            projection.project_list(
                project_item0 = project_item0,
                metas = metas)
        
        fun project_list(
            project_item0_required_0: project_item,
            vararg project_item0: project_item,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            projection.project_list(
                project_item0 = listOf(project_item0_required_0) + project_item0.toList(),
                metas = metas)
        
        
        fun project_value(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): projection =
            projection.project_value(
                expr0 = expr0,
                metas = metas)
        
        
        // Variants for Sum: project_item 
        fun project_all(
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            project_item.project_all(
                metas = metas)
        
        
        fun project_expr(
            expr0: expr,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            project_item.project_expr(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun project_expr_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): project_item =
            project_item.project_expr(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas)
        
        
        // Variants for Sum: join_type 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.outer(
                metas = metas)
        
        
        // Variants for Sum: from_source 
        fun scan(
            expr0: expr,
            symbol1: String? = null,
            symbol2: String? = null,
            symbol3: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                symbol2 = symbol2?.asPrimitive(),
                symbol3 = symbol3?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            symbol2: SymbolPrimitive? = null,
            symbol3: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1,
                symbol2 = symbol2,
                symbol3 = symbol3,
                metas = metas)
        
        
        fun join(
            join_type0: join_type,
            from_source1: from_source,
            from_source2: from_source,
            expr3: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.join(
                join_type0 = join_type0,
                from_source1 = from_source1,
                from_source2 = from_source2,
                expr3 = expr3,
                metas = metas)
        
        
        // Variants for Sum: case_sensitivity 
        fun case_sensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_sensitive(
                metas = metas)
        
        
        fun case_insensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_insensitive(
                metas = metas)
        
        
        // Variants for Sum: scope_qualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.qualified(
                metas = metas)
        
        
        // Variants for Sum: set_quantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.all(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.distinct(
                metas = metas)
        
        
        // Variants for Sum: path_element 
        fun path_expr(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_expr(
                expr0 = expr0,
                metas = metas)
        
        
        fun path_wildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_wildcard(
                metas = metas)
        
        
        fun path_unpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_unpivot(
                metas = metas)
        
        
        // Variants for Sum: expr 
        fun lit(
            ion0: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.lit(
                ion0 = ion0,
                metas = metas)
        
        
        fun id(
            symbol0: String,
            case_sensitivity1: case_sensitivity,
            scope_qualifier2: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                symbol0 = symbol0.asPrimitive(),
                case_sensitivity1 = case_sensitivity1,
                scope_qualifier2 = scope_qualifier2,
                metas = metas)
        
        fun id_(
            symbol0: SymbolPrimitive,
            case_sensitivity1: case_sensitivity,
            scope_qualifier2: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                symbol0 = symbol0,
                case_sensitivity1 = case_sensitivity1,
                scope_qualifier2 = scope_qualifier2,
                metas = metas)
        
        
        fun parameter(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0,
                metas = metas)
        
        
        fun not(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.not(
                expr0 = expr0,
                metas = metas)
        
        
        fun plus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = expr0,
                metas = metas)
        
        fun plus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun minus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = expr0,
                metas = metas)
        
        fun minus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun times(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = expr0,
                metas = metas)
        
        fun times(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun divide(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = expr0,
                metas = metas)
        
        fun divide(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun modulo(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = expr0,
                metas = metas)
        
        fun modulo(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun concat(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = expr0,
                metas = metas)
        
        fun concat(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun like(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.like(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun between(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.between(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun path(
            expr0: expr,
            path_element1: List<path_element>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = path_element1,
                metas = metas)
        
        fun path(
            expr0: expr,
            path_element1_required_0: path_element,
            vararg path_element1: path_element,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = listOf(path_element1_required_0) + path_element1.toList(),
                metas = metas)
        
        
        fun call(
            symbol0: String,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        fun call(
            symbol0: String,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        
        fun call_agg(
            symbol0: String,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0.asPrimitive(),
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        fun call_agg_(
            symbol0: SymbolPrimitive,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0,
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        
        fun simple_case(
            expr0: expr,
            expr_pair1: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = expr_pair1,
                metas = metas)
        
        fun simple_case(
            expr0: expr,
            expr_pair1_required_0: expr_pair,
            vararg expr_pair1: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = listOf(expr_pair1_required_0) + expr_pair1.toList(),
                metas = metas)
        
        
        fun searched_case(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun searched_case(
            expr_pair0_required_0: expr_pair,
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = listOf(expr_pair0_required_0) + expr_pair0.toList(),
                metas = metas)
        
        
        fun struct(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun struct(
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0.toList(),
                metas = metas)
        
        
        fun bag(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0,
                metas = metas)
        
        fun bag(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun list(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0,
                metas = metas)
        
        fun list(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun select(
            setq: set_quantifier? = null,
            project: projection,
            from: from_source,
            where: expr? = null,
            group: group_by? = null,
            having: expr? = null,
            limit: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = metas)
    }
    
    /** Base class for all partiql_basic types. */
    abstract class partiql_basic_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): partiql_basic_node
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class expr_pair(
        val expr0: expr,
        val expr1: expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(key: String, value: Any): expr_pair =
            expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                expr0.toIonElement(),
                expr1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != expr_pair::class.java) return false
    
            other as expr_pair
            if (expr0 != other.expr0) return false
            if (expr1 != other.expr1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + expr1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_item(
        val expr0: expr,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(key: String, value: Any): group_by_item =
            group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                expr0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_item::class.java) return false
    
            other as group_by_item
            if (expr0 != other.expr0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_list(
        val group_by_item0: List<group_by_item>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(key: String, value: Any): group_by_list =
            group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *group_by_item0.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_list::class.java) return false
    
            other as group_by_list
            if (group_by_item0 != other.group_by_item0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_item0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by(
        val group_by_list0: group_by_list,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_node() {
    
        override fun withMeta(key: String, value: Any): group_by =
            group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                group_by_list0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by::class.java) return false
    
            other as group_by
            if (group_by_list0 != other.group_by_list0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_list0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class projection : partiql_basic_node() {
    
        class project_list(
            val project_item0: List<project_item>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): projection() {
        
            override fun withMeta(key: String, value: Any): project_list =
                project_list(
                    project_item0 = project_item0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *project_item0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_list::class.java) return false
        
                other as project_list
                if (project_item0 != other.project_item0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = project_item0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class project_value(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): projection() {
        
            override fun withMeta(key: String, value: Any): project_value =
                project_value(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_value::class.java) return false
        
                other as project_value
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class project_item : partiql_basic_node() {
    
        class project_all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): project_item() {
        
            override fun withMeta(key: String, value: Any): project_all =
                project_all(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class project_expr(
            val expr0: expr,
            val symbol1: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): project_item() {
        
            override fun withMeta(key: String, value: Any): project_expr =
                project_expr(
                    expr0 = expr0,
                    symbol1 = symbol1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    expr0.toIonElement(),
                    symbol1?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != project_expr::class.java) return false
        
                other as project_expr
                if (expr0 != other.expr0) return false
                if (symbol1 != other.symbol1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + symbol1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class join_type : partiql_basic_node() {
    
        class inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): inner =
                inner(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): left =
                left(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): right =
                right(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): outer =
                outer(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
    }
    
    sealed class from_source : partiql_basic_node() {
    
        class scan(
            val expr0: expr,
            val symbol1: SymbolPrimitive?,
            val symbol2: SymbolPrimitive?,
            val symbol3: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): scan =
                scan(
                    expr0 = expr0,
                    symbol1 = symbol1,
                    symbol2 = symbol2,
                    symbol3 = symbol3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr0.toIonElement(),
                    symbol1?.toIonElement() ?: ionNull(),
                    symbol2?.toIonElement() ?: ionNull(),
                    symbol3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != scan::class.java) return false
        
                other as scan
                if (expr0 != other.expr0) return false
                if (symbol1 != other.symbol1) return false
                if (symbol2 != other.symbol2) return false
                if (symbol3 != other.symbol3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + symbol1.hashCode()
                hc = 31 * hc + symbol2.hashCode()
                hc = 31 * hc + symbol3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class join(
            val join_type0: join_type,
            val from_source1: from_source,
            val from_source2: from_source,
            val expr3: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): join =
                join(
                    join_type0 = join_type0,
                    from_source1 = from_source1,
                    from_source2 = from_source2,
                    expr3 = expr3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    join_type0.toIonElement(),
                    from_source1.toIonElement(),
                    from_source2.toIonElement(),
                    expr3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != join::class.java) return false
        
                other as join
                if (join_type0 != other.join_type0) return false
                if (from_source1 != other.from_source1) return false
                if (from_source2 != other.from_source2) return false
                if (expr3 != other.expr3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = join_type0.hashCode()
                hc = 31 * hc + from_source1.hashCode()
                hc = 31 * hc + from_source2.hashCode()
                hc = 31 * hc + expr3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class case_sensitivity : partiql_basic_node() {
    
        class case_sensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_sensitive =
                case_sensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_sensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class case_insensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_insensitive =
                case_insensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_insensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class scope_qualifier : partiql_basic_node() {
    
        class unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): unqualified =
                unqualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): qualified =
                qualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
    }
    
    sealed class set_quantifier : partiql_basic_node() {
    
        class all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): all =
                all(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): distinct =
                distinct(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
    }
    
    sealed class path_element : partiql_basic_node() {
    
        class path_expr(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_expr =
                path_expr(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_expr::class.java) return false
        
                other as path_expr
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path_wildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_wildcard =
                path_wildcard(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_wildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class path_unpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_unpivot =
                path_unpivot(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_unpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
    }
    
    sealed class expr : partiql_basic_node() {
    
        class lit(
            val ion0: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): lit =
                lit(
                    ion0 = ion0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    ion0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (ion0 != other.ion0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = ion0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class id(
            val symbol0: SymbolPrimitive,
            val case_sensitivity1: case_sensitivity,
            val scope_qualifier2: scope_qualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): id =
                id(
                    symbol0 = symbol0,
                    case_sensitivity1 = case_sensitivity1,
                    scope_qualifier2 = scope_qualifier2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    symbol0.toIonElement(),
                    case_sensitivity1.toIonElement(),
                    scope_qualifier2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != id::class.java) return false
        
                other as id
                if (symbol0 != other.symbol0) return false
                if (case_sensitivity1 != other.case_sensitivity1) return false
                if (scope_qualifier2 != other.scope_qualifier2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + case_sensitivity1.hashCode()
                hc = 31 * hc + scope_qualifier2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class parameter(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): parameter =
                parameter(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != parameter::class.java) return false
        
                other as parameter
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): not =
                not(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): plus =
                plus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): minus =
                minus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): times =
                times(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): divide =
                divide(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): modulo =
                modulo(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class concat(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): concat =
                concat(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != concat::class.java) return false
        
                other as concat
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class like(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): like =
                like(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != like::class.java) return false
        
                other as like
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class between(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): between =
                between(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != between::class.java) return false
        
                other as between
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path(
            val expr0: expr,
            val path_element1: List<path_element>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): path =
                path(
                    expr0 = expr0,
                    path_element1 = path_element1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    expr0.toIonElement(),
                    *path_element1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path::class.java) return false
        
                other as path
                if (expr0 != other.expr0) return false
                if (path_element1 != other.path_element1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + path_element1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val symbol0: SymbolPrimitive,
            val expr1: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call =
                call(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    symbol0.toIonElement(),
                    *expr1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call_agg(
            val symbol0: SymbolPrimitive,
            val set_quantifier1: set_quantifier,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call_agg =
                call_agg(
                    symbol0 = symbol0,
                    set_quantifier1 = set_quantifier1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    symbol0.toIonElement(),
                    set_quantifier1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call_agg::class.java) return false
        
                other as call_agg
                if (symbol0 != other.symbol0) return false
                if (set_quantifier1 != other.set_quantifier1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + set_quantifier1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class simple_case(
            val expr0: expr,
            val expr_pair1: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): simple_case =
                simple_case(
                    expr0 = expr0,
                    expr_pair1 = expr_pair1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    expr0.toIonElement(),
                    *expr_pair1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != simple_case::class.java) return false
        
                other as simple_case
                if (expr0 != other.expr0) return false
                if (expr_pair1 != other.expr_pair1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr_pair1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class searched_case(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): searched_case =
                searched_case(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != searched_case::class.java) return false
        
                other as searched_case
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class struct(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): struct =
                struct(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != struct::class.java) return false
        
                other as struct
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class bag(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): bag =
                bag(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != bag::class.java) return false
        
                other as bag
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class list(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): list =
                list(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != list::class.java) return false
        
                other as list
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class select(
            val setq: set_quantifier?,
            val project: projection,
            val from: from_source,
            val where: expr?,
            val group: group_by?,
            val having: expr?,
            val limit: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): select =
                select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
        
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas)
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != select::class.java) return false
        
                other as select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<partiql_basic_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): partiql_basic_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr_pair(
                        expr0,
                        expr1,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by_item(
                        expr0,
                        symbol1,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val group_by_item0 = sexp.drop(1).map { it.transformExpect<group_by_item>() }
                    group_by_list(
                        group_by_item0,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val group_by_list0 = sexp.getRequired(0).transformExpect<group_by_list>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by(
                        group_by_list0,
                        symbol1,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val project_item0 = sexp.drop(1).map { it.transformExpect<project_item>() }
                    projection.project_list(
                        project_item0,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    projection.project_value(
                        expr0,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'project_item'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    project_item.project_all(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    project_item.project_expr(
                        expr0,
                        symbol1,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'join_type'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'from_source'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    val symbol2 = sexp.getOptional(2)?.toSymbolPrimitive()
                    val symbol3 = sexp.getOptional(3)?.toSymbolPrimitive()
                    from_source.scan(
                        expr0,
                        symbol1,
                        symbol2,
                        symbol3,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val join_type0 = sexp.getRequired(0).transformExpect<join_type>()
                    val from_source1 = sexp.getRequired(1).transformExpect<from_source>()
                    val from_source2 = sexp.getRequired(2).transformExpect<from_source>()
                    val expr3 = sexp.getOptional(3)?.transformExpect<expr>()
                    from_source.join(
                        join_type0,
                        from_source1,
                        from_source2,
                        expr3,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'case_sensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_sensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_insensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'scope_qualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'set_quantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.all(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'path_element'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    path_element.path_expr(
                        expr0,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_wildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_unpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val ion0 = sexp.getRequiredIon(0)
                    expr.lit(
                        ion0,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val case_sensitivity1 = sexp.getRequired(1).transformExpect<case_sensitivity>()
                    val scope_qualifier2 = sexp.getRequired(2).transformExpect<scope_qualifier>()
                    expr.id(
                        symbol0,
                        case_sensitivity1,
                        scope_qualifier2,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    expr.parameter(
                        int0,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    expr.not(
                        expr0,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.plus(
                        expr0,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.minus(
                        expr0,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.times(
                        expr0,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.divide(
                        expr0,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.modulo(
                        expr0,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.concat(
                        expr0,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.like(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.between(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val path_element1 = sexp.drop(2).map { it.transformExpect<path_element>() }
                    expr.path(
                        expr0,
                        path_element1,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.drop(2).map { it.transformExpect<expr>() }
                    expr.call(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val set_quantifier1 = sexp.getRequired(1).transformExpect<set_quantifier>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.call_agg(
                        symbol0,
                        set_quantifier1,
                        expr2,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr_pair1 = sexp.drop(2).map { it.transformExpect<expr_pair>() }
                    expr.simple_case(
                        expr0,
                        expr_pair1,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.searched_case(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.struct(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.bag(
                        expr0,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.list(
                        expr0,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<set_quantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<from_source>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<group_by>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    expr.select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
}

class partiql_algebra private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: partiql_algebra_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): partiql_algebra_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun expr_pair(
            expr0: expr,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr_pair =
            partiql_algebra.expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas)
        
        
        fun group_by_item(
            expr0: expr,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_algebra.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_item_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_algebra.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun group_by_list(
            group_by_item0: List<group_by_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_algebra.group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas)
        
        fun group_by_list(
            group_by_item0_required_0: group_by_item,
            vararg group_by_item0: group_by_item,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_algebra.group_by_list(
                group_by_item0 = listOf(group_by_item0_required_0) + group_by_item0.toList(),
                metas = metas)
        
        
        fun group_by(
            group_by_list0: group_by_list,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_algebra.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_(
            group_by_list0: group_by_list,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_algebra.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun tuple_field(
            symbol0: String,
            metas: MetaContainer = emptyMetaContainer()
        ): tuple_field =
            partiql_algebra.tuple_field(
                symbol0 = symbol0.asPrimitive(),
                metas = metas)
        
        fun tuple_field_(
            symbol0: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): tuple_field =
            partiql_algebra.tuple_field(
                symbol0 = symbol0,
                metas = metas)
        
        
        // Variants for Sum: join_type 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.outer(
                metas = metas)
        
        
        // Variants for Sum: from_source 
        fun scan(
            expr0: expr,
            symbol1: String? = null,
            symbol2: String? = null,
            symbol3: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                symbol2 = symbol2?.asPrimitive(),
                symbol3 = symbol3?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            symbol2: SymbolPrimitive? = null,
            symbol3: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1,
                symbol2 = symbol2,
                symbol3 = symbol3,
                metas = metas)
        
        
        fun join(
            join_type0: join_type,
            from_source1: from_source,
            from_source2: from_source,
            expr3: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.join(
                join_type0 = join_type0,
                from_source1 = from_source1,
                from_source2 = from_source2,
                expr3 = expr3,
                metas = metas)
        
        
        // Variants for Sum: case_sensitivity 
        fun case_sensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_sensitive(
                metas = metas)
        
        
        fun case_insensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_insensitive(
                metas = metas)
        
        
        // Variants for Sum: scope_qualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.qualified(
                metas = metas)
        
        
        // Variants for Sum: set_quantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.all(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.distinct(
                metas = metas)
        
        
        // Variants for Sum: path_element 
        fun path_expr(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_expr(
                expr0 = expr0,
                metas = metas)
        
        
        fun path_wildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_wildcard(
                metas = metas)
        
        
        fun path_unpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_unpivot(
                metas = metas)
        
        
        // Variants for Sum: expr 
        fun lit(
            ion0: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.lit(
                ion0 = ion0,
                metas = metas)
        
        
        fun id(
            symbol0: String,
            case_sensitivity1: case_sensitivity,
            scope_qualifier2: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                symbol0 = symbol0.asPrimitive(),
                case_sensitivity1 = case_sensitivity1,
                scope_qualifier2 = scope_qualifier2,
                metas = metas)
        
        fun id_(
            symbol0: SymbolPrimitive,
            case_sensitivity1: case_sensitivity,
            scope_qualifier2: scope_qualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                symbol0 = symbol0,
                case_sensitivity1 = case_sensitivity1,
                scope_qualifier2 = scope_qualifier2,
                metas = metas)
        
        
        fun parameter(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0,
                metas = metas)
        
        
        fun not(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.not(
                expr0 = expr0,
                metas = metas)
        
        
        fun plus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = expr0,
                metas = metas)
        
        fun plus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun minus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = expr0,
                metas = metas)
        
        fun minus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun times(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = expr0,
                metas = metas)
        
        fun times(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun divide(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = expr0,
                metas = metas)
        
        fun divide(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun modulo(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = expr0,
                metas = metas)
        
        fun modulo(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun concat(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = expr0,
                metas = metas)
        
        fun concat(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun like(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.like(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun between(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.between(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun path(
            expr0: expr,
            path_element1: List<path_element>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = path_element1,
                metas = metas)
        
        fun path(
            expr0: expr,
            path_element1_required_0: path_element,
            vararg path_element1: path_element,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = listOf(path_element1_required_0) + path_element1.toList(),
                metas = metas)
        
        
        fun call(
            symbol0: String,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        fun call(
            symbol0: String,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        
        fun call_agg(
            symbol0: String,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0.asPrimitive(),
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        fun call_agg_(
            symbol0: SymbolPrimitive,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0,
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        
        fun simple_case(
            expr0: expr,
            expr_pair1: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = expr_pair1,
                metas = metas)
        
        fun simple_case(
            expr0: expr,
            expr_pair1_required_0: expr_pair,
            vararg expr_pair1: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = listOf(expr_pair1_required_0) + expr_pair1.toList(),
                metas = metas)
        
        
        fun searched_case(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun searched_case(
            expr_pair0_required_0: expr_pair,
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = listOf(expr_pair0_required_0) + expr_pair0.toList(),
                metas = metas)
        
        
        fun struct(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun struct(
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0.toList(),
                metas = metas)
        
        
        fun bag(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0,
                metas = metas)
        
        fun bag(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun list(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0,
                metas = metas)
        
        fun list(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun filter(
            expr0: expr,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.filter(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas)
        
        
        fun construct_value(
            from_source0: from_source,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_value(
                from_source0 = from_source0,
                metas = metas)
        
        
        fun construct_tuple(
            from_source0: from_source,
            tuple_field1: List<tuple_field>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_tuple(
                from_source0 = from_source0,
                tuple_field1 = tuple_field1,
                metas = metas)
        
        fun construct_tuple(
            from_source0: from_source,
            tuple_field1_required_0: tuple_field,
            vararg tuple_field1: tuple_field,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_tuple(
                from_source0 = from_source0,
                tuple_field1 = listOf(tuple_field1_required_0) + tuple_field1.toList(),
                metas = metas)
    }
    
    /** Base class for all partiql_algebra types. */
    abstract class partiql_algebra_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): partiql_algebra_node
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class expr_pair(
        val expr0: expr,
        val expr1: expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_algebra_node() {
    
        override fun withMeta(key: String, value: Any): expr_pair =
            expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                expr0.toIonElement(),
                expr1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != expr_pair::class.java) return false
    
            other as expr_pair
            if (expr0 != other.expr0) return false
            if (expr1 != other.expr1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + expr1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_item(
        val expr0: expr,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_algebra_node() {
    
        override fun withMeta(key: String, value: Any): group_by_item =
            group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                expr0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_item::class.java) return false
    
            other as group_by_item
            if (expr0 != other.expr0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_list(
        val group_by_item0: List<group_by_item>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_algebra_node() {
    
        override fun withMeta(key: String, value: Any): group_by_list =
            group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *group_by_item0.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_list::class.java) return false
    
            other as group_by_list
            if (group_by_item0 != other.group_by_item0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_item0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by(
        val group_by_list0: group_by_list,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_algebra_node() {
    
        override fun withMeta(key: String, value: Any): group_by =
            group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                group_by_list0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by::class.java) return false
    
            other as group_by
            if (group_by_list0 != other.group_by_list0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_list0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class tuple_field(
        val symbol0: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_algebra_node() {
    
        override fun withMeta(key: String, value: Any): tuple_field =
            tuple_field(
                symbol0 = symbol0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("tuple_field"),
                symbol0.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != tuple_field::class.java) return false
    
            other as tuple_field
            if (symbol0 != other.symbol0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class join_type : partiql_algebra_node() {
    
        class inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): inner =
                inner(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): left =
                left(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        class right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): right =
                right(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1002
        }
    
        class outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): outer =
                outer(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1003
        }
    
    }
    
    sealed class from_source : partiql_algebra_node() {
    
        class scan(
            val expr0: expr,
            val symbol1: SymbolPrimitive?,
            val symbol2: SymbolPrimitive?,
            val symbol3: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): scan =
                scan(
                    expr0 = expr0,
                    symbol1 = symbol1,
                    symbol2 = symbol2,
                    symbol3 = symbol3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr0.toIonElement(),
                    symbol1?.toIonElement() ?: ionNull(),
                    symbol2?.toIonElement() ?: ionNull(),
                    symbol3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != scan::class.java) return false
        
                other as scan
                if (expr0 != other.expr0) return false
                if (symbol1 != other.symbol1) return false
                if (symbol2 != other.symbol2) return false
                if (symbol3 != other.symbol3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + symbol1.hashCode()
                hc = 31 * hc + symbol2.hashCode()
                hc = 31 * hc + symbol3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class join(
            val join_type0: join_type,
            val from_source1: from_source,
            val from_source2: from_source,
            val expr3: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): join =
                join(
                    join_type0 = join_type0,
                    from_source1 = from_source1,
                    from_source2 = from_source2,
                    expr3 = expr3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    join_type0.toIonElement(),
                    from_source1.toIonElement(),
                    from_source2.toIonElement(),
                    expr3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != join::class.java) return false
        
                other as join
                if (join_type0 != other.join_type0) return false
                if (from_source1 != other.from_source1) return false
                if (from_source2 != other.from_source2) return false
                if (expr3 != other.expr3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = join_type0.hashCode()
                hc = 31 * hc + from_source1.hashCode()
                hc = 31 * hc + from_source2.hashCode()
                hc = 31 * hc + expr3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class case_sensitivity : partiql_algebra_node() {
    
        class case_sensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_sensitive =
                case_sensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_sensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class case_insensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_insensitive =
                case_insensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_insensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
    }
    
    sealed class scope_qualifier : partiql_algebra_node() {
    
        class unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): unqualified =
                unqualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): qualified =
                qualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4001
        }
    
    }
    
    sealed class set_quantifier : partiql_algebra_node() {
    
        class all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): all =
                all(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): distinct =
                distinct(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class path_element : partiql_algebra_node() {
    
        class path_expr(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_expr =
                path_expr(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_expr::class.java) return false
        
                other as path_expr
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path_wildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_wildcard =
                path_wildcard(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_wildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
        class path_unpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_unpivot =
                path_unpivot(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_unpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6002
        }
    
    }
    
    sealed class expr : partiql_algebra_node() {
    
        class lit(
            val ion0: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): lit =
                lit(
                    ion0 = ion0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    ion0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (ion0 != other.ion0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = ion0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class id(
            val symbol0: SymbolPrimitive,
            val case_sensitivity1: case_sensitivity,
            val scope_qualifier2: scope_qualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): id =
                id(
                    symbol0 = symbol0,
                    case_sensitivity1 = case_sensitivity1,
                    scope_qualifier2 = scope_qualifier2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    symbol0.toIonElement(),
                    case_sensitivity1.toIonElement(),
                    scope_qualifier2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != id::class.java) return false
        
                other as id
                if (symbol0 != other.symbol0) return false
                if (case_sensitivity1 != other.case_sensitivity1) return false
                if (scope_qualifier2 != other.scope_qualifier2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + case_sensitivity1.hashCode()
                hc = 31 * hc + scope_qualifier2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class parameter(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): parameter =
                parameter(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != parameter::class.java) return false
        
                other as parameter
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): not =
                not(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): plus =
                plus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): minus =
                minus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): times =
                times(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): divide =
                divide(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): modulo =
                modulo(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class concat(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): concat =
                concat(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != concat::class.java) return false
        
                other as concat
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class like(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): like =
                like(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != like::class.java) return false
        
                other as like
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class between(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): between =
                between(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != between::class.java) return false
        
                other as between
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path(
            val expr0: expr,
            val path_element1: List<path_element>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): path =
                path(
                    expr0 = expr0,
                    path_element1 = path_element1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    expr0.toIonElement(),
                    *path_element1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path::class.java) return false
        
                other as path
                if (expr0 != other.expr0) return false
                if (path_element1 != other.path_element1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + path_element1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val symbol0: SymbolPrimitive,
            val expr1: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call =
                call(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    symbol0.toIonElement(),
                    *expr1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call_agg(
            val symbol0: SymbolPrimitive,
            val set_quantifier1: set_quantifier,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call_agg =
                call_agg(
                    symbol0 = symbol0,
                    set_quantifier1 = set_quantifier1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    symbol0.toIonElement(),
                    set_quantifier1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call_agg::class.java) return false
        
                other as call_agg
                if (symbol0 != other.symbol0) return false
                if (set_quantifier1 != other.set_quantifier1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + set_quantifier1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class simple_case(
            val expr0: expr,
            val expr_pair1: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): simple_case =
                simple_case(
                    expr0 = expr0,
                    expr_pair1 = expr_pair1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    expr0.toIonElement(),
                    *expr_pair1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != simple_case::class.java) return false
        
                other as simple_case
                if (expr0 != other.expr0) return false
                if (expr_pair1 != other.expr_pair1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr_pair1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class searched_case(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): searched_case =
                searched_case(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != searched_case::class.java) return false
        
                other as searched_case
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class struct(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): struct =
                struct(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != struct::class.java) return false
        
                other as struct
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class bag(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): bag =
                bag(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != bag::class.java) return false
        
                other as bag
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class list(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): list =
                list(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != list::class.java) return false
        
                other as list
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class filter(
            val expr0: expr,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): filter =
                filter(
                    expr0 = expr0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("filter"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != filter::class.java) return false
        
                other as filter
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class construct_value(
            val from_source0: from_source,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): construct_value =
                construct_value(
                    from_source0 = from_source0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("construct_value"),
                    from_source0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != construct_value::class.java) return false
        
                other as construct_value
                if (from_source0 != other.from_source0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = from_source0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class construct_tuple(
            val from_source0: from_source,
            val tuple_field1: List<tuple_field>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): construct_tuple =
                construct_tuple(
                    from_source0 = from_source0,
                    tuple_field1 = tuple_field1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("construct_tuple"),
                    from_source0.toIonElement(),
                    *tuple_field1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != construct_tuple::class.java) return false
        
                other as construct_tuple
                if (from_source0 != other.from_source0) return false
                if (tuple_field1 != other.tuple_field1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = from_source0.hashCode()
                hc = 31 * hc + tuple_field1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<partiql_algebra_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): partiql_algebra_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr_pair(
                        expr0,
                        expr1,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by_item(
                        expr0,
                        symbol1,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val group_by_item0 = sexp.drop(1).map { it.transformExpect<group_by_item>() }
                    group_by_list(
                        group_by_item0,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val group_by_list0 = sexp.getRequired(0).transformExpect<group_by_list>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by(
                        group_by_list0,
                        symbol1,
                        metas = sexp.metas)
                }
                "tuple_field" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    tuple_field(
                        symbol0,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'join_type'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'from_source'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    val symbol2 = sexp.getOptional(2)?.toSymbolPrimitive()
                    val symbol3 = sexp.getOptional(3)?.toSymbolPrimitive()
                    from_source.scan(
                        expr0,
                        symbol1,
                        symbol2,
                        symbol3,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val join_type0 = sexp.getRequired(0).transformExpect<join_type>()
                    val from_source1 = sexp.getRequired(1).transformExpect<from_source>()
                    val from_source2 = sexp.getRequired(2).transformExpect<from_source>()
                    val expr3 = sexp.getOptional(3)?.transformExpect<expr>()
                    from_source.join(
                        join_type0,
                        from_source1,
                        from_source2,
                        expr3,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'case_sensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_sensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_insensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'scope_qualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'set_quantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.all(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'path_element'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    path_element.path_expr(
                        expr0,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_wildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_unpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val ion0 = sexp.getRequiredIon(0)
                    expr.lit(
                        ion0,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val case_sensitivity1 = sexp.getRequired(1).transformExpect<case_sensitivity>()
                    val scope_qualifier2 = sexp.getRequired(2).transformExpect<scope_qualifier>()
                    expr.id(
                        symbol0,
                        case_sensitivity1,
                        scope_qualifier2,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    expr.parameter(
                        int0,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    expr.not(
                        expr0,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.plus(
                        expr0,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.minus(
                        expr0,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.times(
                        expr0,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.divide(
                        expr0,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.modulo(
                        expr0,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.concat(
                        expr0,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.like(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.between(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val path_element1 = sexp.drop(2).map { it.transformExpect<path_element>() }
                    expr.path(
                        expr0,
                        path_element1,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.drop(2).map { it.transformExpect<expr>() }
                    expr.call(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val set_quantifier1 = sexp.getRequired(1).transformExpect<set_quantifier>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.call_agg(
                        symbol0,
                        set_quantifier1,
                        expr2,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr_pair1 = sexp.drop(2).map { it.transformExpect<expr_pair>() }
                    expr.simple_case(
                        expr0,
                        expr_pair1,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.searched_case(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.struct(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.bag(
                        expr0,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.list(
                        expr0,
                        metas = sexp.metas)
                }
                "filter" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.filter(
                        expr0,
                        expr1,
                        metas = sexp.metas)
                }
                "construct_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val from_source0 = sexp.getRequired(0).transformExpect<from_source>()
                    expr.construct_value(
                        from_source0,
                        metas = sexp.metas)
                }
                "construct_tuple" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val from_source0 = sexp.getRequired(0).transformExpect<from_source>()
                    val tuple_field1 = sexp.drop(2).map { it.transformExpect<tuple_field>() }
                    expr.construct_tuple(
                        from_source0,
                        tuple_field1,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_algebra'")
            }
        }
    }
}

class partiql_basic_nameless private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        fun <T: partiql_basic_nameless_node> build(block: builder.() -> T) =
            builder.block()
    
        fun transform(element: IonElement): partiql_basic_nameless_node =
            Transformer().transform(element)
    }
    
    object builder {
                // Tuples
        fun expr_pair(
            expr0: expr,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr_pair =
            partiql_basic_nameless.expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas)
        
        
        fun group_by_item(
            expr0: expr,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic_nameless.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_item_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_item =
            partiql_basic_nameless.group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun group_by_list(
            group_by_item0: List<group_by_item>,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic_nameless.group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas)
        
        fun group_by_list(
            group_by_item0_required_0: group_by_item,
            vararg group_by_item0: group_by_item,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by_list =
            partiql_basic_nameless.group_by_list(
                group_by_item0 = listOf(group_by_item0_required_0) + group_by_item0.toList(),
                metas = metas)
        
        
        fun group_by(
            group_by_list0: group_by_list,
            symbol1: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic_nameless.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1?.asPrimitive(),
                metas = metas)
        
        fun group_by_(
            group_by_list0: group_by_list,
            symbol1: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): group_by =
            partiql_basic_nameless.group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas)
        
        
        fun tuple_field(
            symbol0: String,
            metas: MetaContainer = emptyMetaContainer()
        ): tuple_field =
            partiql_basic_nameless.tuple_field(
                symbol0 = symbol0.asPrimitive(),
                metas = metas)
        
        fun tuple_field_(
            symbol0: SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): tuple_field =
            partiql_basic_nameless.tuple_field(
                symbol0 = symbol0,
                metas = metas)
        
        
        // Variants for Sum: join_type 
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.inner(
                metas = metas)
        
        
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.left(
                metas = metas)
        
        
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.right(
                metas = metas)
        
        
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): join_type =
            join_type.outer(
                metas = metas)
        
        
        // Variants for Sum: from_source 
        fun scan(
            expr0: expr,
            symbol1: String? = null,
            symbol2: String? = null,
            symbol3: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1?.asPrimitive(),
                symbol2 = symbol2?.asPrimitive(),
                symbol3 = symbol3?.asPrimitive(),
                metas = metas)
        
        fun scan_(
            expr0: expr,
            symbol1: SymbolPrimitive? = null,
            symbol2: SymbolPrimitive? = null,
            symbol3: SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.scan(
                expr0 = expr0,
                symbol1 = symbol1,
                symbol2 = symbol2,
                symbol3 = symbol3,
                metas = metas)
        
        
        fun join(
            join_type0: join_type,
            from_source1: from_source,
            from_source2: from_source,
            expr3: expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): from_source =
            from_source.join(
                join_type0 = join_type0,
                from_source1 = from_source1,
                from_source2 = from_source2,
                expr3 = expr3,
                metas = metas)
        
        
        // Variants for Sum: case_sensitivity 
        fun case_sensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_sensitive(
                metas = metas)
        
        
        fun case_insensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity =
            case_sensitivity.case_insensitive(
                metas = metas)
        
        
        // Variants for Sum: scope_qualifier 
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.unqualified(
                metas = metas)
        
        
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier =
            scope_qualifier.qualified(
                metas = metas)
        
        
        // Variants for Sum: set_quantifier 
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.all(
                metas = metas)
        
        
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier =
            set_quantifier.distinct(
                metas = metas)
        
        
        // Variants for Sum: path_element 
        fun path_expr(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_expr(
                expr0 = expr0,
                metas = metas)
        
        
        fun path_wildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_wildcard(
                metas = metas)
        
        
        fun path_unpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): path_element =
            path_element.path_unpivot(
                metas = metas)
        
        
        // Variants for Sum: expr 
        fun lit(
            ion0: IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.lit(
                ion0 = ion0,
                metas = metas)
        
        
        fun parameter(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun parameter_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.parameter(
                int0 = int0,
                metas = metas)
        
        
        fun not(
            expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.not(
                expr0 = expr0,
                metas = metas)
        
        
        fun plus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = expr0,
                metas = metas)
        
        fun plus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.plus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun minus(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = expr0,
                metas = metas)
        
        fun minus(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.minus(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun times(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = expr0,
                metas = metas)
        
        fun times(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.times(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun divide(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = expr0,
                metas = metas)
        
        fun divide(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.divide(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun modulo(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = expr0,
                metas = metas)
        
        fun modulo(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.modulo(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun concat(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = expr0,
                metas = metas)
        
        fun concat(
            expr0_required_0: expr,
            expr0_required_1: expr,
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.concat(
                expr0 = listOf(expr0_required_0, expr0_required_1) + expr0.toList(),
                metas = metas)
        
        
        fun like(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.like(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun between(
            expr0: expr,
            expr1: expr,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.between(
                expr0 = expr0,
                expr1 = expr1,
                expr2 = expr2,
                metas = metas)
        
        
        fun path(
            expr0: expr,
            path_element1: List<path_element>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = path_element1,
                metas = metas)
        
        fun path(
            expr0: expr,
            path_element1_required_0: path_element,
            vararg path_element1: path_element,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.path(
                expr0 = expr0,
                path_element1 = listOf(path_element1_required_0) + path_element1.toList(),
                metas = metas)
        
        
        fun call(
            symbol0: String,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = expr1,
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = expr1,
                metas = metas)
        
        fun call(
            symbol0: String,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0.asPrimitive(),
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        fun call_(
            symbol0: SymbolPrimitive,
            expr1_required_0: expr,
            vararg expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call(
                symbol0 = symbol0,
                expr1 = listOf(expr1_required_0) + expr1.toList(),
                metas = metas)
        
        
        fun call_agg(
            symbol0: String,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0.asPrimitive(),
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        fun call_agg_(
            symbol0: SymbolPrimitive,
            set_quantifier1: set_quantifier,
            expr2: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.call_agg(
                symbol0 = symbol0,
                set_quantifier1 = set_quantifier1,
                expr2 = expr2,
                metas = metas)
        
        
        fun simple_case(
            expr0: expr,
            expr_pair1: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = expr_pair1,
                metas = metas)
        
        fun simple_case(
            expr0: expr,
            expr_pair1_required_0: expr_pair,
            vararg expr_pair1: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.simple_case(
                expr0 = expr0,
                expr_pair1 = listOf(expr_pair1_required_0) + expr_pair1.toList(),
                metas = metas)
        
        
        fun searched_case(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun searched_case(
            expr_pair0_required_0: expr_pair,
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.searched_case(
                expr_pair0 = listOf(expr_pair0_required_0) + expr_pair0.toList(),
                metas = metas)
        
        
        fun struct(
            expr_pair0: List<expr_pair>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0,
                metas = metas)
        
        fun struct(
            vararg expr_pair0: expr_pair,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.struct(
                expr_pair0 = expr_pair0.toList(),
                metas = metas)
        
        
        fun bag(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0,
                metas = metas)
        
        fun bag(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.bag(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun list(
            expr0: List<expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0,
                metas = metas)
        
        fun list(
            vararg expr0: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.list(
                expr0 = expr0.toList(),
                metas = metas)
        
        
        fun filter(
            expr0: expr,
            expr1: expr,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.filter(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas)
        
        
        fun construct_value(
            from_source0: from_source,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_value(
                from_source0 = from_source0,
                metas = metas)
        
        
        fun construct_tuple(
            from_source0: from_source,
            tuple_field1: List<tuple_field>,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_tuple(
                from_source0 = from_source0,
                tuple_field1 = tuple_field1,
                metas = metas)
        
        fun construct_tuple(
            from_source0: from_source,
            tuple_field1_required_0: tuple_field,
            vararg tuple_field1: tuple_field,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.construct_tuple(
                from_source0 = from_source0,
                tuple_field1 = listOf(tuple_field1_required_0) + tuple_field1.toList(),
                metas = metas)
        
        
        fun id(
            int0: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                int0 = int0.asPrimitive(),
                metas = metas)
        
        fun id_(
            int0: LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): expr =
            expr.id(
                int0 = int0,
                metas = metas)
    }
    
    /** Base class for all partiql_basic_nameless types. */
    abstract class partiql_basic_nameless_node : DomainNode {
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(key: String, value: Any): partiql_basic_nameless_node
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class expr_pair(
        val expr0: expr,
        val expr1: expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_nameless_node() {
    
        override fun withMeta(key: String, value: Any): expr_pair =
            expr_pair(
                expr0 = expr0,
                expr1 = expr1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                expr0.toIonElement(),
                expr1.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != expr_pair::class.java) return false
    
            other as expr_pair
            if (expr0 != other.expr0) return false
            if (expr1 != other.expr1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + expr1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_item(
        val expr0: expr,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_nameless_node() {
    
        override fun withMeta(key: String, value: Any): group_by_item =
            group_by_item(
                expr0 = expr0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                expr0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_item::class.java) return false
    
            other as group_by_item
            if (expr0 != other.expr0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = expr0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by_list(
        val group_by_item0: List<group_by_item>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_nameless_node() {
    
        override fun withMeta(key: String, value: Any): group_by_list =
            group_by_list(
                group_by_item0 = group_by_item0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *group_by_item0.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by_list::class.java) return false
    
            other as group_by_list
            if (group_by_item0 != other.group_by_item0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_item0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class group_by(
        val group_by_list0: group_by_list,
        val symbol1: SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_nameless_node() {
    
        override fun withMeta(key: String, value: Any): group_by =
            group_by(
                group_by_list0 = group_by_list0,
                symbol1 = symbol1,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                group_by_list0.toIonElement(),
                symbol1?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != group_by::class.java) return false
    
            other as group_by
            if (group_by_list0 != other.group_by_list0) return false
            if (symbol1 != other.symbol1) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = group_by_list0.hashCode()
            hc = 31 * hc + symbol1.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class tuple_field(
        val symbol0: SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): partiql_basic_nameless_node() {
    
        override fun withMeta(key: String, value: Any): tuple_field =
            tuple_field(
                symbol0 = symbol0,
                metas = metas + metaContainerOf(key to value))
    
        override fun toIonElement(): IonElement {
            val elements = ionSexpOf(
                ionSymbol("tuple_field"),
                symbol0.toIonElement(),
                metas = metas)
            return elements
        }
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != tuple_field::class.java) return false
    
            other as tuple_field
            if (symbol0 != other.symbol0) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = symbol0.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class join_type : partiql_basic_nameless_node() {
    
        class inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): inner =
                inner(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): left =
                left(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        class right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): right =
                right(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1002
        }
    
        class outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): join_type() {
        
            override fun withMeta(key: String, value: Any): outer =
                outer(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1003
        }
    
    }
    
    sealed class from_source : partiql_basic_nameless_node() {
    
        class scan(
            val expr0: expr,
            val symbol1: SymbolPrimitive?,
            val symbol2: SymbolPrimitive?,
            val symbol3: SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): scan =
                scan(
                    expr0 = expr0,
                    symbol1 = symbol1,
                    symbol2 = symbol2,
                    symbol3 = symbol3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr0.toIonElement(),
                    symbol1?.toIonElement() ?: ionNull(),
                    symbol2?.toIonElement() ?: ionNull(),
                    symbol3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != scan::class.java) return false
        
                other as scan
                if (expr0 != other.expr0) return false
                if (symbol1 != other.symbol1) return false
                if (symbol2 != other.symbol2) return false
                if (symbol3 != other.symbol3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + symbol1.hashCode()
                hc = 31 * hc + symbol2.hashCode()
                hc = 31 * hc + symbol3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class join(
            val join_type0: join_type,
            val from_source1: from_source,
            val from_source2: from_source,
            val expr3: expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): from_source() {
        
            override fun withMeta(key: String, value: Any): join =
                join(
                    join_type0 = join_type0,
                    from_source1 = from_source1,
                    from_source2 = from_source2,
                    expr3 = expr3,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    join_type0.toIonElement(),
                    from_source1.toIonElement(),
                    from_source2.toIonElement(),
                    expr3?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != join::class.java) return false
        
                other as join
                if (join_type0 != other.join_type0) return false
                if (from_source1 != other.from_source1) return false
                if (from_source2 != other.from_source2) return false
                if (expr3 != other.expr3) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = join_type0.hashCode()
                hc = 31 * hc + from_source1.hashCode()
                hc = 31 * hc + from_source2.hashCode()
                hc = 31 * hc + expr3.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class case_sensitivity : partiql_basic_nameless_node() {
    
        class case_sensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_sensitive =
                case_sensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_sensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class case_insensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): case_sensitivity() {
        
            override fun withMeta(key: String, value: Any): case_insensitive =
                case_insensitive(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != case_insensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
    }
    
    sealed class scope_qualifier : partiql_basic_nameless_node() {
    
        class unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): unqualified =
                unqualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): scope_qualifier() {
        
            override fun withMeta(key: String, value: Any): qualified =
                qualified(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4001
        }
    
    }
    
    sealed class set_quantifier : partiql_basic_nameless_node() {
    
        class all(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): all =
                all(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != all::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): set_quantifier() {
        
            override fun withMeta(key: String, value: Any): distinct =
                distinct(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
    }
    
    sealed class path_element : partiql_basic_nameless_node() {
    
        class path_expr(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_expr =
                path_expr(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_expr::class.java) return false
        
                other as path_expr
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path_wildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_wildcard =
                path_wildcard(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_wildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
        class path_unpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): path_element() {
        
            override fun withMeta(key: String, value: Any): path_unpivot =
                path_unpivot(
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path_unpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6002
        }
    
    }
    
    sealed class expr : partiql_basic_nameless_node() {
    
        class lit(
            val ion0: IonElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): lit =
                lit(
                    ion0 = ion0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    ion0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != lit::class.java) return false
        
                other as lit
                if (ion0 != other.ion0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = ion0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class parameter(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): parameter =
                parameter(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != parameter::class.java) return false
        
                other as parameter
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class not(
            val expr0: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): not =
                not(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != not::class.java) return false
        
                other as not
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class plus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): plus =
                plus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != plus::class.java) return false
        
                other as plus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class minus(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): minus =
                minus(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != minus::class.java) return false
        
                other as minus
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class times(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): times =
                times(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != times::class.java) return false
        
                other as times
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class divide(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): divide =
                divide(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != divide::class.java) return false
        
                other as divide
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class modulo(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): modulo =
                modulo(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != modulo::class.java) return false
        
                other as modulo
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class concat(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): concat =
                concat(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != concat::class.java) return false
        
                other as concat
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class like(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): like =
                like(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != like::class.java) return false
        
                other as like
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class between(
            val expr0: expr,
            val expr1: expr,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): between =
                between(
                    expr0 = expr0,
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != between::class.java) return false
        
                other as between
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class path(
            val expr0: expr,
            val path_element1: List<path_element>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): path =
                path(
                    expr0 = expr0,
                    path_element1 = path_element1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    expr0.toIonElement(),
                    *path_element1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != path::class.java) return false
        
                other as path
                if (expr0 != other.expr0) return false
                if (path_element1 != other.path_element1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + path_element1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call(
            val symbol0: SymbolPrimitive,
            val expr1: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call =
                call(
                    symbol0 = symbol0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    symbol0.toIonElement(),
                    *expr1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call::class.java) return false
        
                other as call
                if (symbol0 != other.symbol0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class call_agg(
            val symbol0: SymbolPrimitive,
            val set_quantifier1: set_quantifier,
            val expr2: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): call_agg =
                call_agg(
                    symbol0 = symbol0,
                    set_quantifier1 = set_quantifier1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    symbol0.toIonElement(),
                    set_quantifier1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != call_agg::class.java) return false
        
                other as call_agg
                if (symbol0 != other.symbol0) return false
                if (set_quantifier1 != other.set_quantifier1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = symbol0.hashCode()
                hc = 31 * hc + set_quantifier1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class simple_case(
            val expr0: expr,
            val expr_pair1: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): simple_case =
                simple_case(
                    expr0 = expr0,
                    expr_pair1 = expr_pair1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    expr0.toIonElement(),
                    *expr_pair1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != simple_case::class.java) return false
        
                other as simple_case
                if (expr0 != other.expr0) return false
                if (expr_pair1 != other.expr_pair1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr_pair1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class searched_case(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): searched_case =
                searched_case(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != searched_case::class.java) return false
        
                other as searched_case
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class struct(
            val expr_pair0: List<expr_pair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): struct =
                struct(
                    expr_pair0 = expr_pair0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *expr_pair0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != struct::class.java) return false
        
                other as struct
                if (expr_pair0 != other.expr_pair0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr_pair0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class bag(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): bag =
                bag(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != bag::class.java) return false
        
                other as bag
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class list(
            val expr0: List<expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): list =
                list(
                    expr0 = expr0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *expr0.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != list::class.java) return false
        
                other as list
                if (expr0 != other.expr0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class filter(
            val expr0: expr,
            val expr1: expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): filter =
                filter(
                    expr0 = expr0,
                    expr1 = expr1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("filter"),
                    expr0.toIonElement(),
                    expr1.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != filter::class.java) return false
        
                other as filter
                if (expr0 != other.expr0) return false
                if (expr1 != other.expr1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = expr0.hashCode()
                hc = 31 * hc + expr1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class construct_value(
            val from_source0: from_source,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): construct_value =
                construct_value(
                    from_source0 = from_source0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("construct_value"),
                    from_source0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != construct_value::class.java) return false
        
                other as construct_value
                if (from_source0 != other.from_source0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = from_source0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class construct_tuple(
            val from_source0: from_source,
            val tuple_field1: List<tuple_field>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): construct_tuple =
                construct_tuple(
                    from_source0 = from_source0,
                    tuple_field1 = tuple_field1,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("construct_tuple"),
                    from_source0.toIonElement(),
                    *tuple_field1.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != construct_tuple::class.java) return false
        
                other as construct_tuple
                if (from_source0 != other.from_source0) return false
                if (tuple_field1 != other.tuple_field1) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = from_source0.hashCode()
                hc = 31 * hc + tuple_field1.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class id(
            val int0: LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): expr() {
        
            override fun withMeta(key: String, value: Any): id =
                id(
                    int0 = int0,
                    metas = metas + metaContainerOf(key to value))
        
            override fun toIonElement(): IonElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    int0.toIonElement(),
                    metas = metas)
                return elements
            }
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != id::class.java) return false
        
                other as id
                if (int0 != other.int0) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = int0.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<partiql_basic_nameless_node>() {
    
        override fun innerTransform(maybeSexp: IonElement): partiql_basic_nameless_node {
            val sexp = maybeSexp.sexpValue
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr_pair(
                        expr0,
                        expr1,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by_item(
                        expr0,
                        symbol1,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val group_by_item0 = sexp.drop(1).map { it.transformExpect<group_by_item>() }
                    group_by_list(
                        group_by_item0,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val group_by_list0 = sexp.getRequired(0).transformExpect<group_by_list>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    group_by(
                        group_by_list0,
                        symbol1,
                        metas = sexp.metas)
                }
                "tuple_field" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    tuple_field(
                        symbol0,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'join_type'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    join_type.outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'from_source'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val symbol1 = sexp.getOptional(1)?.toSymbolPrimitive()
                    val symbol2 = sexp.getOptional(2)?.toSymbolPrimitive()
                    val symbol3 = sexp.getOptional(3)?.toSymbolPrimitive()
                    from_source.scan(
                        expr0,
                        symbol1,
                        symbol2,
                        symbol3,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val join_type0 = sexp.getRequired(0).transformExpect<join_type>()
                    val from_source1 = sexp.getRequired(1).transformExpect<from_source>()
                    val from_source2 = sexp.getRequired(2).transformExpect<from_source>()
                    val expr3 = sexp.getOptional(3)?.transformExpect<expr>()
                    from_source.join(
                        join_type0,
                        from_source1,
                        from_source2,
                        expr3,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'case_sensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_sensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    case_sensitivity.case_insensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'scope_qualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    scope_qualifier.qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'set_quantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.all(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    set_quantifier.distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'path_element'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    path_element.path_expr(
                        expr0,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_wildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    path_element.path_unpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val ion0 = sexp.getRequiredIon(0)
                    expr.lit(
                        ion0,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    expr.parameter(
                        int0,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    expr.not(
                        expr0,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.plus(
                        expr0,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.minus(
                        expr0,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.times(
                        expr0,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.divide(
                        expr0,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.modulo(
                        expr0,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.concat(
                        expr0,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.like(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.between(
                        expr0,
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val path_element1 = sexp.drop(2).map { it.transformExpect<path_element>() }
                    expr.path(
                        expr0,
                        path_element1,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val expr1 = sexp.drop(2).map { it.transformExpect<expr>() }
                    expr.call(
                        symbol0,
                        expr1,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val symbol0 = sexp.getRequired(0).toSymbolPrimitive()
                    val set_quantifier1 = sexp.getRequired(1).transformExpect<set_quantifier>()
                    val expr2 = sexp.getRequired(2).transformExpect<expr>()
                    expr.call_agg(
                        symbol0,
                        set_quantifier1,
                        expr2,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr_pair1 = sexp.drop(2).map { it.transformExpect<expr_pair>() }
                    expr.simple_case(
                        expr0,
                        expr_pair1,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.searched_case(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr_pair0 = sexp.drop(1).map { it.transformExpect<expr_pair>() }
                    expr.struct(
                        expr_pair0,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.bag(
                        expr0,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val expr0 = sexp.drop(1).map { it.transformExpect<expr>() }
                    expr.list(
                        expr0,
                        metas = sexp.metas)
                }
                "filter" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr0 = sexp.getRequired(0).transformExpect<expr>()
                    val expr1 = sexp.getRequired(1).transformExpect<expr>()
                    expr.filter(
                        expr0,
                        expr1,
                        metas = sexp.metas)
                }
                "construct_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val from_source0 = sexp.getRequired(0).transformExpect<from_source>()
                    expr.construct_value(
                        from_source0,
                        metas = sexp.metas)
                }
                "construct_tuple" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val from_source0 = sexp.getRequired(0).transformExpect<from_source>()
                    val tuple_field1 = sexp.drop(2).map { it.transformExpect<tuple_field>() }
                    expr.construct_tuple(
                        from_source0,
                        tuple_field1,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val int0 = sexp.getRequired(0).toLongPrimitive()
                    expr.id(
                        int0,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic_nameless'")
            }
        }
    }
}

