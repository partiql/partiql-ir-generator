/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
    "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
    "USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class TestDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = TestDomainBuilder
    
        fun <T: TestDomainNode> build(block: Builder.() -> T) =
            TestDomainBuilder.block()
    
        fun transform(element: AnyElement): TestDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): TestDomainNode =
            Transformer().transform(element)
    }
    
    interface Builder {
                // Tuples
        /**
         * Creates an instance of [TestDomain.IntPair].
         */
        fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair
        
        /**
         * Creates an instance of [TestDomain.IntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPair
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         */
        fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair
        
        /**
         * Creates an instance of [TestDomain.SymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPair
        
        
        /**
         * Creates an instance of [TestDomain.IonPair].
         */
        fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPair
        
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         */
        fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair
        
        /**
         * Creates an instance of [TestDomain.IntSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntSymbolPair
        
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         */
        fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair
        
        /**
         * Creates an instance of [TestDomain.SymbolIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolIntPair
        
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         */
        fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair
        
        /**
         * Creates an instance of [TestDomain.IonIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonIntPair
        
        
        /**
         * Creates an instance of [TestDomain.IonSymbolPair].
         */
        fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonSymbolPair
        
        
        /**
         * Creates an instance of [TestDomain.IntPairPair].
         */
        fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntPairPair
        
        
        /**
         * Creates an instance of [TestDomain.SymbolPairPair].
         */
        fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolPairPair
        
        
        /**
         * Creates an instance of [TestDomain.IonPairPair].
         */
        fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IonPairPair
        
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         */
        fun recursivePair(
            first: Long,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair
        
        /**
         * Creates an instance of [TestDomain.RecursivePair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.RecursivePair
        
        
        /**
         * Creates an instance of [TestDomain.AnswerPair].
         */
        fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerPair
        
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         */
        fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair
        
        /**
         * Creates an instance of [TestDomain.AnswerIntPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerIntPair
        
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         */
        fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair
        
        /**
         * Creates an instance of [TestDomain.IntAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.IntAnswerPair
        
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         */
        fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair
        
        /**
         * Creates an instance of [TestDomain.SymbolAnswerPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SymbolAnswerPair
        
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         */
        fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair
        
        /**
         * Creates an instance of [TestDomain.AnswerSymbolPair].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.AnswerSymbolPair
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         */
        fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0
        
        /**
         * Creates an instance of [TestDomain.VariadicMin0].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin0
        
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         */
        fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1
        
        /**
         * Creates an instance of [TestDomain.VariadicMin1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.VariadicMin1
        
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         */
        fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic
        
        /**
         * Creates an instance of [TestDomain.ElementVariadic].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ElementVariadic
        
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         */
        fun optional1(
            value: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1
        
        /**
         * Creates an instance of [TestDomain.Optional1].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional1
        
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         */
        fun optional2(
            first: Long? = null,
            second: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2
        
        /**
         * Creates an instance of [TestDomain.Optional2].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive? = null,
            second: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Optional2
        
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         */
        fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord
        
        /**
         * Creates an instance of [TestDomain.DomainLevelRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.DomainLevelRecord
        
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         */
        fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord
        
        /**
         * Creates an instance of [TestDomain.ProductWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.ProductWithRecord
        
        
        /**
         * Creates an instance of [TestDomain.TestSumTriplet].
         */
        fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSumTriplet
        
        
        /**
         * Creates an instance of [TestDomain.EntityPair].
         */
        fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.EntityPair
        
        
        // Variants for Sum: Answer 
        /**
         * Creates an instance of [TestDomain.Answer.No].
         */
        fun no(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.No
        
        
        /**
         * Creates an instance of [TestDomain.Answer.Yes].
         */
        fun yes(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Answer.Yes
        
        
        // Variants for Sum: SumWithRecord 
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         */
        fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord
        
        /**
         * Creates an instance of [TestDomain.SumWithRecord.VariantWithRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.SumWithRecord.VariantWithRecord
        
        
        // Variants for Sum: TestSum 
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         */
        fun one(
            a: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One
        
        /**
         * Creates an instance of [TestDomain.TestSum.One].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.One
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         */
        fun two(
            a: Long,
            b: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two
        
        /**
         * Creates an instance of [TestDomain.TestSum.Two].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Two
        
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         */
        fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three
        
        /**
         * Creates an instance of [TestDomain.TestSum.Three].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.TestSum.Three
        
        
        // Variants for Sum: Entity 
        /**
         * Creates an instance of [TestDomain.Entity.Slug].
         */
        fun slug(
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Slug
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         */
        fun android(
            id: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android
        
        /**
         * Creates an instance of [TestDomain.Entity.Android].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Android
        
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         */
        fun human(
            firstName: String,
            lastName: String,
            title: String? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human
        
        /**
         * Creates an instance of [TestDomain.Entity.Human].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive? = null,
            parent: Entity? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): TestDomain.Entity.Human
    }
    
    private object TestDomainBuilder : Builder {
                // Tuples
        override fun intPair(
            first: Long,
            second: Long,
            metas: MetaContainer
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        override fun intPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.IntPair =
            TestDomain.IntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun symbolPair(
            first: String,
            second: String,
            metas: MetaContainer
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        override fun symbolPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): TestDomain.SymbolPair =
            TestDomain.SymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun ionPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer
        ): TestDomain.IonPair =
            TestDomain.IonPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = metas)
        
        
        override fun intSymbolPair(
            first: Long,
            second: String,
            metas: MetaContainer
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        override fun intSymbolPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): TestDomain.IntSymbolPair =
            TestDomain.IntSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun symbolIntPair(
            first: String,
            second: Long,
            metas: MetaContainer
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first.asPrimitive(),
                second = second.asPrimitive(),
                metas = metas)
        
        override fun symbolIntPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.SymbolIntPair =
            TestDomain.SymbolIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun ionIntPair(
            first: com.amazon.ionelement.api.IonElement,
            second: Long,
            metas: MetaContainer
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second.asPrimitive(),
                metas = metas)
        
        override fun ionIntPair_(
            first: com.amazon.ionelement.api.IonElement,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.IonIntPair =
            TestDomain.IonIntPair(
                first = first.asAnyElement(),
                second = second,
                metas = metas)
        
        
        override fun ionSymbolPair(
            first: com.amazon.ionelement.api.IonElement,
            second: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer
        ): TestDomain.IonSymbolPair =
            TestDomain.IonSymbolPair(
                first = first.asAnyElement(),
                second = second.asAnyElement(),
                metas = metas)
        
        
        override fun intPairPair(
            first: IntPair,
            second: IntPair,
            metas: MetaContainer
        ): TestDomain.IntPairPair =
            TestDomain.IntPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun symbolPairPair(
            first: SymbolPair,
            second: SymbolPair,
            metas: MetaContainer
        ): TestDomain.SymbolPairPair =
            TestDomain.SymbolPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun ionPairPair(
            first: IonPair,
            second: IonPair,
            metas: MetaContainer
        ): TestDomain.IonPairPair =
            TestDomain.IonPairPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun recursivePair(
            first: Long,
            second: RecursivePair?,
            metas: MetaContainer
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        override fun recursivePair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: RecursivePair?,
            metas: MetaContainer
        ): TestDomain.RecursivePair =
            TestDomain.RecursivePair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun answerPair(
            first: Answer,
            second: Answer,
            metas: MetaContainer
        ): TestDomain.AnswerPair =
            TestDomain.AnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun answerIntPair(
            first: Answer,
            second: Long,
            metas: MetaContainer
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        override fun answerIntPair_(
            first: Answer,
            second: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.AnswerIntPair =
            TestDomain.AnswerIntPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun intAnswerPair(
            first: Long,
            second: Answer,
            metas: MetaContainer
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        override fun intAnswerPair_(
            first: org.partiql.pig.runtime.LongPrimitive,
            second: Answer,
            metas: MetaContainer
        ): TestDomain.IntAnswerPair =
            TestDomain.IntAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun symbolAnswerPair(
            first: String,
            second: Answer,
            metas: MetaContainer
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first.asPrimitive(),
                second = second,
                metas = metas)
        
        override fun symbolAnswerPair_(
            first: org.partiql.pig.runtime.SymbolPrimitive,
            second: Answer,
            metas: MetaContainer
        ): TestDomain.SymbolAnswerPair =
            TestDomain.SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun answerSymbolPair(
            first: Answer,
            second: String,
            metas: MetaContainer
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second.asPrimitive(),
                metas = metas)
        
        override fun answerSymbolPair_(
            first: Answer,
            second: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): TestDomain.AnswerSymbolPair =
            TestDomain.AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun variadicMin0(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun variadicMin0_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints,
                metas = metas)
        
        override fun variadicMin0(
            vararg ints: Long,
            metas: MetaContainer
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun variadicMin0_(
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.VariadicMin0 =
            TestDomain.VariadicMin0(
                ints = ints.toList(),
                metas = metas)
        
        
        override fun variadicMin1(
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun variadicMin1_(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = ints,
                metas = metas)
        
        override fun variadicMin1(
            ints0: Long,
            vararg ints: Long,
            metas: MetaContainer
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun variadicMin1_(
            ints0: org.partiql.pig.runtime.LongPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.VariadicMin1 =
            TestDomain.VariadicMin1(
                ints = listOfPrimitives(ints0) + ints.toList(),
                metas = metas)
        
        
        override fun elementVariadic(
            name: String,
            ints: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints,
                metas = metas)
        
        override fun elementVariadic(
            name: String,
            vararg ints: Long,
            metas: MetaContainer
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name.asPrimitive(),
                ints = ints.map { it.asPrimitive() },
                metas = metas)
        
        override fun elementVariadic_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            vararg ints: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.ElementVariadic =
            TestDomain.ElementVariadic(
                name = name,
                ints = ints.toList(),
                metas = metas)
        
        
        override fun optional1(
            value: Long?,
            metas: MetaContainer
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value?.asPrimitive(),
                metas = metas)
        
        override fun optional1_(
            value: org.partiql.pig.runtime.LongPrimitive?,
            metas: MetaContainer
        ): TestDomain.Optional1 =
            TestDomain.Optional1(
                value = value,
                metas = metas)
        
        
        override fun optional2(
            first: Long?,
            second: Long?,
            metas: MetaContainer
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first?.asPrimitive(),
                second = second?.asPrimitive(),
                metas = metas)
        
        override fun optional2_(
            first: org.partiql.pig.runtime.LongPrimitive?,
            second: org.partiql.pig.runtime.LongPrimitive?,
            metas: MetaContainer
        ): TestDomain.Optional2 =
            TestDomain.Optional2(
                first = first,
                second = second,
                metas = metas)
        
        
        override fun domainLevelRecord(
            someField: Long,
            anotherField: String,
            optionalField: Long?,
            metas: MetaContainer
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField.asPrimitive(),
                anotherField = anotherField.asPrimitive(),
                optionalField = optionalField?.asPrimitive(),
                metas = metas)
        
        override fun domainLevelRecord_(
            someField: org.partiql.pig.runtime.LongPrimitive,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive,
            optionalField: org.partiql.pig.runtime.LongPrimitive?,
            metas: MetaContainer
        ): TestDomain.DomainLevelRecord =
            TestDomain.DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas)
        
        
        override fun productWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        override fun productWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer
        ): TestDomain.ProductWithRecord =
            TestDomain.ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        override fun testSumTriplet(
            a: TestSum,
            b: TestSum,
            c: TestSum,
            metas: MetaContainer
        ): TestDomain.TestSumTriplet =
            TestDomain.TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        override fun entityPair(
            first: Entity,
            second: Entity,
            metas: MetaContainer
        ): TestDomain.EntityPair =
            TestDomain.EntityPair(
                first = first,
                second = second,
                metas = metas)
        
        
        // Variants for Sum: Answer 
        override fun no(
            metas: MetaContainer
        ): TestDomain.Answer.No =
            TestDomain.Answer.No(
                metas = metas)
        
        
        override fun yes(
            metas: MetaContainer
        ): TestDomain.Answer.Yes =
            TestDomain.Answer.Yes(
                metas = metas)
        
        
        // Variants for Sum: SumWithRecord 
        override fun variantWithRecord(
            value: Long,
            dlr: DomainLevelRecord,
            metas: MetaContainer
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value.asPrimitive(),
                dlr = dlr,
                metas = metas)
        
        override fun variantWithRecord_(
            value: org.partiql.pig.runtime.LongPrimitive,
            dlr: DomainLevelRecord,
            metas: MetaContainer
        ): TestDomain.SumWithRecord.VariantWithRecord =
            TestDomain.SumWithRecord.VariantWithRecord(
                value = value,
                dlr = dlr,
                metas = metas)
        
        
        // Variants for Sum: TestSum 
        override fun one(
            a: Long,
            metas: MetaContainer
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a.asPrimitive(),
                metas = metas)
        
        override fun one_(
            a: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.TestSum.One =
            TestDomain.TestSum.One(
                a = a,
                metas = metas)
        
        
        override fun two(
            a: Long,
            b: Long,
            metas: MetaContainer
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                metas = metas)
        
        override fun two_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.TestSum.Two =
            TestDomain.TestSum.Two(
                a = a,
                b = b,
                metas = metas)
        
        
        override fun three(
            a: Long,
            b: Long,
            c: Long,
            metas: MetaContainer
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a.asPrimitive(),
                b = b.asPrimitive(),
                c = c.asPrimitive(),
                metas = metas)
        
        override fun three_(
            a: org.partiql.pig.runtime.LongPrimitive,
            b: org.partiql.pig.runtime.LongPrimitive,
            c: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.TestSum.Three =
            TestDomain.TestSum.Three(
                a = a,
                b = b,
                c = c,
                metas = metas)
        
        
        // Variants for Sum: Entity 
        override fun slug(
            metas: MetaContainer
        ): TestDomain.Entity.Slug =
            TestDomain.Entity.Slug(
                metas = metas)
        
        
        override fun android(
            id: Long,
            metas: MetaContainer
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id.asPrimitive(),
                metas = metas)
        
        override fun android_(
            id: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): TestDomain.Entity.Android =
            TestDomain.Entity.Android(
                id = id,
                metas = metas)
        
        
        override fun human(
            firstName: String,
            lastName: String,
            title: String?,
            parent: Entity?,
            metas: MetaContainer
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName.asPrimitive(),
                lastName = lastName.asPrimitive(),
                title = title?.asPrimitive(),
                parent = parent,
                metas = metas)
        
        override fun human_(
            firstName: org.partiql.pig.runtime.SymbolPrimitive,
            lastName: org.partiql.pig.runtime.SymbolPrimitive,
            title: org.partiql.pig.runtime.SymbolPrimitive?,
            parent: Entity?,
            metas: MetaContainer
        ): TestDomain.Entity.Human =
            TestDomain.Entity.Human(
                firstName = firstName,
                lastName = lastName,
                title = title,
                parent = parent,
                metas = metas)
    }
    
    /** Base class for all TestDomain types. */
    abstract class TestDomainNode : DomainNode {
        abstract override fun copyMetas(newMetas: MetaContainer): TestDomainNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): TestDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class IntPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPair =
            IntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPair::class.java) return false
    
            other as IntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPair =
            SymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPair::class.java) return false
    
            other as SymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPair =
            IonPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPair::class.java) return false
    
            other as IonPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntSymbolPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntSymbolPair =
            IntSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntSymbolPair::class.java) return false
    
            other as IntSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolIntPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolIntPair =
            SymbolIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolIntPair::class.java) return false
    
            other as SymbolIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonIntPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonIntPair =
            IonIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonIntPair::class.java) return false
    
            other as IonIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonSymbolPair(
        val first: com.amazon.ionelement.api.AnyElement,
        val second: com.amazon.ionelement.api.AnyElement,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonSymbolPair =
            IonSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: com.amazon.ionelement.api.AnyElement = this.first,
            second: com.amazon.ionelement.api.AnyElement = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonSymbolPair::class.java) return false
    
            other as IonSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntPairPair(
        val first: IntPair,
        val second: IntPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntPairPair =
            IntPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IntPair = this.first,
            second: IntPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntPairPair::class.java) return false
    
            other as IntPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolPairPair(
        val first: SymbolPair,
        val second: SymbolPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolPairPair =
            SymbolPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: SymbolPair = this.first,
            second: SymbolPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolPairPair::class.java) return false
    
            other as SymbolPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IonPairPair(
        val first: IonPair,
        val second: IonPair,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IonPairPair =
            IonPairPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("ion_pair_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: IonPair = this.first,
            second: IonPair = this.second,
            metas: MetaContainer = this.metas
        ) =
            IonPairPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IonPairPair::class.java) return false
    
            other as IonPairPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecursivePair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: RecursivePair?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecursivePair =
            RecursivePair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("recursive_pair"),
                first.toIonElement(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: RecursivePair? = this.second,
            metas: MetaContainer = this.metas
        ) =
            RecursivePair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecursivePair::class.java) return false
    
            other as RecursivePair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerPair(
        val first: Answer,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerPair =
            AnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerPair::class.java) return false
    
            other as AnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerIntPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerIntPair =
            AnswerIntPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_int_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerIntPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerIntPair::class.java) return false
    
            other as AnswerIntPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class IntAnswerPair(
        val first: org.partiql.pig.runtime.LongPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): IntAnswerPair =
            IntAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("int_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            IntAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != IntAnswerPair::class.java) return false
    
            other as IntAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SymbolAnswerPair(
        val first: org.partiql.pig.runtime.SymbolPrimitive,
        val second: Answer,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SymbolAnswerPair =
            SymbolAnswerPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("symbol_answer_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.SymbolPrimitive = this.first,
            second: Answer = this.second,
            metas: MetaContainer = this.metas
        ) =
            SymbolAnswerPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SymbolAnswerPair::class.java) return false
    
            other as SymbolAnswerPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AnswerSymbolPair(
        val first: Answer,
        val second: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AnswerSymbolPair =
            AnswerSymbolPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("answer_symbol_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Answer = this.first,
            second: org.partiql.pig.runtime.SymbolPrimitive = this.second,
            metas: MetaContainer = this.metas
        ) =
            AnswerSymbolPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AnswerSymbolPair::class.java) return false
    
            other as AnswerSymbolPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin0(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin0 =
            VariadicMin0(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_0"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin0(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin0::class.java) return false
    
            other as VariadicMin0
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class VariadicMin1(
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): VariadicMin1 =
            VariadicMin1(
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("variadic_min_1"),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            VariadicMin1(
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != VariadicMin1::class.java) return false
    
            other as VariadicMin1
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ElementVariadic(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ElementVariadic =
            ElementVariadic(
                name = name,
                ints = ints,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("element_variadic"),
                name.toIonElement(),
                *ints.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            ints: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.ints,
            metas: MetaContainer = this.metas
        ) =
            ElementVariadic(
                name,
                ints,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ElementVariadic::class.java) return false
    
            other as ElementVariadic
            if (name != other.name) return false
            if (ints != other.ints) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = name.hashCode()
            hc = 31 * hc + ints.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional1(
        val value: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): Optional1 =
            Optional1(
                value = value,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional1 =
            Optional1(
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_1"),
                value?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive? = this.value,
            metas: MetaContainer = this.metas
        ) =
            Optional1(
                value,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional1::class.java) return false
    
            other as Optional1
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Optional2(
        val first: org.partiql.pig.runtime.LongPrimitive?,
        val second: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Optional2 =
            Optional2(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("optional_2"),
                first?.toIonElement() ?: ionNull(),
                second?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: org.partiql.pig.runtime.LongPrimitive? = this.first,
            second: org.partiql.pig.runtime.LongPrimitive? = this.second,
            metas: MetaContainer = this.metas
        ) =
            Optional2(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Optional2::class.java) return false
    
            other as Optional2
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DomainLevelRecord(
        val someField: org.partiql.pig.runtime.LongPrimitive,
        val anotherField: org.partiql.pig.runtime.SymbolPrimitive,
        val optionalField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): DomainLevelRecord =
            DomainLevelRecord(
                someField = someField,
                anotherField = anotherField,
                optionalField = optionalField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("domain_level_record"),
                someField?.let { ionSexpOf(ionSymbol("some_field"), it.toIonElement()) },
                anotherField?.let { ionSexpOf(ionSymbol("another_field"), it.toIonElement()) },
                optionalField?.let { ionSexpOf(ionSymbol("optional_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            someField: org.partiql.pig.runtime.LongPrimitive = this.someField,
            anotherField: org.partiql.pig.runtime.SymbolPrimitive = this.anotherField,
            optionalField: org.partiql.pig.runtime.LongPrimitive? = this.optionalField,
            metas: MetaContainer = this.metas
        ) =
            DomainLevelRecord(
                someField,
                anotherField,
                optionalField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DomainLevelRecord::class.java) return false
    
            other as DomainLevelRecord
            if (someField != other.someField) return false
            if (anotherField != other.anotherField) return false
            if (optionalField != other.optionalField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = someField.hashCode()
            hc = 31 * hc + anotherField.hashCode()
            hc = 31 * hc + optionalField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductWithRecord(
        val value: org.partiql.pig.runtime.LongPrimitive,
        val dlr: DomainLevelRecord,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductWithRecord =
            ProductWithRecord(
                value = value,
                dlr = dlr,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_with_record"),
                value.toIonElement(),
                dlr.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: org.partiql.pig.runtime.LongPrimitive = this.value,
            dlr: DomainLevelRecord = this.dlr,
            metas: MetaContainer = this.metas
        ) =
            ProductWithRecord(
                value,
                dlr,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductWithRecord::class.java) return false
    
            other as ProductWithRecord
            if (value != other.value) return false
            if (dlr != other.dlr) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = value.hashCode()
            hc = 31 * hc + dlr.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class TestSumTriplet(
        val a: TestSum,
        val b: TestSum,
        val c: TestSum,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): TestSumTriplet =
            TestSumTriplet(
                a = a,
                b = b,
                c = c,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("test_sum_triplet"),
                a.toIonElement(),
                b.toIonElement(),
                c.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            a: TestSum = this.a,
            b: TestSum = this.b,
            c: TestSum = this.c,
            metas: MetaContainer = this.metas
        ) =
            TestSumTriplet(
                a,
                b,
                c,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TestSumTriplet::class.java) return false
    
            other as TestSumTriplet
            if (a != other.a) return false
            if (b != other.b) return false
            if (c != other.c) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = a.hashCode()
            hc = 31 * hc + b.hashCode()
            hc = 31 * hc + c.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class EntityPair(
        val first: Entity,
        val second: Entity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): TestDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): EntityPair =
            EntityPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("entity_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Entity = this.first,
            second: Entity = this.second,
            metas: MetaContainer = this.metas
        ) =
            EntityPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != EntityPair::class.java) return false
    
            other as EntityPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Answer(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copyMetas(newMetas: MetaContainer): Answer =
            when (this) {
                is No -> copy(metas = newMetas)
                is Yes -> copy(metas = newMetas)
            }
    
        class No(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copyMetas(newMetas: MetaContainer): No =
                No(
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): No =
                No(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("no"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas
            ) =
                No(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != No::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Yes(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Answer() {
        
            override fun copyMetas(newMetas: MetaContainer): Yes =
                Yes(
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Yes =
                Yes(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("yes"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas
            ) =
                Yes(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Yes::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
    }
    
    sealed class SumWithRecord(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copyMetas(newMetas: MetaContainer): SumWithRecord =
            when (this) {
                is VariantWithRecord -> copy(metas = newMetas)
            }
    
        class VariantWithRecord(
            val value: org.partiql.pig.runtime.LongPrimitive,
            val dlr: DomainLevelRecord,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumWithRecord() {
        
            override fun copyMetas(newMetas: MetaContainer): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): VariantWithRecord =
                VariantWithRecord(
                    value = value,
                    dlr = dlr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variant_with_record"),
                    value.toIonElement(),
                    dlr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                dlr: DomainLevelRecord = this.dlr,
                metas: MetaContainer = this.metas
            ) =
                VariantWithRecord(
                    value,
                    dlr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != VariantWithRecord::class.java) return false
        
                other as VariantWithRecord
                if (value != other.value) return false
                if (dlr != other.dlr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = value.hashCode()
                hc = 31 * hc + dlr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class TestSum(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copyMetas(newMetas: MetaContainer): TestSum =
            when (this) {
                is One -> copy(metas = newMetas)
                is Two -> copy(metas = newMetas)
                is Three -> copy(metas = newMetas)
            }
    
        class One(
            val a: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copyMetas(newMetas: MetaContainer): One =
                One(
                    a = a,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): One =
                One(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("one"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                metas: MetaContainer = this.metas
            ) =
                One(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != One::class.java) return false
        
                other as One
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Two(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copyMetas(newMetas: MetaContainer): Two =
                Two(
                    a = a,
                    b = b,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Two =
                Two(
                    a = a,
                    b = b,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("two"),
                    a.toIonElement(),
                    b.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                metas: MetaContainer = this.metas
            ) =
                Two(
                    a,
                    b,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Two::class.java) return false
        
                other as Two
                if (a != other.a) return false
                if (b != other.b) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Three(
            val a: org.partiql.pig.runtime.LongPrimitive,
            val b: org.partiql.pig.runtime.LongPrimitive,
            val c: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): TestSum() {
        
            override fun copyMetas(newMetas: MetaContainer): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Three =
                Three(
                    a = a,
                    b = b,
                    c = c,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("three"),
                    a.toIonElement(),
                    b.toIonElement(),
                    c.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: org.partiql.pig.runtime.LongPrimitive = this.a,
                b: org.partiql.pig.runtime.LongPrimitive = this.b,
                c: org.partiql.pig.runtime.LongPrimitive = this.c,
                metas: MetaContainer = this.metas
            ) =
                Three(
                    a,
                    b,
                    c,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Three::class.java) return false
        
                other as Three
                if (a != other.a) return false
                if (b != other.b) return false
                if (c != other.c) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = a.hashCode()
                hc = 31 * hc + b.hashCode()
                hc = 31 * hc + c.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    sealed class Entity(override val metas: MetaContainer = emptyMetaContainer()) : TestDomainNode() {
        override fun copyMetas(newMetas: MetaContainer): Entity =
            when (this) {
                is Slug -> copy(metas = newMetas)
                is Android -> copy(metas = newMetas)
                is Human -> copy(metas = newMetas)
            }
    
        class Slug(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copyMetas(newMetas: MetaContainer): Slug =
                Slug(
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Slug =
                Slug(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("slug"),
                    metas = metas)
                return elements
            }
        
            fun copy(
                metas: MetaContainer = this.metas
            ) =
                Slug(
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Slug::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class Android(
            val id: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copyMetas(newMetas: MetaContainer): Android =
                Android(
                    id = id,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Android =
                Android(
                    id = id,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("android"),
                    id.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                id: org.partiql.pig.runtime.LongPrimitive = this.id,
                metas: MetaContainer = this.metas
            ) =
                Android(
                    id,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Android::class.java) return false
        
                other as Android
                if (id != other.id) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = id.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Human(
            val firstName: org.partiql.pig.runtime.SymbolPrimitive,
            val lastName: org.partiql.pig.runtime.SymbolPrimitive,
            val title: org.partiql.pig.runtime.SymbolPrimitive?,
            val parent: Entity?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Entity() {
        
            override fun copyMetas(newMetas: MetaContainer): Human =
                Human(
                    firstName = firstName,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Human =
                Human(
                    firstName = firstName,
                    lastName = lastName,
                    title = title,
                    parent = parent,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("human"),
                    firstName?.let { ionSexpOf(ionSymbol("first_name"), it.toIonElement()) },
                    lastName?.let { ionSexpOf(ionSymbol("last_name"), it.toIonElement()) },
                    title?.let { ionSexpOf(ionSymbol("title"), it.toIonElement()) },
                    parent?.let { ionSexpOf(ionSymbol("parent"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                firstName: org.partiql.pig.runtime.SymbolPrimitive = this.firstName,
                lastName: org.partiql.pig.runtime.SymbolPrimitive = this.lastName,
                title: org.partiql.pig.runtime.SymbolPrimitive? = this.title,
                parent: Entity? = this.parent,
                metas: MetaContainer = this.metas
            ) =
                Human(
                    firstName,
                    lastName,
                    title,
                    parent,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Human::class.java) return false
        
                other as Human
                if (firstName != other.firstName) return false
                if (lastName != other.lastName) return false
                if (title != other.title) return false
                if (parent != other.parent) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = firstName.hashCode()
                hc = 31 * hc + lastName.hashCode()
                hc = 31 * hc + title.hashCode()
                hc = 31 * hc + parent.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<TestDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): TestDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.SymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.IntSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.SymbolIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.IonIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequiredIon(0)
                    val second = sexp.getRequiredIon(1)
                    TestDomain.IonSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IntPair>()
                    val second = sexp.getRequired(1).transformExpect<IntPair>()
                    TestDomain.IntPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<SymbolPair>()
                    val second = sexp.getRequired(1).transformExpect<SymbolPair>()
                    TestDomain.SymbolPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "ion_pair_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<IonPair>()
                    val second = sexp.getRequired(1).transformExpect<IonPair>()
                    TestDomain.IonPairPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "recursive_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getOptional(1)?.transformExpect<RecursivePair>()
                    TestDomain.RecursivePair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.AnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_int_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.AnswerIntPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "int_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toLongPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.IntAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "symbol_answer_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).toSymbolPrimitive()
                    val second = sexp.getRequired(1).transformExpect<Answer>()
                    TestDomain.SymbolAnswerPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "answer_symbol_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Answer>()
                    val second = sexp.getRequired(1).toSymbolPrimitive()
                    TestDomain.AnswerSymbolPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "variadic_min_0" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin0(
                        ints,
                        metas = sexp.metas)
                }
                "variadic_min_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ints = sexp.values.drop(1).map { it.toLongPrimitive() }
                    TestDomain.VariadicMin1(
                        ints,
                        metas = sexp.metas)
                }
                "element_variadic" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val ints = sexp.values.drop(2).map { it.toLongPrimitive() }
                    TestDomain.ElementVariadic(
                        name,
                        ints,
                        metas = sexp.metas)
                }
                "optional_1" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val value = sexp.getOptional(0)?.toLongPrimitive()
                    TestDomain.Optional1(
                        value,
                        metas = sexp.metas)
                }
                "optional_2" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val first = sexp.getOptional(0)?.toLongPrimitive()
                    val second = sexp.getOptional(1)?.toLongPrimitive()
                    TestDomain.Optional2(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "domain_level_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val someField = ir.processRequiredField("some_field") { it.toLongPrimitive() }
                    val anotherField = ir.processRequiredField("another_field") { it.toSymbolPrimitive() }
                    val optionalField = ir.processOptionalField("optional_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DomainLevelRecord(someField, anotherField, optionalField, metas = sexp.metas)
                }
                "product_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.ProductWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                "test_sum_triplet" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).transformExpect<TestSum>()
                    val b = sexp.getRequired(1).transformExpect<TestSum>()
                    val c = sexp.getRequired(2).transformExpect<TestSum>()
                    TestDomain.TestSumTriplet(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                "entity_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Entity>()
                    val second = sexp.getRequired(1).transformExpect<Entity>()
                    TestDomain.EntityPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Answer'
                //////////////////////////////////////
                "no" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.No(
                        metas = sexp.metas)
                }
                "yes" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Answer.Yes(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumWithRecord'
                //////////////////////////////////////
                "variant_with_record" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    val dlr = sexp.getRequired(1).transformExpect<DomainLevelRecord>()
                    TestDomain.SumWithRecord.VariantWithRecord(
                        value,
                        dlr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'TestSum'
                //////////////////////////////////////
                "one" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.TestSum.One(
                        a,
                        metas = sexp.metas)
                }
                "two" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    TestDomain.TestSum.Two(
                        a,
                        b,
                        metas = sexp.metas)
                }
                "three" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val a = sexp.getRequired(0).toLongPrimitive()
                    val b = sexp.getRequired(1).toLongPrimitive()
                    val c = sexp.getRequired(2).toLongPrimitive()
                    TestDomain.TestSum.Three(
                        a,
                        b,
                        c,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Entity'
                //////////////////////////////////////
                "slug" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    TestDomain.Entity.Slug(
                        metas = sexp.metas)
                }
                "android" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val id = sexp.getRequired(0).toLongPrimitive()
                    TestDomain.Entity.Android(
                        id,
                        metas = sexp.metas)
                }
                "human" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val firstName = ir.processRequiredField("first_name") { it.toSymbolPrimitive() }
                    val lastName = ir.processRequiredField("last_name") { it.toSymbolPrimitive() }
                    val title = ir.processOptionalField("title") { it.toSymbolPrimitive() }
                    val parent = ir.processOptionalField("parent") { it.transformExpect<Entity>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Entity.Human(firstName, lastName, title, parent, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'test_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitIntPair(node: TestDomain.IntPair) { }
        open fun visitSymbolPair(node: TestDomain.SymbolPair) { }
        open fun visitIonPair(node: TestDomain.IonPair) { }
        open fun visitIntSymbolPair(node: TestDomain.IntSymbolPair) { }
        open fun visitSymbolIntPair(node: TestDomain.SymbolIntPair) { }
        open fun visitIonIntPair(node: TestDomain.IonIntPair) { }
        open fun visitIonSymbolPair(node: TestDomain.IonSymbolPair) { }
        open fun visitIntPairPair(node: TestDomain.IntPairPair) { }
        open fun visitSymbolPairPair(node: TestDomain.SymbolPairPair) { }
        open fun visitIonPairPair(node: TestDomain.IonPairPair) { }
        open fun visitRecursivePair(node: TestDomain.RecursivePair) { }
        open fun visitAnswerPair(node: TestDomain.AnswerPair) { }
        open fun visitAnswerIntPair(node: TestDomain.AnswerIntPair) { }
        open fun visitIntAnswerPair(node: TestDomain.IntAnswerPair) { }
        open fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) { }
        open fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) { }
        open fun visitVariadicMin0(node: TestDomain.VariadicMin0) { }
        open fun visitVariadicMin1(node: TestDomain.VariadicMin1) { }
        open fun visitElementVariadic(node: TestDomain.ElementVariadic) { }
        open fun visitOptional1(node: TestDomain.Optional1) { }
        open fun visitOptional2(node: TestDomain.Optional2) { }
        open fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord) { }
        open fun visitProductWithRecord(node: TestDomain.ProductWithRecord) { }
        open fun visitTestSumTriplet(node: TestDomain.TestSumTriplet) { }
        open fun visitEntityPair(node: TestDomain.EntityPair) { }
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        protected open fun visitAnswer(node: TestDomain.Answer) { }
        protected open fun visitAnswerNo(node: TestDomain.Answer.No) { }
        protected open fun visitAnswerYes(node: TestDomain.Answer.Yes) { }
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        protected open fun visitSumWithRecord(node: TestDomain.SumWithRecord) { }
        protected open fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) { }
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        protected open fun visitTestSum(node: TestDomain.TestSum) { }
        protected open fun visitTestSumOne(node: TestDomain.TestSum.One) { }
        protected open fun visitTestSumTwo(node: TestDomain.TestSum.Two) { }
        protected open fun visitTestSumThree(node: TestDomain.TestSum.Three) { }
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        protected open fun visitEntity(node: TestDomain.Entity) { }
        protected open fun visitEntitySlug(node: TestDomain.Entity.Slug) { }
        protected open fun visitEntityAndroid(node: TestDomain.Entity.Android) { }
        protected open fun visitEntityHuman(node: TestDomain.Entity.Human) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkIntPair(node: TestDomain.IntPair) {
            visitIntPair(node)
            walkLongPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair) {
            visitSymbolPair(node)
            walkSymbolPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPair(node: TestDomain.IonPair) {
            visitIonPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair) {
            visitIntSymbolPair(node)
            walkLongPrimitive(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair) {
            visitSymbolIntPair(node)
            walkSymbolPrimitive(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair) {
            visitIonIntPair(node)
            walkAnyElement(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair) {
            visitIonSymbolPair(node)
            walkAnyElement(node.first)
            walkAnyElement(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair) {
            visitIntPairPair(node)
            walkIntPair(node.first)
            walkIntPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair) {
            visitSymbolPairPair(node)
            walkSymbolPair(node.first)
            walkSymbolPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair) {
            visitIonPairPair(node)
            walkIonPair(node.first)
            walkIonPair(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair) {
            visitRecursivePair(node)
            walkLongPrimitive(node.first)
            node.second?.let { walkRecursivePair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair) {
            visitAnswerPair(node)
            walkAnswer(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair) {
            visitAnswerIntPair(node)
            walkAnswer(node.first)
            walkLongPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair) {
            visitIntAnswerPair(node)
            walkLongPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair) {
            visitSymbolAnswerPair(node)
            walkSymbolPrimitive(node.first)
            walkAnswer(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair) {
            visitAnswerSymbolPair(node)
            walkAnswer(node.first)
            walkSymbolPrimitive(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0) {
            visitVariadicMin0(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1) {
            visitVariadicMin1(node)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic) {
            visitElementVariadic(node)
            walkSymbolPrimitive(node.name)
            node.ints.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional1(node: TestDomain.Optional1) {
            visitOptional1(node)
            node.value?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOptional2(node: TestDomain.Optional2) {
            visitOptional2(node)
            node.first?.let { walkLongPrimitive(it) }
            node.second?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord) {
            visitDomainLevelRecord(node)
            walkLongPrimitive(node.someField)
            walkSymbolPrimitive(node.anotherField)
            node.optionalField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord) {
            visitProductWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet) {
            visitTestSumTriplet(node)
            walkTestSum(node.a)
            walkTestSum(node.b)
            walkTestSum(node.c)
            walkMetas(node.metas)
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair) {
            visitEntityPair(node)
            walkEntity(node.first)
            walkEntity(node.second)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer) {
            visitAnswer(node)
            when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node)
                is TestDomain.Answer.Yes -> walkAnswerYes(node)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No) {
            visitAnswerNo(node)
            walkMetas(node.metas)
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes) {
            visitAnswerYes(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord) {
            visitSumWithRecord(node)
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord) {
            visitSumWithRecordVariantWithRecord(node)
            walkLongPrimitive(node.value)
            walkDomainLevelRecord(node.dlr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum) {
            visitTestSum(node)
            when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node)
                is TestDomain.TestSum.Three -> walkTestSumThree(node)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One) {
            visitTestSumOne(node)
            walkLongPrimitive(node.a)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two) {
            visitTestSumTwo(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkMetas(node.metas)
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three) {
            visitTestSumThree(node)
            walkLongPrimitive(node.a)
            walkLongPrimitive(node.b)
            walkLongPrimitive(node.c)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity) {
            visitEntity(node)
            when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node)
                is TestDomain.Entity.Android -> walkEntityAndroid(node)
                is TestDomain.Entity.Human -> walkEntityHuman(node)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug) {
            visitEntitySlug(node)
            walkMetas(node.metas)
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android) {
            visitEntityAndroid(node)
            walkLongPrimitive(node.id)
            walkMetas(node.metas)
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human) {
            visitEntityHuman(node)
            walkSymbolPrimitive(node.firstName)
            walkSymbolPrimitive(node.lastName)
            node.title?.let { walkSymbolPrimitive(it) }
            node.parent?.let { walkEntity(it) }
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitIntPair(node: TestDomain.IntPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T = accumulator
        open protected fun visitIonPair(node: TestDomain.IonPair, accumulator: T): T = accumulator
        open protected fun visitIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T = accumulator
        open protected fun visitSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T = accumulator
        open protected fun visitIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T = accumulator
        open protected fun visitIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T = accumulator
        open protected fun visitIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T = accumulator
        open protected fun visitSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T = accumulator
        open protected fun visitIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T = accumulator
        open protected fun visitRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T = accumulator
        open protected fun visitAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T = accumulator
        open protected fun visitIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T = accumulator
        open protected fun visitSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T = accumulator
        open protected fun visitAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T = accumulator
        open protected fun visitVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T = accumulator
        open protected fun visitVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T = accumulator
        open protected fun visitElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T = accumulator
        open protected fun visitOptional1(node: TestDomain.Optional1, accumulator: T): T = accumulator
        open protected fun visitOptional2(node: TestDomain.Optional2, accumulator: T): T = accumulator
        open protected fun visitDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T = accumulator
        open protected fun visitProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T = accumulator
        open protected fun visitTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T = accumulator
        open protected fun visitEntityPair(node: TestDomain.EntityPair, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open protected fun visitAnswer(node: TestDomain.Answer, accumulator: T): T = accumulator
        open protected fun visitAnswerNo(node: TestDomain.Answer.No, accumulator: T): T = accumulator
        open protected fun visitAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open protected fun visitSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T = accumulator
        open protected fun visitSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open protected fun visitTestSum(node: TestDomain.TestSum, accumulator: T): T = accumulator
        open protected fun visitTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T = accumulator
        open protected fun visitTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T = accumulator
        open protected fun visitTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open protected fun visitEntity(node: TestDomain.Entity, accumulator: T): T = accumulator
        open protected fun visitEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T = accumulator
        open protected fun visitEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T = accumulator
        open protected fun visitEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkIntPair(node: TestDomain.IntPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPair(node: TestDomain.SymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPair(node: TestDomain.IonPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntSymbolPair(node: TestDomain.IntSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIntSymbolPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolIntPair(node: TestDomain.SymbolIntPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolIntPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonIntPair(node: TestDomain.IonIntPair, accumulator: T): T {
            var current = accumulator
            current = visitIonIntPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonSymbolPair(node: TestDomain.IonSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitIonSymbolPair(node, current)
            current = walkAnyElement(node.first, current)
            current = walkAnyElement(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntPairPair(node: TestDomain.IntPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIntPairPair(node, current)
            current = walkIntPair(node.first, current)
            current = walkIntPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolPairPair(node: TestDomain.SymbolPairPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolPairPair(node, current)
            current = walkSymbolPair(node.first, current)
            current = walkSymbolPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIonPairPair(node: TestDomain.IonPairPair, accumulator: T): T {
            var current = accumulator
            current = visitIonPairPair(node, current)
            current = walkIonPair(node.first, current)
            current = walkIonPair(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecursivePair(node: TestDomain.RecursivePair, accumulator: T): T {
            var current = accumulator
            current = visitRecursivePair(node, current)
            current = walkLongPrimitive(node.first, current)
            node.second?.let { current = walkRecursivePair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerPair(node: TestDomain.AnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerIntPair(node: TestDomain.AnswerIntPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerIntPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkLongPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIntAnswerPair(node: TestDomain.IntAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitIntAnswerPair(node, current)
            current = walkLongPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSymbolAnswerPair(node: TestDomain.SymbolAnswerPair, accumulator: T): T {
            var current = accumulator
            current = visitSymbolAnswerPair(node, current)
            current = walkSymbolPrimitive(node.first, current)
            current = walkAnswer(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerSymbolPair(node: TestDomain.AnswerSymbolPair, accumulator: T): T {
            var current = accumulator
            current = visitAnswerSymbolPair(node, current)
            current = walkAnswer(node.first, current)
            current = walkSymbolPrimitive(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin0(node: TestDomain.VariadicMin0, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin0(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkVariadicMin1(node: TestDomain.VariadicMin1, accumulator: T): T {
            var current = accumulator
            current = visitVariadicMin1(node, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkElementVariadic(node: TestDomain.ElementVariadic, accumulator: T): T {
            var current = accumulator
            current = visitElementVariadic(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.ints.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional1(node: TestDomain.Optional1, accumulator: T): T {
            var current = accumulator
            current = visitOptional1(node, current)
            node.value?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOptional2(node: TestDomain.Optional2, accumulator: T): T {
            var current = accumulator
            current = visitOptional2(node, current)
            node.first?.let { current = walkLongPrimitive(it, current) }
            node.second?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDomainLevelRecord(node: TestDomain.DomainLevelRecord, accumulator: T): T {
            var current = accumulator
            current = visitDomainLevelRecord(node, current)
            current = walkLongPrimitive(node.someField, current)
            current = walkSymbolPrimitive(node.anotherField, current)
            node.optionalField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductWithRecord(node: TestDomain.ProductWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitProductWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTriplet(node: TestDomain.TestSumTriplet, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTriplet(node, current)
            current = walkTestSum(node.a, current)
            current = walkTestSum(node.b, current)
            current = walkTestSum(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityPair(node: TestDomain.EntityPair, accumulator: T): T {
            var current = accumulator
            current = visitEntityPair(node, current)
            current = walkEntity(node.first, current)
            current = walkEntity(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun walkAnswer(node: TestDomain.Answer, accumulator: T): T {
            val current = visitAnswer(node, accumulator)
            return when(node) {
                is TestDomain.Answer.No -> walkAnswerNo(node, current)
                is TestDomain.Answer.Yes -> walkAnswerYes(node, current)
            }
        }
    
        open fun walkAnswerNo(node: TestDomain.Answer.No, accumulator: T): T {
            var current = accumulator
            current = visitAnswerNo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAnswerYes(node: TestDomain.Answer.Yes, accumulator: T): T {
            var current = accumulator
            current = visitAnswerYes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun walkSumWithRecord(node: TestDomain.SumWithRecord, accumulator: T): T {
            val current = visitSumWithRecord(node, accumulator)
            return when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> walkSumWithRecordVariantWithRecord(node, current)
            }
        }
    
        open fun walkSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord, accumulator: T): T {
            var current = accumulator
            current = visitSumWithRecordVariantWithRecord(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkDomainLevelRecord(node.dlr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun walkTestSum(node: TestDomain.TestSum, accumulator: T): T {
            val current = visitTestSum(node, accumulator)
            return when(node) {
                is TestDomain.TestSum.One -> walkTestSumOne(node, current)
                is TestDomain.TestSum.Two -> walkTestSumTwo(node, current)
                is TestDomain.TestSum.Three -> walkTestSumThree(node, current)
            }
        }
    
        open fun walkTestSumOne(node: TestDomain.TestSum.One, accumulator: T): T {
            var current = accumulator
            current = visitTestSumOne(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumTwo(node: TestDomain.TestSum.Two, accumulator: T): T {
            var current = accumulator
            current = visitTestSumTwo(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTestSumThree(node: TestDomain.TestSum.Three, accumulator: T): T {
            var current = accumulator
            current = visitTestSumThree(node, current)
            current = walkLongPrimitive(node.a, current)
            current = walkLongPrimitive(node.b, current)
            current = walkLongPrimitive(node.c, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun walkEntity(node: TestDomain.Entity, accumulator: T): T {
            val current = visitEntity(node, accumulator)
            return when(node) {
                is TestDomain.Entity.Slug -> walkEntitySlug(node, current)
                is TestDomain.Entity.Android -> walkEntityAndroid(node, current)
                is TestDomain.Entity.Human -> walkEntityHuman(node, current)
            }
        }
    
        open fun walkEntitySlug(node: TestDomain.Entity.Slug, accumulator: T): T {
            var current = accumulator
            current = visitEntitySlug(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityAndroid(node: TestDomain.Entity.Android, accumulator: T): T {
            var current = accumulator
            current = visitEntityAndroid(node, current)
            current = walkLongPrimitive(node.id, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkEntityHuman(node: TestDomain.Entity.Human, accumulator: T): T {
            var current = accumulator
            current = visitEntityHuman(node, current)
            current = walkSymbolPrimitive(node.firstName, current)
            current = walkSymbolPrimitive(node.lastName, current)
            node.title?.let { current = walkSymbolPrimitive(it, current) }
            node.parent?.let { current = walkEntity(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple IntPair
        open fun transformIntPair(node: IntPair): IntPair {
            val new_first = transformIntPair_first(node)
            val new_second = transformIntPair_second(node)
            val new_metas = transformIntPair_metas(node)
            return build {
                IntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntPair_first(node: IntPair) =
            transformLongPrimitive(node.first)
        open fun transformIntPair_second(node: IntPair) =
            transformLongPrimitive(node.second)
        open fun transformIntPair_metas(node: IntPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPair
        open fun transformSymbolPair(node: SymbolPair): SymbolPair {
            val new_first = transformSymbolPair_first(node)
            val new_second = transformSymbolPair_second(node)
            val new_metas = transformSymbolPair_metas(node)
            return build {
                SymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolPair_first(node: SymbolPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolPair_second(node: SymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformSymbolPair_metas(node: SymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IonPair
        open fun transformIonPair(node: IonPair): IonPair {
            val new_first = transformIonPair_first(node)
            val new_second = transformIonPair_second(node)
            val new_metas = transformIonPair_metas(node)
            return build {
                IonPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonPair_first(node: IonPair) =
            transformAnyElement(node.first)
        open fun transformIonPair_second(node: IonPair) =
            transformAnyElement(node.second)
        open fun transformIonPair_metas(node: IonPair) =
            transformMetas(node.metas)
    
        // Tuple IntSymbolPair
        open fun transformIntSymbolPair(node: IntSymbolPair): IntSymbolPair {
            val new_first = transformIntSymbolPair_first(node)
            val new_second = transformIntSymbolPair_second(node)
            val new_metas = transformIntSymbolPair_metas(node)
            return build {
                IntSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntSymbolPair_first(node: IntSymbolPair) =
            transformLongPrimitive(node.first)
        open fun transformIntSymbolPair_second(node: IntSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformIntSymbolPair_metas(node: IntSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolIntPair
        open fun transformSymbolIntPair(node: SymbolIntPair): SymbolIntPair {
            val new_first = transformSymbolIntPair_first(node)
            val new_second = transformSymbolIntPair_second(node)
            val new_metas = transformSymbolIntPair_metas(node)
            return build {
                SymbolIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolIntPair_first(node: SymbolIntPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolIntPair_second(node: SymbolIntPair) =
            transformLongPrimitive(node.second)
        open fun transformSymbolIntPair_metas(node: SymbolIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonIntPair
        open fun transformIonIntPair(node: IonIntPair): IonIntPair {
            val new_first = transformIonIntPair_first(node)
            val new_second = transformIonIntPair_second(node)
            val new_metas = transformIonIntPair_metas(node)
            return build {
                IonIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonIntPair_first(node: IonIntPair) =
            transformAnyElement(node.first)
        open fun transformIonIntPair_second(node: IonIntPair) =
            transformLongPrimitive(node.second)
        open fun transformIonIntPair_metas(node: IonIntPair) =
            transformMetas(node.metas)
    
        // Tuple IonSymbolPair
        open fun transformIonSymbolPair(node: IonSymbolPair): IonSymbolPair {
            val new_first = transformIonSymbolPair_first(node)
            val new_second = transformIonSymbolPair_second(node)
            val new_metas = transformIonSymbolPair_metas(node)
            return build {
                IonSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonSymbolPair_first(node: IonSymbolPair) =
            transformAnyElement(node.first)
        open fun transformIonSymbolPair_second(node: IonSymbolPair) =
            transformAnyElement(node.second)
        open fun transformIonSymbolPair_metas(node: IonSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple IntPairPair
        open fun transformIntPairPair(node: IntPairPair): IntPairPair {
            val new_first = transformIntPairPair_first(node)
            val new_second = transformIntPairPair_second(node)
            val new_metas = transformIntPairPair_metas(node)
            return build {
                IntPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntPairPair_first(node: IntPairPair) =
            transformIntPair(node.first)
        open fun transformIntPairPair_second(node: IntPairPair) =
            transformIntPair(node.second)
        open fun transformIntPairPair_metas(node: IntPairPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolPairPair
        open fun transformSymbolPairPair(node: SymbolPairPair): SymbolPairPair {
            val new_first = transformSymbolPairPair_first(node)
            val new_second = transformSymbolPairPair_second(node)
            val new_metas = transformSymbolPairPair_metas(node)
            return build {
                SymbolPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolPairPair_first(node: SymbolPairPair) =
            transformSymbolPair(node.first)
        open fun transformSymbolPairPair_second(node: SymbolPairPair) =
            transformSymbolPair(node.second)
        open fun transformSymbolPairPair_metas(node: SymbolPairPair) =
            transformMetas(node.metas)
    
        // Tuple IonPairPair
        open fun transformIonPairPair(node: IonPairPair): IonPairPair {
            val new_first = transformIonPairPair_first(node)
            val new_second = transformIonPairPair_second(node)
            val new_metas = transformIonPairPair_metas(node)
            return build {
                IonPairPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIonPairPair_first(node: IonPairPair) =
            transformIonPair(node.first)
        open fun transformIonPairPair_second(node: IonPairPair) =
            transformIonPair(node.second)
        open fun transformIonPairPair_metas(node: IonPairPair) =
            transformMetas(node.metas)
    
        // Tuple RecursivePair
        open fun transformRecursivePair(node: RecursivePair): RecursivePair {
            val new_first = transformRecursivePair_first(node)
            val new_second = transformRecursivePair_second(node)
            val new_metas = transformRecursivePair_metas(node)
            return build {
                RecursivePair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformRecursivePair_first(node: RecursivePair) =
            transformLongPrimitive(node.first)
        open fun transformRecursivePair_second(node: RecursivePair) =
            node.second?.let { transformRecursivePair(it) }
        open fun transformRecursivePair_metas(node: RecursivePair) =
            transformMetas(node.metas)
    
        // Tuple AnswerPair
        open fun transformAnswerPair(node: AnswerPair): AnswerPair {
            val new_first = transformAnswerPair_first(node)
            val new_second = transformAnswerPair_second(node)
            val new_metas = transformAnswerPair_metas(node)
            return build {
                AnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerPair_first(node: AnswerPair) =
            transformAnswer(node.first)
        open fun transformAnswerPair_second(node: AnswerPair) =
            transformAnswer(node.second)
        open fun transformAnswerPair_metas(node: AnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerIntPair
        open fun transformAnswerIntPair(node: AnswerIntPair): AnswerIntPair {
            val new_first = transformAnswerIntPair_first(node)
            val new_second = transformAnswerIntPair_second(node)
            val new_metas = transformAnswerIntPair_metas(node)
            return build {
                AnswerIntPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerIntPair_first(node: AnswerIntPair) =
            transformAnswer(node.first)
        open fun transformAnswerIntPair_second(node: AnswerIntPair) =
            transformLongPrimitive(node.second)
        open fun transformAnswerIntPair_metas(node: AnswerIntPair) =
            transformMetas(node.metas)
    
        // Tuple IntAnswerPair
        open fun transformIntAnswerPair(node: IntAnswerPair): IntAnswerPair {
            val new_first = transformIntAnswerPair_first(node)
            val new_second = transformIntAnswerPair_second(node)
            val new_metas = transformIntAnswerPair_metas(node)
            return build {
                IntAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformIntAnswerPair_first(node: IntAnswerPair) =
            transformLongPrimitive(node.first)
        open fun transformIntAnswerPair_second(node: IntAnswerPair) =
            transformAnswer(node.second)
        open fun transformIntAnswerPair_metas(node: IntAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple SymbolAnswerPair
        open fun transformSymbolAnswerPair(node: SymbolAnswerPair): SymbolAnswerPair {
            val new_first = transformSymbolAnswerPair_first(node)
            val new_second = transformSymbolAnswerPair_second(node)
            val new_metas = transformSymbolAnswerPair_metas(node)
            return build {
                SymbolAnswerPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformSymbolAnswerPair_first(node: SymbolAnswerPair) =
            transformSymbolPrimitive(node.first)
        open fun transformSymbolAnswerPair_second(node: SymbolAnswerPair) =
            transformAnswer(node.second)
        open fun transformSymbolAnswerPair_metas(node: SymbolAnswerPair) =
            transformMetas(node.metas)
    
        // Tuple AnswerSymbolPair
        open fun transformAnswerSymbolPair(node: AnswerSymbolPair): AnswerSymbolPair {
            val new_first = transformAnswerSymbolPair_first(node)
            val new_second = transformAnswerSymbolPair_second(node)
            val new_metas = transformAnswerSymbolPair_metas(node)
            return build {
                AnswerSymbolPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformAnswerSymbolPair_first(node: AnswerSymbolPair) =
            transformAnswer(node.first)
        open fun transformAnswerSymbolPair_second(node: AnswerSymbolPair) =
            transformSymbolPrimitive(node.second)
        open fun transformAnswerSymbolPair_metas(node: AnswerSymbolPair) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin0
        open fun transformVariadicMin0(node: VariadicMin0): VariadicMin0 {
            val new_ints = transformVariadicMin0_ints(node)
            val new_metas = transformVariadicMin0_metas(node)
            return build {
                VariadicMin0(
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformVariadicMin0_ints(node: VariadicMin0) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin0_metas(node: VariadicMin0) =
            transformMetas(node.metas)
    
        // Tuple VariadicMin1
        open fun transformVariadicMin1(node: VariadicMin1): VariadicMin1 {
            val new_ints = transformVariadicMin1_ints(node)
            val new_metas = transformVariadicMin1_metas(node)
            return build {
                VariadicMin1(
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformVariadicMin1_ints(node: VariadicMin1) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformVariadicMin1_metas(node: VariadicMin1) =
            transformMetas(node.metas)
    
        // Tuple ElementVariadic
        open fun transformElementVariadic(node: ElementVariadic): ElementVariadic {
            val new_name = transformElementVariadic_name(node)
            val new_ints = transformElementVariadic_ints(node)
            val new_metas = transformElementVariadic_metas(node)
            return build {
                ElementVariadic(
                    name = new_name,
                    ints = new_ints,
                    metas = new_metas
                )
            }
        }
        open fun transformElementVariadic_name(node: ElementVariadic) =
            transformSymbolPrimitive(node.name)
        open fun transformElementVariadic_ints(node: ElementVariadic) =
            node.ints.map { transformLongPrimitive(it) }
        open fun transformElementVariadic_metas(node: ElementVariadic) =
            transformMetas(node.metas)
    
        // Tuple Optional1
        open fun transformOptional1(node: Optional1): Optional1 {
            val new_value = transformOptional1_value(node)
            val new_metas = transformOptional1_metas(node)
            return build {
                Optional1(
                    value = new_value,
                    metas = new_metas
                )
            }
        }
        open fun transformOptional1_value(node: Optional1) =
            node.value?.let { transformLongPrimitive(it) }
        open fun transformOptional1_metas(node: Optional1) =
            transformMetas(node.metas)
    
        // Tuple Optional2
        open fun transformOptional2(node: Optional2): Optional2 {
            val new_first = transformOptional2_first(node)
            val new_second = transformOptional2_second(node)
            val new_metas = transformOptional2_metas(node)
            return build {
                Optional2(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformOptional2_first(node: Optional2) =
            node.first?.let { transformLongPrimitive(it) }
        open fun transformOptional2_second(node: Optional2) =
            node.second?.let { transformLongPrimitive(it) }
        open fun transformOptional2_metas(node: Optional2) =
            transformMetas(node.metas)
    
        // Tuple DomainLevelRecord
        open fun transformDomainLevelRecord(node: DomainLevelRecord): DomainLevelRecord {
            val new_someField = transformDomainLevelRecord_someField(node)
            val new_anotherField = transformDomainLevelRecord_anotherField(node)
            val new_optionalField = transformDomainLevelRecord_optionalField(node)
            val new_metas = transformDomainLevelRecord_metas(node)
            return build {
                DomainLevelRecord(
                    someField = new_someField,
                    anotherField = new_anotherField,
                    optionalField = new_optionalField,
                    metas = new_metas
                )
            }
        }
        open fun transformDomainLevelRecord_someField(node: DomainLevelRecord) =
            transformLongPrimitive(node.someField)
        open fun transformDomainLevelRecord_anotherField(node: DomainLevelRecord) =
            transformSymbolPrimitive(node.anotherField)
        open fun transformDomainLevelRecord_optionalField(node: DomainLevelRecord) =
            node.optionalField?.let { transformLongPrimitive(it) }
        open fun transformDomainLevelRecord_metas(node: DomainLevelRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductWithRecord
        open fun transformProductWithRecord(node: ProductWithRecord): ProductWithRecord {
            val new_value = transformProductWithRecord_value(node)
            val new_dlr = transformProductWithRecord_dlr(node)
            val new_metas = transformProductWithRecord_metas(node)
            return build {
                ProductWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            }
        }
        open fun transformProductWithRecord_value(node: ProductWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformProductWithRecord_dlr(node: ProductWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformProductWithRecord_metas(node: ProductWithRecord) =
            transformMetas(node.metas)
    
        // Tuple TestSumTriplet
        open fun transformTestSumTriplet(node: TestSumTriplet): TestSumTriplet {
            val new_a = transformTestSumTriplet_a(node)
            val new_b = transformTestSumTriplet_b(node)
            val new_c = transformTestSumTriplet_c(node)
            val new_metas = transformTestSumTriplet_metas(node)
            return build {
                TestSumTriplet(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            }
        }
        open fun transformTestSumTriplet_a(node: TestSumTriplet) =
            transformTestSum(node.a)
        open fun transformTestSumTriplet_b(node: TestSumTriplet) =
            transformTestSum(node.b)
        open fun transformTestSumTriplet_c(node: TestSumTriplet) =
            transformTestSum(node.c)
        open fun transformTestSumTriplet_metas(node: TestSumTriplet) =
            transformMetas(node.metas)
    
        // Tuple EntityPair
        open fun transformEntityPair(node: EntityPair): EntityPair {
            val new_first = transformEntityPair_first(node)
            val new_second = transformEntityPair_second(node)
            val new_metas = transformEntityPair_metas(node)
            return build {
                EntityPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            }
        }
        open fun transformEntityPair_first(node: EntityPair) =
            transformEntity(node.first)
        open fun transformEntityPair_second(node: EntityPair) =
            transformEntity(node.second)
        open fun transformEntityPair_metas(node: EntityPair) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Answer
        //////////////////////////////////////
        open fun transformAnswer(node: TestDomain.Answer) =
            when(node) {
                is TestDomain.Answer.No -> transformAnswerNo(node)
                is TestDomain.Answer.Yes -> transformAnswerYes(node)
            }
        // Variant AnswerNo
        open fun transformAnswerNo(node: TestDomain.Answer.No): TestDomain.Answer {
            val new_metas = transformAnswerNo_metas(node)
            return build {
                Answer.No(
                    metas = new_metas
                )
            }
        }
    
        open fun transformAnswerNo_metas(node: Answer.No) =
            transformMetas(node.metas)
    
    
        // Variant AnswerYes
        open fun transformAnswerYes(node: TestDomain.Answer.Yes): TestDomain.Answer {
            val new_metas = transformAnswerYes_metas(node)
            return build {
                Answer.Yes(
                    metas = new_metas
                )
            }
        }
    
        open fun transformAnswerYes_metas(node: Answer.Yes) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: SumWithRecord
        //////////////////////////////////////
        open fun transformSumWithRecord(node: TestDomain.SumWithRecord) =
            when(node) {
                is TestDomain.SumWithRecord.VariantWithRecord -> transformSumWithRecordVariantWithRecord(node)
            }
        // Variant SumWithRecordVariantWithRecord
        open fun transformSumWithRecordVariantWithRecord(node: TestDomain.SumWithRecord.VariantWithRecord): TestDomain.SumWithRecord {
            val new_value = transformSumWithRecordVariantWithRecord_value(node)
            val new_dlr = transformSumWithRecordVariantWithRecord_dlr(node)
            val new_metas = transformSumWithRecordVariantWithRecord_metas(node)
            return build {
                SumWithRecord.VariantWithRecord(
                    value = new_value,
                    dlr = new_dlr,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSumWithRecordVariantWithRecord_value(node: SumWithRecord.VariantWithRecord) =
            transformLongPrimitive(node.value)
        open fun transformSumWithRecordVariantWithRecord_dlr(node: SumWithRecord.VariantWithRecord) =
            transformDomainLevelRecord(node.dlr)
        open fun transformSumWithRecordVariantWithRecord_metas(node: SumWithRecord.VariantWithRecord) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: TestSum
        //////////////////////////////////////
        open fun transformTestSum(node: TestDomain.TestSum) =
            when(node) {
                is TestDomain.TestSum.One -> transformTestSumOne(node)
                is TestDomain.TestSum.Two -> transformTestSumTwo(node)
                is TestDomain.TestSum.Three -> transformTestSumThree(node)
            }
        // Variant TestSumOne
        open fun transformTestSumOne(node: TestDomain.TestSum.One): TestDomain.TestSum {
            val new_a = transformTestSumOne_a(node)
            val new_metas = transformTestSumOne_metas(node)
            return build {
                TestSum.One(
                    a = new_a,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumOne_a(node: TestSum.One) =
            transformLongPrimitive(node.a)
        open fun transformTestSumOne_metas(node: TestSum.One) =
            transformMetas(node.metas)
    
    
        // Variant TestSumTwo
        open fun transformTestSumTwo(node: TestDomain.TestSum.Two): TestDomain.TestSum {
            val new_a = transformTestSumTwo_a(node)
            val new_b = transformTestSumTwo_b(node)
            val new_metas = transformTestSumTwo_metas(node)
            return build {
                TestSum.Two(
                    a = new_a,
                    b = new_b,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumTwo_a(node: TestSum.Two) =
            transformLongPrimitive(node.a)
        open fun transformTestSumTwo_b(node: TestSum.Two) =
            transformLongPrimitive(node.b)
        open fun transformTestSumTwo_metas(node: TestSum.Two) =
            transformMetas(node.metas)
    
    
        // Variant TestSumThree
        open fun transformTestSumThree(node: TestDomain.TestSum.Three): TestDomain.TestSum {
            val new_a = transformTestSumThree_a(node)
            val new_b = transformTestSumThree_b(node)
            val new_c = transformTestSumThree_c(node)
            val new_metas = transformTestSumThree_metas(node)
            return build {
                TestSum.Three(
                    a = new_a,
                    b = new_b,
                    c = new_c,
                    metas = new_metas
                )
            }
        }
    
        open fun transformTestSumThree_a(node: TestSum.Three) =
            transformLongPrimitive(node.a)
        open fun transformTestSumThree_b(node: TestSum.Three) =
            transformLongPrimitive(node.b)
        open fun transformTestSumThree_c(node: TestSum.Three) =
            transformLongPrimitive(node.c)
        open fun transformTestSumThree_metas(node: TestSum.Three) =
            transformMetas(node.metas)
    
    
        //////////////////////////////////////
        // Sum Type: Entity
        //////////////////////////////////////
        open fun transformEntity(node: TestDomain.Entity) =
            when(node) {
                is TestDomain.Entity.Slug -> transformEntitySlug(node)
                is TestDomain.Entity.Android -> transformEntityAndroid(node)
                is TestDomain.Entity.Human -> transformEntityHuman(node)
            }
        // Variant EntitySlug
        open fun transformEntitySlug(node: TestDomain.Entity.Slug): TestDomain.Entity {
            val new_metas = transformEntitySlug_metas(node)
            return build {
                Entity.Slug(
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntitySlug_metas(node: Entity.Slug) =
            transformMetas(node.metas)
    
    
        // Variant EntityAndroid
        open fun transformEntityAndroid(node: TestDomain.Entity.Android): TestDomain.Entity {
            val new_id = transformEntityAndroid_id(node)
            val new_metas = transformEntityAndroid_metas(node)
            return build {
                Entity.Android(
                    id = new_id,
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntityAndroid_id(node: Entity.Android) =
            transformLongPrimitive(node.id)
        open fun transformEntityAndroid_metas(node: Entity.Android) =
            transformMetas(node.metas)
    
    
        // Variant EntityHuman
        open fun transformEntityHuman(node: TestDomain.Entity.Human): TestDomain.Entity {
            val new_firstName = transformEntityHuman_firstName(node)
            val new_lastName = transformEntityHuman_lastName(node)
            val new_title = transformEntityHuman_title(node)
            val new_parent = transformEntityHuman_parent(node)
            val new_metas = transformEntityHuman_metas(node)
            return build {
                Entity.Human(
                    firstName = new_firstName,
                    lastName = new_lastName,
                    title = new_title,
                    parent = new_parent,
                    metas = new_metas
                )
            }
        }
    
        open fun transformEntityHuman_firstName(node: Entity.Human) =
            transformSymbolPrimitive(node.firstName)
        open fun transformEntityHuman_lastName(node: Entity.Human) =
            transformSymbolPrimitive(node.lastName)
        open fun transformEntityHuman_title(node: Entity.Human) =
            node.title?.let { transformSymbolPrimitive(it) }
        open fun transformEntityHuman_parent(node: Entity.Human) =
            node.parent?.let { transformEntity(it) }
        open fun transformEntityHuman_metas(node: Entity.Human) =
            transformMetas(node.metas)
    
    
    }
}

class MultiWordDomain private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = MultiWordDomainBuilder
    
        fun <T: MultiWordDomainNode> build(block: Builder.() -> T) =
            MultiWordDomainBuilder.block()
    
        fun transform(element: AnyElement): MultiWordDomainNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): MultiWordDomainNode =
            Transformer().transform(element)
    }
    
    interface Builder {
                // Tuples
        /**
         * Creates an instance of [MultiWordDomain.AaaAaa].
         */
        fun aaaAaa(
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAaa
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         */
        fun aaaAab(
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAab_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAab
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         */
        fun aaaAac(
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAac_(
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAac
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         */
        fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAad_(
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAad
        
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         */
        fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae
        
        /**
         * Creates an instance of [MultiWordDomain.AaaAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aaaAae_(
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AaaAae
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         */
        fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa
        
        /**
         * Creates an instance of [MultiWordDomain.AabAaa].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAaa_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAaa
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         */
        fun aabAab(
            bField: Long,
            cField: String,
            dField: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab
        
        /**
         * Creates an instance of [MultiWordDomain.AabAab].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAab_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAab
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         */
        fun aabAac(
            bField: Long,
            cField: String,
            dField: Long? = null,
            eField: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac
        
        /**
         * Creates an instance of [MultiWordDomain.AabAac].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAac_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive? = null,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAac
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         */
        fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad
        
        /**
         * Creates an instance of [MultiWordDomain.AabAad].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAad
        
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         */
        fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae
        
        /**
         * Creates an instance of [MultiWordDomain.AabAae].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.AabAae
        
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         */
        fun rrr(
            aField: Long,
            bbbField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr
        
        /**
         * Creates an instance of [MultiWordDomain.Rrr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun rrr_(
            aField: org.partiql.pig.runtime.LongPrimitive,
            bbbField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.Rrr
        
        
        // Variants for Sum: SssTtt 
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         */
        fun lll(
            uField: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Lll].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun lll_(
            uField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Lll
        
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         */
        fun mmm(
            vField: String,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm
        
        /**
         * Creates an instance of [MultiWordDomain.SssTtt.Mmm].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun mmm_(
            vField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): MultiWordDomain.SssTtt.Mmm
    }
    
    private object MultiWordDomainBuilder : Builder {
                // Tuples
        override fun aaaAaa(
            metas: MetaContainer
        ): MultiWordDomain.AaaAaa =
            MultiWordDomain.AaaAaa(
                metas = metas)
        
        
        override fun aaaAab(
            dField: Long?,
            metas: MetaContainer
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField?.asPrimitive(),
                metas = metas)
        
        override fun aaaAab_(
            dField: org.partiql.pig.runtime.LongPrimitive?,
            metas: MetaContainer
        ): MultiWordDomain.AaaAab =
            MultiWordDomain.AaaAab(
                dField = dField,
                metas = metas)
        
        
        override fun aaaAac(
            dField: Long?,
            eField: String?,
            metas: MetaContainer
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        override fun aaaAac_(
            dField: org.partiql.pig.runtime.LongPrimitive?,
            eField: org.partiql.pig.runtime.SymbolPrimitive?,
            metas: MetaContainer
        ): MultiWordDomain.AaaAac =
            MultiWordDomain.AaaAac(
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        override fun aaaAad(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aaaAad_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField,
                metas = metas)
        
        override fun aaaAad(
            vararg dField: Long,
            metas: MetaContainer
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aaaAad_(
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.AaaAad =
            MultiWordDomain.AaaAad(
                dField = dField.toList(),
                metas = metas)
        
        
        override fun aaaAae(
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aaaAae_(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = dField,
                metas = metas)
        
        override fun aaaAae(
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aaaAae_(
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.AaaAae =
            MultiWordDomain.AaaAae(
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        override fun aabAaa(
            bField: Long,
            cField: String,
            metas: MetaContainer
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                metas = metas)
        
        override fun aabAaa_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.AabAaa =
            MultiWordDomain.AabAaa(
                bField = bField,
                cField = cField,
                metas = metas)
        
        
        override fun aabAab(
            bField: Long,
            cField: String,
            dField: Long?,
            metas: MetaContainer
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                metas = metas)
        
        override fun aabAab_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive?,
            metas: MetaContainer
        ): MultiWordDomain.AabAab =
            MultiWordDomain.AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        
        override fun aabAac(
            bField: Long,
            cField: String,
            dField: Long?,
            eField: String?,
            metas: MetaContainer
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField?.asPrimitive(),
                eField = eField?.asPrimitive(),
                metas = metas)
        
        override fun aabAac_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: org.partiql.pig.runtime.LongPrimitive?,
            eField: org.partiql.pig.runtime.SymbolPrimitive?,
            metas: MetaContainer
        ): MultiWordDomain.AabAac =
            MultiWordDomain.AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas)
        
        
        override fun aabAad(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        override fun aabAad(
            bField: Long,
            cField: String,
            vararg dField: Long,
            metas: MetaContainer
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aabAad_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.AabAad =
            MultiWordDomain.AabAad(
                bField = bField,
                cField = cField,
                dField = dField.toList(),
                metas = metas)
        
        
        override fun aabAae(
            bField: Long,
            cField: String,
            dField: kotlin.collections.List<Long>,
            metas: MetaContainer
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
            metas: MetaContainer
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas)
        
        override fun aabAae(
            bField: Long,
            cField: String,
            dField0: Long,
            dField1: Long,
            vararg dField: Long,
            metas: MetaContainer
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField.asPrimitive(),
                cField = cField.asPrimitive(),
                dField = listOfPrimitives(dField0, dField1) + dField.map { it.asPrimitive() },
                metas = metas)
        
        override fun aabAae_(
            bField: org.partiql.pig.runtime.LongPrimitive,
            cField: org.partiql.pig.runtime.SymbolPrimitive,
            dField0: org.partiql.pig.runtime.LongPrimitive,
            dField1: org.partiql.pig.runtime.LongPrimitive,
            vararg dField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.AabAae =
            MultiWordDomain.AabAae(
                bField = bField,
                cField = cField,
                dField = listOfPrimitives(dField0, dField1) + dField.toList(),
                metas = metas)
        
        
        override fun rrr(
            aField: Long,
            bbbField: Long,
            metas: MetaContainer
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField.asPrimitive(),
                bbbField = bbbField.asPrimitive(),
                metas = metas)
        
        override fun rrr_(
            aField: org.partiql.pig.runtime.LongPrimitive,
            bbbField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.Rrr =
            MultiWordDomain.Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas)
        
        
        // Variants for Sum: SssTtt 
        override fun lll(
            uField: Long,
            metas: MetaContainer
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField.asPrimitive(),
                metas = metas)
        
        override fun lll_(
            uField: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.SssTtt.Lll =
            MultiWordDomain.SssTtt.Lll(
                uField = uField,
                metas = metas)
        
        
        override fun mmm(
            vField: String,
            metas: MetaContainer
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField.asPrimitive(),
                metas = metas)
        
        override fun mmm_(
            vField: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer
        ): MultiWordDomain.SssTtt.Mmm =
            MultiWordDomain.SssTtt.Mmm(
                vField = vField,
                metas = metas)
    }
    
    /** Base class for all MultiWordDomain types. */
    abstract class MultiWordDomainNode : DomainNode {
        abstract override fun copyMetas(newMetas: MetaContainer): MultiWordDomainNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): MultiWordDomainNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class AaaAaa(
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AaaAaa =
            AaaAaa(
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAaa =
            AaaAaa(
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aaa"),
                metas = metas)
            return elements
        }
    
        fun copy(
            metas: MetaContainer = this.metas
        ) =
            AaaAaa(
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAaa::class.java) return false
    
            return true
        }
    
        override fun hashCode(): Int = 0
    }
    
    class AaaAab(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AaaAab =
            AaaAab(
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAab =
            AaaAab(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aab"),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAab(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAab::class.java) return false
    
            other as AaaAab
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAac(
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAac =
            AaaAac(
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aac"),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas
        ) =
            AaaAac(
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAac::class.java) return false
    
            other as AaaAac
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAad(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AaaAad =
            AaaAad(
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAad =
            AaaAad(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aad"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAad(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAad::class.java) return false
    
            other as AaaAad
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AaaAae(
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AaaAae =
            AaaAae(
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AaaAae =
            AaaAae(
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aaa_aae"),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AaaAae(
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AaaAae::class.java) return false
    
            other as AaaAae
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAaa(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAaa =
            AabAaa(
                bField = bField,
                cField = cField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aaa"),
                bField.toIonElement(),
                cField.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            metas: MetaContainer = this.metas
        ) =
            AabAaa(
                bField,
                cField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAaa::class.java) return false
    
            other as AabAaa
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAab(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAab =
            AabAab(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aab"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAab(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAab::class.java) return false
    
            other as AabAab
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAac(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: org.partiql.pig.runtime.LongPrimitive?,
        val eField: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAac =
            AabAac(
                bField = bField,
                cField = cField,
                dField = dField,
                eField = eField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aac"),
                bField.toIonElement(),
                cField.toIonElement(),
                dField?.toIonElement() ?: ionNull(),
                eField?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: org.partiql.pig.runtime.LongPrimitive? = this.dField,
            eField: org.partiql.pig.runtime.SymbolPrimitive? = this.eField,
            metas: MetaContainer = this.metas
        ) =
            AabAac(
                bField,
                cField,
                dField,
                eField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAac::class.java) return false
    
            other as AabAac
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            if (eField != other.eField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc = 31 * hc + eField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAad(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAad =
            AabAad(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aad"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAad(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAad::class.java) return false
    
            other as AabAad
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class AabAae(
        val bField: org.partiql.pig.runtime.LongPrimitive,
        val cField: org.partiql.pig.runtime.SymbolPrimitive,
        val dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): AabAae =
            AabAae(
                bField = bField,
                cField = cField,
                dField = dField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("aab_aae"),
                bField.toIonElement(),
                cField.toIonElement(),
                *dField.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            bField: org.partiql.pig.runtime.LongPrimitive = this.bField,
            cField: org.partiql.pig.runtime.SymbolPrimitive = this.cField,
            dField: kotlin.collections.List<org.partiql.pig.runtime.LongPrimitive> = this.dField,
            metas: MetaContainer = this.metas
        ) =
            AabAae(
                bField,
                cField,
                dField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != AabAae::class.java) return false
    
            other as AabAae
            if (bField != other.bField) return false
            if (cField != other.cField) return false
            if (dField != other.dField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = bField.hashCode()
            hc = 31 * hc + cField.hashCode()
            hc = 31 * hc + dField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Rrr(
        val aField: org.partiql.pig.runtime.LongPrimitive,
        val bbbField: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): MultiWordDomainNode() {
    
        override fun copyMetas(newMetas: MetaContainer): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = newMetas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Rrr =
            Rrr(
                aField = aField,
                bbbField = bbbField,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("rrr"),
                aField?.let { ionSexpOf(ionSymbol("a_field"), it.toIonElement()) },
                bbbField?.let { ionSexpOf(ionSymbol("b_field"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            aField: org.partiql.pig.runtime.LongPrimitive = this.aField,
            bbbField: org.partiql.pig.runtime.LongPrimitive = this.bbbField,
            metas: MetaContainer = this.metas
        ) =
            Rrr(
                aField,
                bbbField,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Rrr::class.java) return false
    
            other as Rrr
            if (aField != other.aField) return false
            if (bbbField != other.bbbField) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
            var hc = aField.hashCode()
            hc = 31 * hc + bbbField.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SssTtt(override val metas: MetaContainer = emptyMetaContainer()) : MultiWordDomainNode() {
        override fun copyMetas(newMetas: MetaContainer): SssTtt =
            when (this) {
                is Lll -> copy(metas = newMetas)
                is Mmm -> copy(metas = newMetas)
            }
    
        class Lll(
            val uField: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun copyMetas(newMetas: MetaContainer): Lll =
                Lll(
                    uField = uField,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lll =
                Lll(
                    uField = uField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lll"),
                    uField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                uField: org.partiql.pig.runtime.LongPrimitive = this.uField,
                metas: MetaContainer = this.metas
            ) =
                Lll(
                    uField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lll::class.java) return false
        
                other as Lll
                if (uField != other.uField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = uField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Mmm(
            val vField: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SssTtt() {
        
            override fun copyMetas(newMetas: MetaContainer): Mmm =
                Mmm(
                    vField = vField,
                    metas = newMetas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Mmm =
                Mmm(
                    vField = vField,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("mmm"),
                    vField.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                vField: org.partiql.pig.runtime.SymbolPrimitive = this.vField,
                metas: MetaContainer = this.metas
            ) =
                Mmm(
                    vField,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Mmm::class.java) return false
        
                other as Mmm
                if (vField != other.vField) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
                var hc = vField.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Transformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class Transformer : IonElementTransformerBase<MultiWordDomainNode>() {
    
        override fun innerTransform(sexp: SexpElement): MultiWordDomainNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "aaa_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    MultiWordDomain.AaaAaa(
                        metas = sexp.metas)
                }
                "aaa_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    MultiWordDomain.AaaAab(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val dField = sexp.getOptional(0)?.toLongPrimitive()
                    val eField = sexp.getOptional(1)?.toSymbolPrimitive()
                    MultiWordDomain.AaaAac(
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aaa_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAad(
                        dField,
                        metas = sexp.metas)
                }
                "aaa_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val dField = sexp.values.drop(1).map { it.toLongPrimitive() }
                    MultiWordDomain.AaaAae(
                        dField,
                        metas = sexp.metas)
                }
                "aab_aaa" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    MultiWordDomain.AabAaa(
                        bField,
                        cField,
                        metas = sexp.metas)
                }
                "aab_aab" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    MultiWordDomain.AabAab(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aac" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.getOptional(2)?.toLongPrimitive()
                    val eField = sexp.getOptional(3)?.toSymbolPrimitive()
                    MultiWordDomain.AabAac(
                        bField,
                        cField,
                        dField,
                        eField,
                        metas = sexp.metas)
                }
                "aab_aad" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAad(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "aab_aae" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2147483647))
                    val bField = sexp.getRequired(0).toLongPrimitive()
                    val cField = sexp.getRequired(1).toSymbolPrimitive()
                    val dField = sexp.values.drop(3).map { it.toLongPrimitive() }
                    MultiWordDomain.AabAae(
                        bField,
                        cField,
                        dField,
                        metas = sexp.metas)
                }
                "rrr" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val aField = ir.processRequiredField("a_field") { it.toLongPrimitive() }
                    val bbbField = ir.processRequiredField("bbb_field") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Rrr(aField, bbbField, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SssTtt'
                //////////////////////////////////////
                "lll" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val uField = sexp.getRequired(0).toLongPrimitive()
                    MultiWordDomain.SssTtt.Lll(
                        uField,
                        metas = sexp.metas)
                }
                "mmm" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val vField = sexp.getRequired(0).toSymbolPrimitive()
                    MultiWordDomain.SssTtt.Mmm(
                        vField,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'multi_word_domain'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitAaaAaa(node: MultiWordDomain.AaaAaa) { }
        open fun visitAaaAab(node: MultiWordDomain.AaaAab) { }
        open fun visitAaaAac(node: MultiWordDomain.AaaAac) { }
        open fun visitAaaAad(node: MultiWordDomain.AaaAad) { }
        open fun visitAaaAae(node: MultiWordDomain.AaaAae) { }
        open fun visitAabAaa(node: MultiWordDomain.AabAaa) { }
        open fun visitAabAab(node: MultiWordDomain.AabAab) { }
        open fun visitAabAac(node: MultiWordDomain.AabAac) { }
        open fun visitAabAad(node: MultiWordDomain.AabAad) { }
        open fun visitAabAae(node: MultiWordDomain.AabAae) { }
        open fun visitRrr(node: MultiWordDomain.Rrr) { }
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        protected open fun visitSssTtt(node: MultiWordDomain.SssTtt) { }
        protected open fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll) { }
        protected open fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa) {
            visitAaaAaa(node)
            walkMetas(node.metas)
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab) {
            visitAaaAab(node)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac) {
            visitAaaAac(node)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad) {
            visitAaaAad(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae) {
            visitAaaAae(node)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa) {
            visitAabAaa(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            walkMetas(node.metas)
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab) {
            visitAabAab(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac) {
            visitAabAac(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField?.let { walkLongPrimitive(it) }
            node.eField?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad) {
            visitAabAad(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae) {
            visitAabAae(node)
            walkLongPrimitive(node.bField)
            walkSymbolPrimitive(node.cField)
            node.dField.map { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr) {
            visitRrr(node)
            walkLongPrimitive(node.aField)
            walkLongPrimitive(node.bbbField)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt) {
            visitSssTtt(node)
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll) {
            visitSssTttLll(node)
            walkLongPrimitive(node.uField)
            walkMetas(node.metas)
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm) {
            visitSssTttMmm(node)
            walkSymbolPrimitive(node.vField)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T = accumulator
        open protected fun visitAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T = accumulator
        open protected fun visitAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T = accumulator
        open protected fun visitAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T = accumulator
        open protected fun visitAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T = accumulator
        open protected fun visitAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T = accumulator
        open protected fun visitAabAab(node: MultiWordDomain.AabAab, accumulator: T): T = accumulator
        open protected fun visitAabAac(node: MultiWordDomain.AabAac, accumulator: T): T = accumulator
        open protected fun visitAabAad(node: MultiWordDomain.AabAad, accumulator: T): T = accumulator
        open protected fun visitAabAae(node: MultiWordDomain.AabAae, accumulator: T): T = accumulator
        open protected fun visitRrr(node: MultiWordDomain.Rrr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open protected fun visitSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T = accumulator
        open protected fun visitSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T = accumulator
        open protected fun visitSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkAaaAaa(node: MultiWordDomain.AaaAaa, accumulator: T): T {
            var current = accumulator
            current = visitAaaAaa(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAab(node: MultiWordDomain.AaaAab, accumulator: T): T {
            var current = accumulator
            current = visitAaaAab(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAac(node: MultiWordDomain.AaaAac, accumulator: T): T {
            var current = accumulator
            current = visitAaaAac(node, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAad(node: MultiWordDomain.AaaAad, accumulator: T): T {
            var current = accumulator
            current = visitAaaAad(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAaaAae(node: MultiWordDomain.AaaAae, accumulator: T): T {
            var current = accumulator
            current = visitAaaAae(node, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAaa(node: MultiWordDomain.AabAaa, accumulator: T): T {
            var current = accumulator
            current = visitAabAaa(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAab(node: MultiWordDomain.AabAab, accumulator: T): T {
            var current = accumulator
            current = visitAabAab(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAac(node: MultiWordDomain.AabAac, accumulator: T): T {
            var current = accumulator
            current = visitAabAac(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField?.let { current = walkLongPrimitive(it, current) }
            node.eField?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAad(node: MultiWordDomain.AabAad, accumulator: T): T {
            var current = accumulator
            current = visitAabAad(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAabAae(node: MultiWordDomain.AabAae, accumulator: T): T {
            var current = accumulator
            current = visitAabAae(node, current)
            current = walkLongPrimitive(node.bField, current)
            current = walkSymbolPrimitive(node.cField, current)
            node.dField.map { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRrr(node: MultiWordDomain.Rrr, accumulator: T): T {
            var current = accumulator
            current = visitRrr(node, current)
            current = walkLongPrimitive(node.aField, current)
            current = walkLongPrimitive(node.bbbField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun walkSssTtt(node: MultiWordDomain.SssTtt, accumulator: T): T {
            val current = visitSssTtt(node, accumulator)
            return when(node) {
                is MultiWordDomain.SssTtt.Lll -> walkSssTttLll(node, current)
                is MultiWordDomain.SssTtt.Mmm -> walkSssTttMmm(node, current)
            }
        }
    
        open fun walkSssTttLll(node: MultiWordDomain.SssTtt.Lll, accumulator: T): T {
            var current = accumulator
            current = visitSssTttLll(node, current)
            current = walkLongPrimitive(node.uField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSssTttMmm(node: MultiWordDomain.SssTtt.Mmm, accumulator: T): T {
            var current = accumulator
            current = visitSssTttMmm(node, current)
            current = walkSymbolPrimitive(node.vField, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    
    
    open class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple AaaAaa
        open fun transformAaaAaa(node: AaaAaa): AaaAaa {
            val new_metas = transformAaaAaa_metas(node)
            return build {
                AaaAaa(
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAaa_metas(node: AaaAaa) =
            transformMetas(node.metas)
    
        // Tuple AaaAab
        open fun transformAaaAab(node: AaaAab): AaaAab {
            val new_dField = transformAaaAab_dField(node)
            val new_metas = transformAaaAab_metas(node)
            return build {
                AaaAab(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAab_dField(node: AaaAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAab_metas(node: AaaAab) =
            transformMetas(node.metas)
    
        // Tuple AaaAac
        open fun transformAaaAac(node: AaaAac): AaaAac {
            val new_dField = transformAaaAac_dField(node)
            val new_eField = transformAaaAac_eField(node)
            val new_metas = transformAaaAac_metas(node)
            return build {
                AaaAac(
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAac_dField(node: AaaAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAaaAac_eField(node: AaaAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAaaAac_metas(node: AaaAac) =
            transformMetas(node.metas)
    
        // Tuple AaaAad
        open fun transformAaaAad(node: AaaAad): AaaAad {
            val new_dField = transformAaaAad_dField(node)
            val new_metas = transformAaaAad_metas(node)
            return build {
                AaaAad(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAad_dField(node: AaaAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAad_metas(node: AaaAad) =
            transformMetas(node.metas)
    
        // Tuple AaaAae
        open fun transformAaaAae(node: AaaAae): AaaAae {
            val new_dField = transformAaaAae_dField(node)
            val new_metas = transformAaaAae_metas(node)
            return build {
                AaaAae(
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAaaAae_dField(node: AaaAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAaaAae_metas(node: AaaAae) =
            transformMetas(node.metas)
    
        // Tuple AabAaa
        open fun transformAabAaa(node: AabAaa): AabAaa {
            val new_bField = transformAabAaa_bField(node)
            val new_cField = transformAabAaa_cField(node)
            val new_metas = transformAabAaa_metas(node)
            return build {
                AabAaa(
                    bField = new_bField,
                    cField = new_cField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAaa_bField(node: AabAaa) =
            transformLongPrimitive(node.bField)
        open fun transformAabAaa_cField(node: AabAaa) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAaa_metas(node: AabAaa) =
            transformMetas(node.metas)
    
        // Tuple AabAab
        open fun transformAabAab(node: AabAab): AabAab {
            val new_bField = transformAabAab_bField(node)
            val new_cField = transformAabAab_cField(node)
            val new_dField = transformAabAab_dField(node)
            val new_metas = transformAabAab_metas(node)
            return build {
                AabAab(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAab_bField(node: AabAab) =
            transformLongPrimitive(node.bField)
        open fun transformAabAab_cField(node: AabAab) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAab_dField(node: AabAab) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAab_metas(node: AabAab) =
            transformMetas(node.metas)
    
        // Tuple AabAac
        open fun transformAabAac(node: AabAac): AabAac {
            val new_bField = transformAabAac_bField(node)
            val new_cField = transformAabAac_cField(node)
            val new_dField = transformAabAac_dField(node)
            val new_eField = transformAabAac_eField(node)
            val new_metas = transformAabAac_metas(node)
            return build {
                AabAac(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    eField = new_eField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAac_bField(node: AabAac) =
            transformLongPrimitive(node.bField)
        open fun transformAabAac_cField(node: AabAac) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAac_dField(node: AabAac) =
            node.dField?.let { transformLongPrimitive(it) }
        open fun transformAabAac_eField(node: AabAac) =
            node.eField?.let { transformSymbolPrimitive(it) }
        open fun transformAabAac_metas(node: AabAac) =
            transformMetas(node.metas)
    
        // Tuple AabAad
        open fun transformAabAad(node: AabAad): AabAad {
            val new_bField = transformAabAad_bField(node)
            val new_cField = transformAabAad_cField(node)
            val new_dField = transformAabAad_dField(node)
            val new_metas = transformAabAad_metas(node)
            return build {
                AabAad(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAad_bField(node: AabAad) =
            transformLongPrimitive(node.bField)
        open fun transformAabAad_cField(node: AabAad) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAad_dField(node: AabAad) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAad_metas(node: AabAad) =
            transformMetas(node.metas)
    
        // Tuple AabAae
        open fun transformAabAae(node: AabAae): AabAae {
            val new_bField = transformAabAae_bField(node)
            val new_cField = transformAabAae_cField(node)
            val new_dField = transformAabAae_dField(node)
            val new_metas = transformAabAae_metas(node)
            return build {
                AabAae(
                    bField = new_bField,
                    cField = new_cField,
                    dField = new_dField,
                    metas = new_metas
                )
            }
        }
        open fun transformAabAae_bField(node: AabAae) =
            transformLongPrimitive(node.bField)
        open fun transformAabAae_cField(node: AabAae) =
            transformSymbolPrimitive(node.cField)
        open fun transformAabAae_dField(node: AabAae) =
            node.dField.map { transformLongPrimitive(it) }
        open fun transformAabAae_metas(node: AabAae) =
            transformMetas(node.metas)
    
        // Tuple Rrr
        open fun transformRrr(node: Rrr): Rrr {
            val new_aField = transformRrr_aField(node)
            val new_bbbField = transformRrr_bbbField(node)
            val new_metas = transformRrr_metas(node)
            return build {
                Rrr(
                    aField = new_aField,
                    bbbField = new_bbbField,
                    metas = new_metas
                )
            }
        }
        open fun transformRrr_aField(node: Rrr) =
            transformLongPrimitive(node.aField)
        open fun transformRrr_bbbField(node: Rrr) =
            transformLongPrimitive(node.bbbField)
        open fun transformRrr_metas(node: Rrr) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SssTtt
        //////////////////////////////////////
        open fun transformSssTtt(node: MultiWordDomain.SssTtt) =
            when(node) {
                is MultiWordDomain.SssTtt.Lll -> transformSssTttLll(node)
                is MultiWordDomain.SssTtt.Mmm -> transformSssTttMmm(node)
            }
        // Variant SssTttLll
        open fun transformSssTttLll(node: MultiWordDomain.SssTtt.Lll): MultiWordDomain.SssTtt {
            val new_uField = transformSssTttLll_uField(node)
            val new_metas = transformSssTttLll_metas(node)
            return build {
                SssTtt.Lll(
                    uField = new_uField,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSssTttLll_uField(node: SssTtt.Lll) =
            transformLongPrimitive(node.uField)
        open fun transformSssTttLll_metas(node: SssTtt.Lll) =
            transformMetas(node.metas)
    
    
        // Variant SssTttMmm
        open fun transformSssTttMmm(node: MultiWordDomain.SssTtt.Mmm): MultiWordDomain.SssTtt {
            val new_vField = transformSssTttMmm_vField(node)
            val new_metas = transformSssTttMmm_metas(node)
            return build {
                SssTtt.Mmm(
                    vField = new_vField,
                    metas = new_metas
                )
            }
        }
    
        open fun transformSssTttMmm_vField(node: SssTtt.Mmm) =
            transformSymbolPrimitive(node.vField)
        open fun transformSssTttMmm_metas(node: SssTtt.Mmm) =
            transformMetas(node.metas)
    
    
    }
}

