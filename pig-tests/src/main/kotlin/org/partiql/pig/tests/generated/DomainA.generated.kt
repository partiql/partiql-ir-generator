
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*


class DomainA private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = DomainABuilder
    
        fun <T: DomainANode> build(block: Builder.() -> T) =
            DomainABuilder.block()
    
        fun transform(element: AnyElement): DomainANode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): DomainANode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [DomainA.ProductToRemove].
         */
        fun productToRemove(
            whatever: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductToRemove =
            DomainA.ProductToRemove(
                whatever = whatever.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.ProductToRemove].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productToRemove_(
            whatever: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductToRemove =
            DomainA.ProductToRemove(
                whatever = whatever,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.RecordToRemove].
         */
        fun recordToRemove(
            irrelevant: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordToRemove =
            DomainA.RecordToRemove(
                irrelevant = irrelevant.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.RecordToRemove].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordToRemove_(
            irrelevant: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordToRemove =
            DomainA.RecordToRemove(
                irrelevant = irrelevant,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.ProductA].
         */
        fun productA(
            one: Long,
            two: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductA =
            DomainA.ProductA(
                one = one.asPrimitive(),
                two = two,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.ProductA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productA_(
            one: org.partiql.pig.runtime.LongPrimitive,
            two: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.ProductA =
            DomainA.ProductA(
                one = one,
                two = two,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.RecordA].
         */
        fun recordA(
            one: Long,
            two: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordA =
            DomainA.RecordA(
                one = one.asPrimitive(),
                two = two,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.RecordA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordA_(
            one: org.partiql.pig.runtime.LongPrimitive,
            two: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.RecordA =
            DomainA.RecordA(
                one = one,
                two = two,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedProduct].
         */
        fun unpermutedProduct(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedProduct =
            DomainA.UnpermutedProduct(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProduct_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedProduct =
            DomainA.UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedRecord].
         */
        fun unpermutedRecord(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedRecord =
            DomainA.UnpermutedRecord(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecord_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedRecord =
            DomainA.UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumToRemove 
        /**
         * Creates an instance of [DomainA.SumToRemove.Doesnt].
         */
        fun doesnt(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumToRemove.Doesnt =
            DomainA.SumToRemove.Doesnt(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumToRemove.Matter].
         */
        fun matter(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumToRemove.Matter =
            DomainA.SumToRemove.Matter(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumToReplaceWithProduct 
        /**
         * Creates an instance of [DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant].
         */
        fun sumToReplaceWithProductVariant(
            t: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant =
            DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant(
                t = t,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumA 
        /**
         * Creates an instance of [DomainA.SumA.Who].
         */
        fun who(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumA.Who =
            DomainA.SumA.Who(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumA.Cares].
         */
        fun cares(
            a: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumA.Cares =
            DomainA.SumA.Cares(
                a = a,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumA.Noti].
         */
        fun noti(
            a: ProductToRemove,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumA.Noti =
            DomainA.SumA.Noti(
                a = a,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumB 
        /**
         * Creates an instance of [DomainA.SumB.WillBeUnchanged].
         */
        fun willBeUnchanged(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeUnchanged =
            DomainA.SumB.WillBeUnchanged(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeRemoved].
         */
        fun willBeRemoved(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeRemoved =
            DomainA.SumB.WillBeRemoved(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeReplaced].
         */
        fun willBeReplaced(
            something: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeReplaced =
            DomainA.SumB.WillBeReplaced(
                something = something.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.SumB.WillBeReplaced].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun willBeReplaced_(
            something: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.SumB.WillBeReplaced =
            DomainA.SumB.WillBeReplaced(
                something = something,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: UnpermutedSum 
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedProductVariant].
         */
        fun unpermutedProductVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedProductVariant =
            DomainA.UnpermutedSum.UnpermutedProductVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedProductVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProductVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedProductVariant =
            DomainA.UnpermutedSum.UnpermutedProductVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedRecordVariant].
         */
        fun unpermutedRecordVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedRecordVariant =
            DomainA.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainA.UnpermutedSum.UnpermutedRecordVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecordVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainA.UnpermutedSum.UnpermutedRecordVariant =
            DomainA.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object DomainABuilder : Builder
    
    /** Base class for all DomainA types. */
    abstract class DomainANode : DomainNode {
        abstract override fun copy(metas: MetaContainer): DomainANode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): DomainANode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ProductToRemove(
        val whatever: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): ProductToRemove =
            ProductToRemove(
                whatever = whatever,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductToRemove =
            ProductToRemove(
                whatever = whatever,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_to_remove"),
                whatever.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            whatever: org.partiql.pig.runtime.SymbolPrimitive = this.whatever,
            metas: MetaContainer = this.metas
        ) =
            ProductToRemove(
                whatever,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductToRemove::class.java) return false
    
            other as ProductToRemove
            if (whatever != other.whatever) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = whatever.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordToRemove(
        val irrelevant: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): RecordToRemove =
            RecordToRemove(
                irrelevant = irrelevant,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordToRemove =
            RecordToRemove(
                irrelevant = irrelevant,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_to_remove"),
                irrelevant?.let { ionSexpOf(ionSymbol("irrelevant"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            irrelevant: org.partiql.pig.runtime.LongPrimitive = this.irrelevant,
            metas: MetaContainer = this.metas
        ) =
            RecordToRemove(
                irrelevant,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordToRemove::class.java) return false
    
            other as RecordToRemove
            if (irrelevant != other.irrelevant) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = irrelevant.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductA(
        val one: org.partiql.pig.runtime.LongPrimitive,
        val two: ProductToRemove,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): ProductA =
            ProductA(
                one = one,
                two = two,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductA =
            ProductA(
                one = one,
                two = two,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_a"),
                one.toIonElement(),
                two.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            one: org.partiql.pig.runtime.LongPrimitive = this.one,
            two: ProductToRemove = this.two,
            metas: MetaContainer = this.metas
        ) =
            ProductA(
                one,
                two,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductA::class.java) return false
    
            other as ProductA
            if (one != other.one) return false
            if (two != other.two) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = one.hashCode()
            hc = 31 * hc + two.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordA(
        val one: org.partiql.pig.runtime.LongPrimitive,
        val two: ProductToRemove,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): RecordA =
            RecordA(
                one = one,
                two = two,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordA =
            RecordA(
                one = one,
                two = two,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_a"),
                one?.let { ionSexpOf(ionSymbol("one"), it.toIonElement()) },
                two?.let { ionSexpOf(ionSymbol("two"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            one: org.partiql.pig.runtime.LongPrimitive = this.one,
            two: ProductToRemove = this.two,
            metas: MetaContainer = this.metas
        ) =
            RecordA(
                one,
                two,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordA::class.java) return false
    
            other as RecordA
            if (one != other.one) return false
            if (two != other.two) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = one.hashCode()
            hc = 31 * hc + two.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedProduct(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("unpermuted_product"),
                foo.toIonElement(),
                bar.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedProduct(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedProduct::class.java) return false
    
            other as UnpermutedProduct
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedRecord(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainANode() {
    
        override fun copy(metas: MetaContainer): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("unpermuted_record"),
                foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedRecord(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedRecord::class.java) return false
    
            other as UnpermutedRecord
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class SumToRemove(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumToRemove =
            when (this) {
                is Doesnt -> copy(metas = metas)
                is Matter -> copy(metas = metas)
            }
    
        class Doesnt(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumToRemove() {
        
            override fun copy(metas: MetaContainer): Doesnt =
                Doesnt(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Doesnt =
                Doesnt(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("doesnt"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Doesnt::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Matter(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumToRemove() {
        
            override fun copy(metas: MetaContainer): Matter =
                Matter(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Matter =
                Matter(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("matter"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Matter::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        /** Converts instances of [DomainA.SumToRemove] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumToRemove): T = when(node) {
                is DomainA.SumToRemove.Doesnt -> convertDoesnt(node)
                is DomainA.SumToRemove.Matter -> convertMatter(node)
            }
    
            fun convertDoesnt(node: DomainA.SumToRemove.Doesnt): T
            fun convertMatter(node: DomainA.SumToRemove.Matter): T
        }
    }
    
    sealed class SumToReplaceWithProduct(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumToReplaceWithProduct =
            when (this) {
                is SumToReplaceWithProductVariant -> copy(metas = metas)
            }
    
        class SumToReplaceWithProductVariant(
            val t: ProductToRemove,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumToReplaceWithProduct() {
        
            override fun copy(metas: MetaContainer): SumToReplaceWithProductVariant =
                SumToReplaceWithProductVariant(
                    t = t,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SumToReplaceWithProductVariant =
                SumToReplaceWithProductVariant(
                    t = t,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("sum_to_replace_with_product_variant"),
                    t.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                t: ProductToRemove = this.t,
                metas: MetaContainer = this.metas
            ) =
                SumToReplaceWithProductVariant(
                    t,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SumToReplaceWithProductVariant::class.java) return false
        
                other as SumToReplaceWithProductVariant
                if (t != other.t) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = t.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.SumToReplaceWithProduct] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumToReplaceWithProduct): T = when(node) {
                is DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant -> convertSumToReplaceWithProductVariant(node)
            }
    
            fun convertSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant): T
        }
    }
    
    sealed class SumA(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumA =
            when (this) {
                is Who -> copy(metas = metas)
                is Cares -> copy(metas = metas)
                is Noti -> copy(metas = metas)
            }
    
        class Who(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumA() {
        
            override fun copy(metas: MetaContainer): Who =
                Who(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Who =
                Who(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("who"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Who::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Cares(
            val a: ProductToRemove,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumA() {
        
            override fun copy(metas: MetaContainer): Cares =
                Cares(
                    a = a,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Cares =
                Cares(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("cares"),
                    a.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                a: ProductToRemove = this.a,
                metas: MetaContainer = this.metas
            ) =
                Cares(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Cares::class.java) return false
        
                other as Cares
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Noti(
            val a: ProductToRemove,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumA() {
        
            override fun copy(metas: MetaContainer): Noti =
                Noti(
                    a = a,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Noti =
                Noti(
                    a = a,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("noti"),
                    a?.let { ionSexpOf(ionSymbol("a"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                a: ProductToRemove = this.a,
                metas: MetaContainer = this.metas
            ) =
                Noti(
                    a,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Noti::class.java) return false
        
                other as Noti
                if (a != other.a) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = a.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.SumA] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumA): T = when(node) {
                is DomainA.SumA.Who -> convertWho(node)
                is DomainA.SumA.Cares -> convertCares(node)
                is DomainA.SumA.Noti -> convertNoti(node)
            }
    
            fun convertWho(node: DomainA.SumA.Who): T
            fun convertCares(node: DomainA.SumA.Cares): T
            fun convertNoti(node: DomainA.SumA.Noti): T
        }
    }
    
    sealed class SumB(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): SumB =
            when (this) {
                is WillBeUnchanged -> copy(metas = metas)
                is WillBeRemoved -> copy(metas = metas)
                is WillBeReplaced -> copy(metas = metas)
            }
    
        class WillBeUnchanged(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_unchanged"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeUnchanged::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class WillBeRemoved(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeRemoved =
                WillBeRemoved(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeRemoved =
                WillBeRemoved(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_removed"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeRemoved::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4001
        }
    
        class WillBeReplaced(
            val something: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_replaced"),
                    something.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                something: org.partiql.pig.runtime.LongPrimitive = this.something,
                metas: MetaContainer = this.metas
            ) =
                WillBeReplaced(
                    something,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeReplaced::class.java) return false
        
                other as WillBeReplaced
                if (something != other.something) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = something.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.SumB] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.SumB): T = when(node) {
                is DomainA.SumB.WillBeUnchanged -> convertWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> convertWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> convertWillBeReplaced(node)
            }
    
            fun convertWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged): T
            fun convertWillBeRemoved(node: DomainA.SumB.WillBeRemoved): T
            fun convertWillBeReplaced(node: DomainA.SumB.WillBeReplaced): T
        }
    }
    
    sealed class UnpermutedSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainANode() {
        override fun copy(metas: MetaContainer): UnpermutedSum =
            when (this) {
                is UnpermutedProductVariant -> copy(metas = metas)
                is UnpermutedRecordVariant -> copy(metas = metas)
            }
    
        class UnpermutedProductVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unpermuted_product_variant"),
                    foo.toIonElement(),
                    bar.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedProductVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedProductVariant::class.java) return false
        
                other as UnpermutedProductVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class UnpermutedRecordVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("unpermuted_record_variant"),
                    foo?.let { ionSexpOf(ionSymbol("foo"), it.toIonElement()) },
                    bar?.let { ionSexpOf(ionSymbol("bar"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedRecordVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedRecordVariant::class.java) return false
        
                other as UnpermutedRecordVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainA.UnpermutedSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainA.UnpermutedSum): T = when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> convertUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> convertUnpermutedRecordVariant(node)
            }
    
            fun convertUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant): T
            fun convertUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<DomainANode>() {
    
        override fun innerTransform(sexp: SexpElement): DomainANode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "product_to_remove" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val whatever = sexp.getRequired(0).toSymbolPrimitive()
                    DomainA.ProductToRemove(
                        whatever,
                        metas = sexp.metas)
                }
                "record_to_remove" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val irrelevant = ir.processRequiredField("irrelevant") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordToRemove(irrelevant, metas = sexp.metas)
                }
                "product_a" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val one = sexp.getRequired(0).toLongPrimitive()
                    val two = sexp.getRequired(1).transformExpect<ProductToRemove>()
                    DomainA.ProductA(
                        one,
                        two,
                        metas = sexp.metas)
                }
                "record_a" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val one = ir.processRequiredField("one") { it.toLongPrimitive() }
                    val two = ir.processRequiredField("two") { it.transformExpect<ProductToRemove>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordA(one, two, metas = sexp.metas)
                }
                "unpermuted_product" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainA.UnpermutedProduct(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedRecord(foo, bar, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumToRemove'
                //////////////////////////////////////
                "doesnt" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumToRemove.Doesnt(
                        metas = sexp.metas)
                }
                "matter" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumToRemove.Matter(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumToReplaceWithProduct'
                //////////////////////////////////////
                "sum_to_replace_with_product_variant" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val t = sexp.getRequired(0).transformExpect<ProductToRemove>()
                    DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant(
                        t,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumA'
                //////////////////////////////////////
                "who" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumA.Who(
                        metas = sexp.metas)
                }
                "cares" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val a = sexp.getRequired(0).transformExpect<ProductToRemove>()
                    DomainA.SumA.Cares(
                        a,
                        metas = sexp.metas)
                }
                "noti" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val a = ir.processRequiredField("a") { it.transformExpect<ProductToRemove>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    SumA.Noti(a, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumB'
                //////////////////////////////////////
                "will_be_unchanged" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumB.WillBeUnchanged(
                        metas = sexp.metas)
                }
                "will_be_removed" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainA.SumB.WillBeRemoved(
                        metas = sexp.metas)
                }
                "will_be_replaced" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val something = sexp.getRequired(0).toLongPrimitive()
                    DomainA.SumB.WillBeReplaced(
                        something,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'UnpermutedSum'
                //////////////////////////////////////
                "unpermuted_product_variant" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainA.UnpermutedSum.UnpermutedProductVariant(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record_variant" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedSum.UnpermutedRecordVariant(foo, bar, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'domain_a'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitProductToRemove(node: DomainA.ProductToRemove) { }
        open fun visitRecordToRemove(node: DomainA.RecordToRemove) { }
        open fun visitProductA(node: DomainA.ProductA) { }
        open fun visitRecordA(node: DomainA.RecordA) { }
        open fun visitUnpermutedProduct(node: DomainA.UnpermutedProduct) { }
        open fun visitUnpermutedRecord(node: DomainA.UnpermutedRecord) { }
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        protected open fun visitSumToRemove(node: DomainA.SumToRemove) { }
        protected open fun visitSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt) { }
        protected open fun visitSumToRemoveMatter(node: DomainA.SumToRemove.Matter) { }
        //////////////////////////////////////
        // Sum Type: SumToReplaceWithProduct
        //////////////////////////////////////
        protected open fun visitSumToReplaceWithProduct(node: DomainA.SumToReplaceWithProduct) { }
        protected open fun visitSumToReplaceWithProductSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant) { }
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        protected open fun visitSumA(node: DomainA.SumA) { }
        protected open fun visitSumAWho(node: DomainA.SumA.Who) { }
        protected open fun visitSumACares(node: DomainA.SumA.Cares) { }
        protected open fun visitSumANoti(node: DomainA.SumA.Noti) { }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        protected open fun visitSumB(node: DomainA.SumB) { }
        protected open fun visitSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged) { }
        protected open fun visitSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved) { }
        protected open fun visitSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced) { }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        protected open fun visitUnpermutedSum(node: DomainA.UnpermutedSum) { }
        protected open fun visitUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant) { }
        protected open fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkProductToRemove(node: DomainA.ProductToRemove) {
            visitProductToRemove(node)
            walkSymbolPrimitive(node.whatever)
            walkMetas(node.metas)
        }
    
        open fun walkRecordToRemove(node: DomainA.RecordToRemove) {
            visitRecordToRemove(node)
            walkLongPrimitive(node.irrelevant)
            walkMetas(node.metas)
        }
    
        open fun walkProductA(node: DomainA.ProductA) {
            visitProductA(node)
            walkLongPrimitive(node.one)
            walkProductToRemove(node.two)
            walkMetas(node.metas)
        }
    
        open fun walkRecordA(node: DomainA.RecordA) {
            visitRecordA(node)
            walkLongPrimitive(node.one)
            walkProductToRemove(node.two)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedProduct(node: DomainA.UnpermutedProduct) {
            visitUnpermutedProduct(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        open fun walkUnpermutedRecord(node: DomainA.UnpermutedRecord) {
            visitUnpermutedRecord(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun walkSumToRemove(node: DomainA.SumToRemove) {
            visitSumToRemove(node)
            when(node) {
                is DomainA.SumToRemove.Doesnt -> walkSumToRemoveDoesnt(node)
                is DomainA.SumToRemove.Matter -> walkSumToRemoveMatter(node)
            }
        }
    
        open fun walkSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt) {
            visitSumToRemoveDoesnt(node)
            walkMetas(node.metas)
        }
        open fun walkSumToRemoveMatter(node: DomainA.SumToRemove.Matter) {
            visitSumToRemoveMatter(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: SumToReplaceWithProduct
        //////////////////////////////////////
        open fun walkSumToReplaceWithProduct(node: DomainA.SumToReplaceWithProduct) {
            visitSumToReplaceWithProduct(node)
            when(node) {
                is DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant -> walkSumToReplaceWithProductSumToReplaceWithProductVariant(node)
            }
        }
    
        open fun walkSumToReplaceWithProductSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant) {
            visitSumToReplaceWithProductSumToReplaceWithProductVariant(node)
            walkProductToRemove(node.t)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun walkSumA(node: DomainA.SumA) {
            visitSumA(node)
            when(node) {
                is DomainA.SumA.Who -> walkSumAWho(node)
                is DomainA.SumA.Cares -> walkSumACares(node)
                is DomainA.SumA.Noti -> walkSumANoti(node)
            }
        }
    
        open fun walkSumAWho(node: DomainA.SumA.Who) {
            visitSumAWho(node)
            walkMetas(node.metas)
        }
        open fun walkSumACares(node: DomainA.SumA.Cares) {
            visitSumACares(node)
            walkProductToRemove(node.a)
            walkMetas(node.metas)
        }
        open fun walkSumANoti(node: DomainA.SumA.Noti) {
            visitSumANoti(node)
            walkProductToRemove(node.a)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainA.SumB) {
            visitSumB(node)
            when(node) {
                is DomainA.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> walkSumBWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged) {
            visitSumBWillBeUnchanged(node)
            walkMetas(node.metas)
        }
        open fun walkSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved) {
            visitSumBWillBeRemoved(node)
            walkMetas(node.metas)
        }
        open fun walkSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced) {
            visitSumBWillBeReplaced(node)
            walkLongPrimitive(node.something)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainA.UnpermutedSum) {
            visitUnpermutedSum(node)
            when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant) {
            visitUnpermutedSumUnpermutedProductVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) {
            visitUnpermutedSumUnpermutedRecordVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitProductToRemove(node: DomainA.ProductToRemove, accumulator: T): T = accumulator
        open protected fun visitRecordToRemove(node: DomainA.RecordToRemove, accumulator: T): T = accumulator
        open protected fun visitProductA(node: DomainA.ProductA, accumulator: T): T = accumulator
        open protected fun visitRecordA(node: DomainA.RecordA, accumulator: T): T = accumulator
        open protected fun visitUnpermutedProduct(node: DomainA.UnpermutedProduct, accumulator: T): T = accumulator
        open protected fun visitUnpermutedRecord(node: DomainA.UnpermutedRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open protected fun visitSumToRemove(node: DomainA.SumToRemove, accumulator: T): T = accumulator
        open protected fun visitSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt, accumulator: T): T = accumulator
        open protected fun visitSumToRemoveMatter(node: DomainA.SumToRemove.Matter, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumToReplaceWithProduct
        //////////////////////////////////////
        open protected fun visitSumToReplaceWithProduct(node: DomainA.SumToReplaceWithProduct, accumulator: T): T = accumulator
        open protected fun visitSumToReplaceWithProductSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open protected fun visitSumA(node: DomainA.SumA, accumulator: T): T = accumulator
        open protected fun visitSumAWho(node: DomainA.SumA.Who, accumulator: T): T = accumulator
        open protected fun visitSumACares(node: DomainA.SumA.Cares, accumulator: T): T = accumulator
        open protected fun visitSumANoti(node: DomainA.SumA.Noti, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open protected fun visitSumB(node: DomainA.SumB, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open protected fun visitUnpermutedSum(node: DomainA.UnpermutedSum, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkProductToRemove(node: DomainA.ProductToRemove, accumulator: T): T {
            var current = accumulator
            current = visitProductToRemove(node, current)
            current = walkSymbolPrimitive(node.whatever, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordToRemove(node: DomainA.RecordToRemove, accumulator: T): T {
            var current = accumulator
            current = visitRecordToRemove(node, current)
            current = walkLongPrimitive(node.irrelevant, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductA(node: DomainA.ProductA, accumulator: T): T {
            var current = accumulator
            current = visitProductA(node, current)
            current = walkLongPrimitive(node.one, current)
            current = walkProductToRemove(node.two, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordA(node: DomainA.RecordA, accumulator: T): T {
            var current = accumulator
            current = visitRecordA(node, current)
            current = walkLongPrimitive(node.one, current)
            current = walkProductToRemove(node.two, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedProduct(node: DomainA.UnpermutedProduct, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedProduct(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedRecord(node: DomainA.UnpermutedRecord, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedRecord(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun walkSumToRemove(node: DomainA.SumToRemove, accumulator: T): T {
            val current = visitSumToRemove(node, accumulator)
            return when(node) {
                is DomainA.SumToRemove.Doesnt -> walkSumToRemoveDoesnt(node, current)
                is DomainA.SumToRemove.Matter -> walkSumToRemoveMatter(node, current)
            }
        }
    
        open fun walkSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt, accumulator: T): T {
            var current = accumulator
            current = visitSumToRemoveDoesnt(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumToRemoveMatter(node: DomainA.SumToRemove.Matter, accumulator: T): T {
            var current = accumulator
            current = visitSumToRemoveMatter(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumToReplaceWithProduct
        //////////////////////////////////////
        open fun walkSumToReplaceWithProduct(node: DomainA.SumToReplaceWithProduct, accumulator: T): T {
            val current = visitSumToReplaceWithProduct(node, accumulator)
            return when(node) {
                is DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant -> walkSumToReplaceWithProductSumToReplaceWithProductVariant(node, current)
            }
        }
    
        open fun walkSumToReplaceWithProductSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant, accumulator: T): T {
            var current = accumulator
            current = visitSumToReplaceWithProductSumToReplaceWithProductVariant(node, current)
            current = walkProductToRemove(node.t, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun walkSumA(node: DomainA.SumA, accumulator: T): T {
            val current = visitSumA(node, accumulator)
            return when(node) {
                is DomainA.SumA.Who -> walkSumAWho(node, current)
                is DomainA.SumA.Cares -> walkSumACares(node, current)
                is DomainA.SumA.Noti -> walkSumANoti(node, current)
            }
        }
    
        open fun walkSumAWho(node: DomainA.SumA.Who, accumulator: T): T {
            var current = accumulator
            current = visitSumAWho(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumACares(node: DomainA.SumA.Cares, accumulator: T): T {
            var current = accumulator
            current = visitSumACares(node, current)
            current = walkProductToRemove(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumANoti(node: DomainA.SumA.Noti, accumulator: T): T {
            var current = accumulator
            current = visitSumANoti(node, current)
            current = walkProductToRemove(node.a, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainA.SumB, accumulator: T): T {
            val current = visitSumB(node, accumulator)
            return when(node) {
                is DomainA.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node, current)
                is DomainA.SumB.WillBeRemoved -> walkSumBWillBeRemoved(node, current)
                is DomainA.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node, current)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeUnchanged(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeRemoved(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeReplaced(node, current)
            current = walkLongPrimitive(node.something, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainA.UnpermutedSum, accumulator: T): T {
            val current = visitUnpermutedSum(node, accumulator)
            return when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node, current)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node, current)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedProductVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedRecordVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple ProductToRemove
        open fun transformProductToRemove(node: DomainA.ProductToRemove): DomainA.ProductToRemove {
            val new_whatever = transformProductToRemove_whatever(node)
            val new_metas = transformProductToRemove_metas(node)
            return if (
                node.whatever !== new_whatever ||
                node.metas !== new_metas
            ) {
                DomainA.ProductToRemove(
                    whatever = new_whatever,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductToRemove_whatever(node: DomainA.ProductToRemove) =
            transformSymbolPrimitive(node.whatever)
        open fun transformProductToRemove_metas(node: DomainA.ProductToRemove) =
            transformMetas(node.metas)
    
        // Tuple RecordToRemove
        open fun transformRecordToRemove(node: DomainA.RecordToRemove): DomainA.RecordToRemove {
            val new_irrelevant = transformRecordToRemove_irrelevant(node)
            val new_metas = transformRecordToRemove_metas(node)
            return if (
                node.irrelevant !== new_irrelevant ||
                node.metas !== new_metas
            ) {
                DomainA.RecordToRemove(
                    irrelevant = new_irrelevant,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordToRemove_irrelevant(node: DomainA.RecordToRemove) =
            transformLongPrimitive(node.irrelevant)
        open fun transformRecordToRemove_metas(node: DomainA.RecordToRemove) =
            transformMetas(node.metas)
    
        // Tuple ProductA
        open fun transformProductA(node: DomainA.ProductA): DomainA.ProductA {
            val new_one = transformProductA_one(node)
            val new_two = transformProductA_two(node)
            val new_metas = transformProductA_metas(node)
            return if (
                node.one !== new_one ||
                node.two !== new_two ||
                node.metas !== new_metas
            ) {
                DomainA.ProductA(
                    one = new_one,
                    two = new_two,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductA_one(node: DomainA.ProductA) =
            transformLongPrimitive(node.one)
        open fun transformProductA_two(node: DomainA.ProductA) =
            transformProductToRemove(node.two)
        open fun transformProductA_metas(node: DomainA.ProductA) =
            transformMetas(node.metas)
    
        // Tuple RecordA
        open fun transformRecordA(node: DomainA.RecordA): DomainA.RecordA {
            val new_one = transformRecordA_one(node)
            val new_two = transformRecordA_two(node)
            val new_metas = transformRecordA_metas(node)
            return if (
                node.one !== new_one ||
                node.two !== new_two ||
                node.metas !== new_metas
            ) {
                DomainA.RecordA(
                    one = new_one,
                    two = new_two,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordA_one(node: DomainA.RecordA) =
            transformLongPrimitive(node.one)
        open fun transformRecordA_two(node: DomainA.RecordA) =
            transformProductToRemove(node.two)
        open fun transformRecordA_metas(node: DomainA.RecordA) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedProduct
        open fun transformUnpermutedProduct(node: DomainA.UnpermutedProduct): DomainA.UnpermutedProduct {
            val new_foo = transformUnpermutedProduct_foo(node)
            val new_bar = transformUnpermutedProduct_bar(node)
            val new_metas = transformUnpermutedProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedProduct(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedProduct_foo(node: DomainA.UnpermutedProduct) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedProduct_bar(node: DomainA.UnpermutedProduct) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedProduct_metas(node: DomainA.UnpermutedProduct) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedRecord
        open fun transformUnpermutedRecord(node: DomainA.UnpermutedRecord): DomainA.UnpermutedRecord {
            val new_foo = transformUnpermutedRecord_foo(node)
            val new_bar = transformUnpermutedRecord_bar(node)
            val new_metas = transformUnpermutedRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedRecord(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedRecord_foo(node: DomainA.UnpermutedRecord) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedRecord_bar(node: DomainA.UnpermutedRecord) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedRecord_metas(node: DomainA.UnpermutedRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumToRemove
        //////////////////////////////////////
        open fun transformSumToRemove(node: DomainA.SumToRemove): DomainA.SumToRemove =
            when(node) {
                is DomainA.SumToRemove.Doesnt -> transformSumToRemoveDoesnt(node)
                is DomainA.SumToRemove.Matter -> transformSumToRemoveMatter(node)
            }
        // Variant SumToRemoveDoesnt
        open fun transformSumToRemoveDoesnt(node: DomainA.SumToRemove.Doesnt): DomainA.SumToRemove {
            val new_metas = transformSumToRemoveDoesnt_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumToRemove.Doesnt(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToRemoveDoesnt_metas(node: DomainA.SumToRemove.Doesnt) =
            transformMetas(node.metas)
    
        // Variant SumToRemoveMatter
        open fun transformSumToRemoveMatter(node: DomainA.SumToRemove.Matter): DomainA.SumToRemove {
            val new_metas = transformSumToRemoveMatter_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumToRemove.Matter(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToRemoveMatter_metas(node: DomainA.SumToRemove.Matter) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumToReplaceWithProduct
        //////////////////////////////////////
        open fun transformSumToReplaceWithProduct(node: DomainA.SumToReplaceWithProduct): DomainA.SumToReplaceWithProduct =
            when(node) {
                is DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant -> transformSumToReplaceWithProductSumToReplaceWithProductVariant(node)
            }
        // Variant SumToReplaceWithProductSumToReplaceWithProductVariant
        open fun transformSumToReplaceWithProductSumToReplaceWithProductVariant(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant): DomainA.SumToReplaceWithProduct {
            val new_t = transformSumToReplaceWithProductSumToReplaceWithProductVariant_t(node)
            val new_metas = transformSumToReplaceWithProductSumToReplaceWithProductVariant_metas(node)
            return if (
                node.t !== new_t ||
                node.metas !== new_metas
            ) {
                DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant(
                    t = new_t,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToReplaceWithProductSumToReplaceWithProductVariant_t(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant) =
            transformProductToRemove(node.t)
        open fun transformSumToReplaceWithProductSumToReplaceWithProductVariant_metas(node: DomainA.SumToReplaceWithProduct.SumToReplaceWithProductVariant) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumA
        //////////////////////////////////////
        open fun transformSumA(node: DomainA.SumA): DomainA.SumA =
            when(node) {
                is DomainA.SumA.Who -> transformSumAWho(node)
                is DomainA.SumA.Cares -> transformSumACares(node)
                is DomainA.SumA.Noti -> transformSumANoti(node)
            }
        // Variant SumAWho
        open fun transformSumAWho(node: DomainA.SumA.Who): DomainA.SumA {
            val new_metas = transformSumAWho_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumA.Who(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumAWho_metas(node: DomainA.SumA.Who) =
            transformMetas(node.metas)
    
        // Variant SumACares
        open fun transformSumACares(node: DomainA.SumA.Cares): DomainA.SumA {
            val new_a = transformSumACares_a(node)
            val new_metas = transformSumACares_metas(node)
            return if (
                node.a !== new_a ||
                node.metas !== new_metas
            ) {
                DomainA.SumA.Cares(
                    a = new_a,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumACares_a(node: DomainA.SumA.Cares) =
            transformProductToRemove(node.a)
        open fun transformSumACares_metas(node: DomainA.SumA.Cares) =
            transformMetas(node.metas)
    
        // Variant SumANoti
        open fun transformSumANoti(node: DomainA.SumA.Noti): DomainA.SumA {
            val new_a = transformSumANoti_a(node)
            val new_metas = transformSumANoti_metas(node)
            return if (
                node.a !== new_a ||
                node.metas !== new_metas
            ) {
                DomainA.SumA.Noti(
                    a = new_a,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumANoti_a(node: DomainA.SumA.Noti) =
            transformProductToRemove(node.a)
        open fun transformSumANoti_metas(node: DomainA.SumA.Noti) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun transformSumB(node: DomainA.SumB): DomainA.SumB =
            when(node) {
                is DomainA.SumB.WillBeUnchanged -> transformSumBWillBeUnchanged(node)
                is DomainA.SumB.WillBeRemoved -> transformSumBWillBeRemoved(node)
                is DomainA.SumB.WillBeReplaced -> transformSumBWillBeReplaced(node)
            }
        // Variant SumBWillBeUnchanged
        open fun transformSumBWillBeUnchanged(node: DomainA.SumB.WillBeUnchanged): DomainA.SumB {
            val new_metas = transformSumBWillBeUnchanged_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeUnchanged(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeUnchanged_metas(node: DomainA.SumB.WillBeUnchanged) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeRemoved
        open fun transformSumBWillBeRemoved(node: DomainA.SumB.WillBeRemoved): DomainA.SumB {
            val new_metas = transformSumBWillBeRemoved_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeRemoved(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeRemoved_metas(node: DomainA.SumB.WillBeRemoved) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeReplaced
        open fun transformSumBWillBeReplaced(node: DomainA.SumB.WillBeReplaced): DomainA.SumB {
            val new_something = transformSumBWillBeReplaced_something(node)
            val new_metas = transformSumBWillBeReplaced_metas(node)
            return if (
                node.something !== new_something ||
                node.metas !== new_metas
            ) {
                DomainA.SumB.WillBeReplaced(
                    something = new_something,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeReplaced_something(node: DomainA.SumB.WillBeReplaced) =
            transformLongPrimitive(node.something)
        open fun transformSumBWillBeReplaced_metas(node: DomainA.SumB.WillBeReplaced) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun transformUnpermutedSum(node: DomainA.UnpermutedSum): DomainA.UnpermutedSum =
            when(node) {
                is DomainA.UnpermutedSum.UnpermutedProductVariant -> transformUnpermutedSumUnpermutedProductVariant(node)
                is DomainA.UnpermutedSum.UnpermutedRecordVariant -> transformUnpermutedSumUnpermutedRecordVariant(node)
            }
        // Variant UnpermutedSumUnpermutedProductVariant
        open fun transformUnpermutedSumUnpermutedProductVariant(node: DomainA.UnpermutedSum.UnpermutedProductVariant): DomainA.UnpermutedSum {
            val new_foo = transformUnpermutedSumUnpermutedProductVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedProductVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedProductVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedSum.UnpermutedProductVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedProductVariant_foo(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedProductVariant_bar(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedProductVariant_metas(node: DomainA.UnpermutedSum.UnpermutedProductVariant) =
            transformMetas(node.metas)
    
        // Variant UnpermutedSumUnpermutedRecordVariant
        open fun transformUnpermutedSumUnpermutedRecordVariant(node: DomainA.UnpermutedSum.UnpermutedRecordVariant): DomainA.UnpermutedSum {
            val new_foo = transformUnpermutedSumUnpermutedRecordVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedRecordVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedRecordVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainA.UnpermutedSum.UnpermutedRecordVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedRecordVariant_foo(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedRecordVariant_bar(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedRecordVariant_metas(node: DomainA.UnpermutedSum.UnpermutedRecordVariant) =
            transformMetas(node.metas)
    
    }
}

