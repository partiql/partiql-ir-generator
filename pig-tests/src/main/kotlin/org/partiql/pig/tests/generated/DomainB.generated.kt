
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*


class DomainB private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = DomainBBuilder
    
        fun <T: DomainBNode> build(block: Builder.() -> T) =
            DomainBBuilder.block()
    
        fun transform(element: AnyElement): DomainBNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): DomainBNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [DomainB.UnpermutedProduct].
         */
        fun unpermutedProduct(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedProduct =
            DomainB.UnpermutedProduct(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProduct_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedProduct =
            DomainB.UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.UnpermutedRecord].
         */
        fun unpermutedRecord(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedRecord =
            DomainB.UnpermutedRecord(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecord_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedRecord =
            DomainB.UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.ProductA].
         */
        fun productA(
            one: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.ProductA =
            DomainB.ProductA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.ProductA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun productA_(
            one: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.ProductA =
            DomainB.ProductA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.RecordA].
         */
        fun recordA(
            one: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.RecordA =
            DomainB.RecordA(
                one = one.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.RecordA].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun recordA_(
            one: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.RecordA =
            DomainB.RecordA(
                one = one,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.SumToReplaceWithProduct].
         */
        fun sumToReplaceWithProduct(
            foo: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumToReplaceWithProduct =
            DomainB.SumToReplaceWithProduct(
                foo = foo.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.SumToReplaceWithProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun sumToReplaceWithProduct_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumToReplaceWithProduct =
            DomainB.SumToReplaceWithProduct(
                foo = foo,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewProduct].
         */
        fun newProduct(
            foo: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewProduct =
            DomainB.NewProduct(
                foo = foo.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.NewProduct].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun newProduct_(
            foo: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewProduct =
            DomainB.NewProduct(
                foo = foo,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewRecord].
         */
        fun newRecord(
            foo: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewRecord =
            DomainB.NewRecord(
                foo = foo.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.NewRecord].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun newRecord_(
            foo: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewRecord =
            DomainB.NewRecord(
                foo = foo,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: UnpermutedSum 
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedProductVariant].
         */
        fun unpermutedProductVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedProductVariant =
            DomainB.UnpermutedSum.UnpermutedProductVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedProductVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedProductVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedProductVariant =
            DomainB.UnpermutedSum.UnpermutedProductVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedRecordVariant].
         */
        fun unpermutedRecordVariant(
            foo: String,
            bar: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedRecordVariant =
            DomainB.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo.asPrimitive(),
                bar = bar.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.UnpermutedSum.UnpermutedRecordVariant].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpermutedRecordVariant_(
            foo: org.partiql.pig.runtime.SymbolPrimitive,
            bar: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.UnpermutedSum.UnpermutedRecordVariant =
            DomainB.UnpermutedSum.UnpermutedRecordVariant(
                foo = foo,
                bar = bar,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SumB 
        /**
         * Creates an instance of [DomainB.SumB.WillBeUnchanged].
         */
        fun willBeUnchanged(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeUnchanged =
            DomainB.SumB.WillBeUnchanged(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.SumB.WillBeReplaced].
         */
        fun willBeReplaced(
            something: String,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeReplaced =
            DomainB.SumB.WillBeReplaced(
                something = something.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [DomainB.SumB.WillBeReplaced].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun willBeReplaced_(
            something: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.SumB.WillBeReplaced =
            DomainB.SumB.WillBeReplaced(
                something = something,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: NewSum 
        /**
         * Creates an instance of [DomainB.NewSum.Eek].
         */
        fun eek(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewSum.Eek =
            DomainB.NewSum.Eek(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [DomainB.NewSum.Whatever].
         */
        fun whatever(
            metas: MetaContainer = emptyMetaContainer()
        ): DomainB.NewSum.Whatever =
            DomainB.NewSum.Whatever(
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object DomainBBuilder : Builder
    
    /** Base class for all DomainB types. */
    abstract class DomainBNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): DomainBNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): DomainBNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class UnpermutedProduct(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProduct =
            UnpermutedProduct(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("unpermuted_product"),
                foo.toIonElement(),
                bar.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedProduct(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedProduct::class.java) return false
    
            other as UnpermutedProduct
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class UnpermutedRecord(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        val bar: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecord =
            UnpermutedRecord(
                foo = foo,
                bar = bar,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("unpermuted_record"),
                ionSexpOf(ionSymbol("foo"), foo.toIonElement()),
                ionSexpOf(ionSymbol("bar"), bar.toIonElement())
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
            metas: MetaContainer = this.metas
        ) =
            UnpermutedRecord(
                foo,
                bar,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != UnpermutedRecord::class.java) return false
    
            other as UnpermutedRecord
            if (foo != other.foo) return false
            if (bar != other.bar) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc = 31 * hc + bar.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ProductA(
        val one: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): ProductA =
            ProductA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ProductA =
            ProductA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("product_a"),
                one.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            one: org.partiql.pig.runtime.SymbolPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            ProductA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ProductA::class.java) return false
    
            other as ProductA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class RecordA(
        val one: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): RecordA =
            RecordA(
                one = one,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): RecordA =
            RecordA(
                one = one,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("record_a"),
                ionSexpOf(ionSymbol("one"), one.toIonElement())
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            one: org.partiql.pig.runtime.SymbolPrimitive = this.one,
            metas: MetaContainer = this.metas
        ) =
            RecordA(
                one,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != RecordA::class.java) return false
    
            other as RecordA
            if (one != other.one) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = one.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SumToReplaceWithProduct(
        val foo: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): SumToReplaceWithProduct =
            SumToReplaceWithProduct(
                foo = foo,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SumToReplaceWithProduct =
            SumToReplaceWithProduct(
                foo = foo,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("sum_to_replace_with_product"),
                foo.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
            metas: MetaContainer = this.metas
        ) =
            SumToReplaceWithProduct(
                foo,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SumToReplaceWithProduct::class.java) return false
    
            other as SumToReplaceWithProduct
            if (foo != other.foo) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class NewProduct(
        val foo: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): NewProduct =
            NewProduct(
                foo = foo,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): NewProduct =
            NewProduct(
                foo = foo,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("new_product"),
                foo.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.LongPrimitive = this.foo,
            metas: MetaContainer = this.metas
        ) =
            NewProduct(
                foo,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != NewProduct::class.java) return false
    
            other as NewProduct
            if (foo != other.foo) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class NewRecord(
        val foo: org.partiql.pig.runtime.LongPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): DomainBNode() {
    
        override fun copy(metas: MetaContainer): NewRecord =
            NewRecord(
                foo = foo,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): NewRecord =
            NewRecord(
                foo = foo,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = listOfNotNull(
                ionSymbol("new_record"),
                ionSexpOf(ionSymbol("foo"), foo.toIonElement())
            )
    
            return ionSexpOf(elements, metas = metas)
        }
    
        fun copy(
            foo: org.partiql.pig.runtime.LongPrimitive = this.foo,
            metas: MetaContainer = this.metas
        ) =
            NewRecord(
                foo,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != NewRecord::class.java) return false
    
            other as NewRecord
            if (foo != other.foo) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = foo.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class UnpermutedSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): UnpermutedSum =
            when (this) {
                is UnpermutedProductVariant -> copy(metas = metas)
                is UnpermutedRecordVariant -> copy(metas = metas)
            }
    
        class UnpermutedProductVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedProductVariant =
                UnpermutedProductVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unpermuted_product_variant"),
                    foo.toIonElement(),
                    bar.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedProductVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedProductVariant::class.java) return false
        
                other as UnpermutedProductVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class UnpermutedRecordVariant(
            val foo: org.partiql.pig.runtime.SymbolPrimitive,
            val bar: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): UnpermutedSum() {
        
            override fun copy(metas: MetaContainer): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UnpermutedRecordVariant =
                UnpermutedRecordVariant(
                    foo = foo,
                    bar = bar,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("unpermuted_record_variant"),
                    ionSexpOf(ionSymbol("foo"), foo.toIonElement()),
                    ionSexpOf(ionSymbol("bar"), bar.toIonElement())
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                foo: org.partiql.pig.runtime.SymbolPrimitive = this.foo,
                bar: org.partiql.pig.runtime.LongPrimitive = this.bar,
                metas: MetaContainer = this.metas
            ) =
                UnpermutedRecordVariant(
                    foo,
                    bar,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UnpermutedRecordVariant::class.java) return false
        
                other as UnpermutedRecordVariant
                if (foo != other.foo) return false
                if (bar != other.bar) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = foo.hashCode()
                hc = 31 * hc + bar.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainB.UnpermutedSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.UnpermutedSum): T = when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> convertUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> convertUnpermutedRecordVariant(node)
            }
    
            fun convertUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant): T
            fun convertUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant): T
        }
    }
    
    sealed class SumB(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): SumB =
            when (this) {
                is WillBeUnchanged -> copy(metas = metas)
                is WillBeReplaced -> copy(metas = metas)
            }
    
        class WillBeUnchanged(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeUnchanged =
                WillBeUnchanged(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_unchanged"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeUnchanged::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class WillBeReplaced(
            val something: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): SumB() {
        
            override fun copy(metas: MetaContainer): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): WillBeReplaced =
                WillBeReplaced(
                    something = something,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("will_be_replaced"),
                    something.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                something: org.partiql.pig.runtime.SymbolPrimitive = this.something,
                metas: MetaContainer = this.metas
            ) =
                WillBeReplaced(
                    something,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != WillBeReplaced::class.java) return false
        
                other as WillBeReplaced
                if (something != other.something) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = something.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [DomainB.SumB] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.SumB): T = when(node) {
                is DomainB.SumB.WillBeUnchanged -> convertWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> convertWillBeReplaced(node)
            }
    
            fun convertWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged): T
            fun convertWillBeReplaced(node: DomainB.SumB.WillBeReplaced): T
        }
    }
    
    sealed class NewSum(override val metas: MetaContainer = emptyMetaContainer()) : DomainBNode() {
        override fun copy(metas: MetaContainer): NewSum =
            when (this) {
                is Eek -> copy(metas = metas)
                is Whatever -> copy(metas = metas)
            }
    
        class Eek(
            override val metas: MetaContainer = emptyMetaContainer()
        ): NewSum() {
        
            override fun copy(metas: MetaContainer): Eek =
                Eek(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Eek =
                Eek(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("eek"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Eek::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Whatever(
            override val metas: MetaContainer = emptyMetaContainer()
        ): NewSum() {
        
            override fun copy(metas: MetaContainer): Whatever =
                Whatever(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Whatever =
                Whatever(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("whatever"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Whatever::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        /** Converts instances of [DomainB.NewSum] to any [T]. */
        interface Converter<T> {
            fun convert(node: DomainB.NewSum): T = when(node) {
                is DomainB.NewSum.Eek -> convertEek(node)
                is DomainB.NewSum.Whatever -> convertWhatever(node)
            }
    
            fun convertEek(node: DomainB.NewSum.Eek): T
            fun convertWhatever(node: DomainB.NewSum.Whatever): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<DomainBNode>() {
    
        override fun innerTransform(sexp: SexpElement): DomainBNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "unpermuted_product" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainB.UnpermutedProduct(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedRecord(foo, bar, metas = sexp.metas)
                }
                "product_a" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val one = sexp.getRequired(0).toSymbolPrimitive()
                    DomainB.ProductA(
                        one,
                        metas = sexp.metas)
                }
                "record_a" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val one = ir.processRequiredField("one") { it.toSymbolPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    RecordA(one, metas = sexp.metas)
                }
                "sum_to_replace_with_product" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    DomainB.SumToReplaceWithProduct(
                        foo,
                        metas = sexp.metas)
                }
                "new_product" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val foo = sexp.getRequired(0).toLongPrimitive()
                    DomainB.NewProduct(
                        foo,
                        metas = sexp.metas)
                }
                "new_record" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    NewRecord(foo, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'UnpermutedSum'
                //////////////////////////////////////
                "unpermuted_product_variant" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val foo = sexp.getRequired(0).toSymbolPrimitive()
                    val bar = sexp.getRequired(1).toLongPrimitive()
                    DomainB.UnpermutedSum.UnpermutedProductVariant(
                        foo,
                        bar,
                        metas = sexp.metas)
                }
                "unpermuted_record_variant" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val foo = ir.processRequiredField("foo") { it.toSymbolPrimitive() }
                    val bar = ir.processRequiredField("bar") { it.toLongPrimitive() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    UnpermutedSum.UnpermutedRecordVariant(foo, bar, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SumB'
                //////////////////////////////////////
                "will_be_unchanged" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.SumB.WillBeUnchanged(
                        metas = sexp.metas)
                }
                "will_be_replaced" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val something = sexp.getRequired(0).toSymbolPrimitive()
                    DomainB.SumB.WillBeReplaced(
                        something,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'NewSum'
                //////////////////////////////////////
                "eek" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.NewSum.Eek(
                        metas = sexp.metas)
                }
                "whatever" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    DomainB.NewSum.Whatever(
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'domain_b'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitUnpermutedProduct(node: DomainB.UnpermutedProduct) { }
        open fun visitUnpermutedRecord(node: DomainB.UnpermutedRecord) { }
        open fun visitProductA(node: DomainB.ProductA) { }
        open fun visitRecordA(node: DomainB.RecordA) { }
        open fun visitSumToReplaceWithProduct(node: DomainB.SumToReplaceWithProduct) { }
        open fun visitNewProduct(node: DomainB.NewProduct) { }
        open fun visitNewRecord(node: DomainB.NewRecord) { }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        protected open fun visitUnpermutedSum(node: DomainB.UnpermutedSum) { }
        protected open fun visitUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant) { }
        protected open fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) { }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        protected open fun visitSumB(node: DomainB.SumB) { }
        protected open fun visitSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged) { }
        protected open fun visitSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced) { }
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        protected open fun visitNewSum(node: DomainB.NewSum) { }
        protected open fun visitNewSumEek(node: DomainB.NewSum.Eek) { }
        protected open fun visitNewSumWhatever(node: DomainB.NewSum.Whatever) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkUnpermutedProduct(node: DomainB.UnpermutedProduct) {
            visitUnpermutedProduct(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
        open fun walkUnpermutedRecord(node: DomainB.UnpermutedRecord) {
            visitUnpermutedRecord(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
        open fun walkProductA(node: DomainB.ProductA) {
            visitProductA(node)
            walkSymbolPrimitive(node.one)
            walkMetas(node.metas)
        }
        open fun walkRecordA(node: DomainB.RecordA) {
            visitRecordA(node)
            walkSymbolPrimitive(node.one)
            walkMetas(node.metas)
        }
        open fun walkSumToReplaceWithProduct(node: DomainB.SumToReplaceWithProduct) {
            visitSumToReplaceWithProduct(node)
            walkSymbolPrimitive(node.foo)
            walkMetas(node.metas)
        }
        open fun walkNewProduct(node: DomainB.NewProduct) {
            visitNewProduct(node)
            walkLongPrimitive(node.foo)
            walkMetas(node.metas)
        }
        open fun walkNewRecord(node: DomainB.NewRecord) {
            visitNewRecord(node)
            walkLongPrimitive(node.foo)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainB.UnpermutedSum) {
            visitUnpermutedSum(node)
            when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant) {
            visitUnpermutedSumUnpermutedProductVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) {
            visitUnpermutedSumUnpermutedRecordVariant(node)
            walkSymbolPrimitive(node.foo)
            walkLongPrimitive(node.bar)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainB.SumB) {
            visitSumB(node)
            when(node) {
                is DomainB.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged) {
            visitSumBWillBeUnchanged(node)
            walkMetas(node.metas)
        }
        open fun walkSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced) {
            visitSumBWillBeReplaced(node)
            walkSymbolPrimitive(node.something)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun walkNewSum(node: DomainB.NewSum) {
            visitNewSum(node)
            when(node) {
                is DomainB.NewSum.Eek -> walkNewSumEek(node)
                is DomainB.NewSum.Whatever -> walkNewSumWhatever(node)
            }
        }
    
        open fun walkNewSumEek(node: DomainB.NewSum.Eek) {
            visitNewSumEek(node)
            walkMetas(node.metas)
        }
        open fun walkNewSumWhatever(node: DomainB.NewSum.Whatever) {
            visitNewSumWhatever(node)
            walkMetas(node.metas)
        }
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitUnpermutedProduct(node: DomainB.UnpermutedProduct, accumulator: T): T = accumulator
        open protected fun visitUnpermutedRecord(node: DomainB.UnpermutedRecord, accumulator: T): T = accumulator
        open protected fun visitProductA(node: DomainB.ProductA, accumulator: T): T = accumulator
        open protected fun visitRecordA(node: DomainB.RecordA, accumulator: T): T = accumulator
        open protected fun visitSumToReplaceWithProduct(node: DomainB.SumToReplaceWithProduct, accumulator: T): T = accumulator
        open protected fun visitNewProduct(node: DomainB.NewProduct, accumulator: T): T = accumulator
        open protected fun visitNewRecord(node: DomainB.NewRecord, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open protected fun visitUnpermutedSum(node: DomainB.UnpermutedSum, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T = accumulator
        open protected fun visitUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open protected fun visitSumB(node: DomainB.SumB, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged, accumulator: T): T = accumulator
        open protected fun visitSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open protected fun visitNewSum(node: DomainB.NewSum, accumulator: T): T = accumulator
        open protected fun visitNewSumEek(node: DomainB.NewSum.Eek, accumulator: T): T = accumulator
        open protected fun visitNewSumWhatever(node: DomainB.NewSum.Whatever, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkUnpermutedProduct(node: DomainB.UnpermutedProduct, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedProduct(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedRecord(node: DomainB.UnpermutedRecord, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedRecord(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProductA(node: DomainB.ProductA, accumulator: T): T {
            var current = accumulator
            current = visitProductA(node, current)
            current = walkSymbolPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkRecordA(node: DomainB.RecordA, accumulator: T): T {
            var current = accumulator
            current = visitRecordA(node, current)
            current = walkSymbolPrimitive(node.one, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumToReplaceWithProduct(node: DomainB.SumToReplaceWithProduct, accumulator: T): T {
            var current = accumulator
            current = visitSumToReplaceWithProduct(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewProduct(node: DomainB.NewProduct, accumulator: T): T {
            var current = accumulator
            current = visitNewProduct(node, current)
            current = walkLongPrimitive(node.foo, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewRecord(node: DomainB.NewRecord, accumulator: T): T {
            var current = accumulator
            current = visitNewRecord(node, current)
            current = walkLongPrimitive(node.foo, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun walkUnpermutedSum(node: DomainB.UnpermutedSum, accumulator: T): T {
            val current = visitUnpermutedSum(node, accumulator)
            return when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> walkUnpermutedSumUnpermutedProductVariant(node, current)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> walkUnpermutedSumUnpermutedRecordVariant(node, current)
            }
        }
    
        open fun walkUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedProductVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant, accumulator: T): T {
            var current = accumulator
            current = visitUnpermutedSumUnpermutedRecordVariant(node, current)
            current = walkSymbolPrimitive(node.foo, current)
            current = walkLongPrimitive(node.bar, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun walkSumB(node: DomainB.SumB, accumulator: T): T {
            val current = visitSumB(node, accumulator)
            return when(node) {
                is DomainB.SumB.WillBeUnchanged -> walkSumBWillBeUnchanged(node, current)
                is DomainB.SumB.WillBeReplaced -> walkSumBWillBeReplaced(node, current)
            }
        }
    
        open fun walkSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeUnchanged(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced, accumulator: T): T {
            var current = accumulator
            current = visitSumBWillBeReplaced(node, current)
            current = walkSymbolPrimitive(node.something, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun walkNewSum(node: DomainB.NewSum, accumulator: T): T {
            val current = visitNewSum(node, accumulator)
            return when(node) {
                is DomainB.NewSum.Eek -> walkNewSumEek(node, current)
                is DomainB.NewSum.Whatever -> walkNewSumWhatever(node, current)
            }
        }
    
        open fun walkNewSumEek(node: DomainB.NewSum.Eek, accumulator: T): T {
            var current = accumulator
            current = visitNewSumEek(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkNewSumWhatever(node: DomainB.NewSum.Whatever, accumulator: T): T {
            var current = accumulator
            current = visitNewSumWhatever(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple UnpermutedProduct
        open fun transformUnpermutedProduct(node: DomainB.UnpermutedProduct): DomainB.UnpermutedProduct {
            val new_foo = transformUnpermutedProduct_foo(node)
            val new_bar = transformUnpermutedProduct_bar(node)
            val new_metas = transformUnpermutedProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedProduct(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedProduct_foo(node: DomainB.UnpermutedProduct) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedProduct_bar(node: DomainB.UnpermutedProduct) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedProduct_metas(node: DomainB.UnpermutedProduct) =
            transformMetas(node.metas)
    
        // Tuple UnpermutedRecord
        open fun transformUnpermutedRecord(node: DomainB.UnpermutedRecord): DomainB.UnpermutedRecord {
            val new_foo = transformUnpermutedRecord_foo(node)
            val new_bar = transformUnpermutedRecord_bar(node)
            val new_metas = transformUnpermutedRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedRecord(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedRecord_foo(node: DomainB.UnpermutedRecord) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedRecord_bar(node: DomainB.UnpermutedRecord) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedRecord_metas(node: DomainB.UnpermutedRecord) =
            transformMetas(node.metas)
    
        // Tuple ProductA
        open fun transformProductA(node: DomainB.ProductA): DomainB.ProductA {
            val new_one = transformProductA_one(node)
            val new_metas = transformProductA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainB.ProductA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProductA_one(node: DomainB.ProductA) =
            transformSymbolPrimitive(node.one)
        open fun transformProductA_metas(node: DomainB.ProductA) =
            transformMetas(node.metas)
    
        // Tuple RecordA
        open fun transformRecordA(node: DomainB.RecordA): DomainB.RecordA {
            val new_one = transformRecordA_one(node)
            val new_metas = transformRecordA_metas(node)
            return if (
                node.one !== new_one ||
                node.metas !== new_metas
            ) {
                DomainB.RecordA(
                    one = new_one,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformRecordA_one(node: DomainB.RecordA) =
            transformSymbolPrimitive(node.one)
        open fun transformRecordA_metas(node: DomainB.RecordA) =
            transformMetas(node.metas)
    
        // Tuple SumToReplaceWithProduct
        open fun transformSumToReplaceWithProduct(node: DomainB.SumToReplaceWithProduct): DomainB.SumToReplaceWithProduct {
            val new_foo = transformSumToReplaceWithProduct_foo(node)
            val new_metas = transformSumToReplaceWithProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.metas !== new_metas
            ) {
                DomainB.SumToReplaceWithProduct(
                    foo = new_foo,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumToReplaceWithProduct_foo(node: DomainB.SumToReplaceWithProduct) =
            transformSymbolPrimitive(node.foo)
        open fun transformSumToReplaceWithProduct_metas(node: DomainB.SumToReplaceWithProduct) =
            transformMetas(node.metas)
    
        // Tuple NewProduct
        open fun transformNewProduct(node: DomainB.NewProduct): DomainB.NewProduct {
            val new_foo = transformNewProduct_foo(node)
            val new_metas = transformNewProduct_metas(node)
            return if (
                node.foo !== new_foo ||
                node.metas !== new_metas
            ) {
                DomainB.NewProduct(
                    foo = new_foo,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewProduct_foo(node: DomainB.NewProduct) =
            transformLongPrimitive(node.foo)
        open fun transformNewProduct_metas(node: DomainB.NewProduct) =
            transformMetas(node.metas)
    
        // Tuple NewRecord
        open fun transformNewRecord(node: DomainB.NewRecord): DomainB.NewRecord {
            val new_foo = transformNewRecord_foo(node)
            val new_metas = transformNewRecord_metas(node)
            return if (
                node.foo !== new_foo ||
                node.metas !== new_metas
            ) {
                DomainB.NewRecord(
                    foo = new_foo,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewRecord_foo(node: DomainB.NewRecord) =
            transformLongPrimitive(node.foo)
        open fun transformNewRecord_metas(node: DomainB.NewRecord) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: UnpermutedSum
        //////////////////////////////////////
        open fun transformUnpermutedSum(node: DomainB.UnpermutedSum): DomainB.UnpermutedSum =
            when(node) {
                is DomainB.UnpermutedSum.UnpermutedProductVariant -> transformUnpermutedSumUnpermutedProductVariant(node)
                is DomainB.UnpermutedSum.UnpermutedRecordVariant -> transformUnpermutedSumUnpermutedRecordVariant(node)
            }
        // Variant UnpermutedSumUnpermutedProductVariant
        open fun transformUnpermutedSumUnpermutedProductVariant(node: DomainB.UnpermutedSum.UnpermutedProductVariant): DomainB.UnpermutedSum {
            val new_foo = transformUnpermutedSumUnpermutedProductVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedProductVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedProductVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedSum.UnpermutedProductVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedProductVariant_foo(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedProductVariant_bar(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedProductVariant_metas(node: DomainB.UnpermutedSum.UnpermutedProductVariant) =
            transformMetas(node.metas)
    
        // Variant UnpermutedSumUnpermutedRecordVariant
        open fun transformUnpermutedSumUnpermutedRecordVariant(node: DomainB.UnpermutedSum.UnpermutedRecordVariant): DomainB.UnpermutedSum {
            val new_foo = transformUnpermutedSumUnpermutedRecordVariant_foo(node)
            val new_bar = transformUnpermutedSumUnpermutedRecordVariant_bar(node)
            val new_metas = transformUnpermutedSumUnpermutedRecordVariant_metas(node)
            return if (
                node.foo !== new_foo ||
                node.bar !== new_bar ||
                node.metas !== new_metas
            ) {
                DomainB.UnpermutedSum.UnpermutedRecordVariant(
                    foo = new_foo,
                    bar = new_bar,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformUnpermutedSumUnpermutedRecordVariant_foo(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformSymbolPrimitive(node.foo)
        open fun transformUnpermutedSumUnpermutedRecordVariant_bar(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformLongPrimitive(node.bar)
        open fun transformUnpermutedSumUnpermutedRecordVariant_metas(node: DomainB.UnpermutedSum.UnpermutedRecordVariant) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SumB
        //////////////////////////////////////
        open fun transformSumB(node: DomainB.SumB): DomainB.SumB =
            when(node) {
                is DomainB.SumB.WillBeUnchanged -> transformSumBWillBeUnchanged(node)
                is DomainB.SumB.WillBeReplaced -> transformSumBWillBeReplaced(node)
            }
        // Variant SumBWillBeUnchanged
        open fun transformSumBWillBeUnchanged(node: DomainB.SumB.WillBeUnchanged): DomainB.SumB {
            val new_metas = transformSumBWillBeUnchanged_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.SumB.WillBeUnchanged(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeUnchanged_metas(node: DomainB.SumB.WillBeUnchanged) =
            transformMetas(node.metas)
    
        // Variant SumBWillBeReplaced
        open fun transformSumBWillBeReplaced(node: DomainB.SumB.WillBeReplaced): DomainB.SumB {
            val new_something = transformSumBWillBeReplaced_something(node)
            val new_metas = transformSumBWillBeReplaced_metas(node)
            return if (
                node.something !== new_something ||
                node.metas !== new_metas
            ) {
                DomainB.SumB.WillBeReplaced(
                    something = new_something,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSumBWillBeReplaced_something(node: DomainB.SumB.WillBeReplaced) =
            transformSymbolPrimitive(node.something)
        open fun transformSumBWillBeReplaced_metas(node: DomainB.SumB.WillBeReplaced) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: NewSum
        //////////////////////////////////////
        open fun transformNewSum(node: DomainB.NewSum): DomainB.NewSum =
            when(node) {
                is DomainB.NewSum.Eek -> transformNewSumEek(node)
                is DomainB.NewSum.Whatever -> transformNewSumWhatever(node)
            }
        // Variant NewSumEek
        open fun transformNewSumEek(node: DomainB.NewSum.Eek): DomainB.NewSum {
            val new_metas = transformNewSumEek_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.NewSum.Eek(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewSumEek_metas(node: DomainB.NewSum.Eek) =
            transformMetas(node.metas)
    
        // Variant NewSumWhatever
        open fun transformNewSumWhatever(node: DomainB.NewSum.Whatever): DomainB.NewSum {
            val new_metas = transformNewSumWhatever_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                DomainB.NewSum.Whatever(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformNewSumWhatever_metas(node: DomainB.NewSum.Whatever) =
            transformMetas(node.metas)
    
    }
}

