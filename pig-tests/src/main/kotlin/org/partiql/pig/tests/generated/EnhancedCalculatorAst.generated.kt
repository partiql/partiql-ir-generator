
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*


class EnhancedCalculatorAst private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = EnhancedCalculatorAstBuilder
    
        fun <T: EnhancedCalculatorAstNode> build(block: Builder.() -> T) =
            EnhancedCalculatorAstBuilder.block()
    
        fun transform(element: AnyElement): EnhancedCalculatorAstNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): EnhancedCalculatorAstNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Lit].
         */
        fun lit(
            value: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Lit =
            EnhancedCalculatorAst.Expr.Lit(
                value = value.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Lit].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun lit_(
            value: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Lit =
            EnhancedCalculatorAst.Expr.Lit(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Binary].
         */
        fun binary(
            op: Operator,
            left: Expr,
            right: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Binary =
            EnhancedCalculatorAst.Expr.Binary(
                op = op,
                left = left,
                right = right,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Let].
         */
        fun let(
            name: String,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Let =
            EnhancedCalculatorAst.Expr.Let(
                name = name.asPrimitive(),
                value = value,
                body = body,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Let].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun let_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            value: Expr,
            body: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Let =
            EnhancedCalculatorAst.Expr.Let(
                name = name,
                value = value,
                body = body,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Variable].
         */
        fun variable(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Variable =
            EnhancedCalculatorAst.Expr.Variable(
                name = name.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Expr.Variable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun variable_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Expr.Variable =
            EnhancedCalculatorAst.Expr.Variable(
                name = name,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Operator 
        /**
         * Creates an instance of [EnhancedCalculatorAst.Operator.Plus].
         */
        fun plus(
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Operator.Plus =
            EnhancedCalculatorAst.Operator.Plus(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Operator.Minus].
         */
        fun minus(
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Operator.Minus =
            EnhancedCalculatorAst.Operator.Minus(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Operator.Times].
         */
        fun times(
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Operator.Times =
            EnhancedCalculatorAst.Operator.Times(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Operator.Divide].
         */
        fun divide(
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Operator.Divide =
            EnhancedCalculatorAst.Operator.Divide(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [EnhancedCalculatorAst.Operator.Modulo].
         */
        fun modulo(
            metas: MetaContainer = emptyMetaContainer()
        ): EnhancedCalculatorAst.Operator.Modulo =
            EnhancedCalculatorAst.Operator.Modulo(
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object EnhancedCalculatorAstBuilder : Builder
    
    /** Base class for all EnhancedCalculatorAst types. */
    abstract class EnhancedCalculatorAstNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): EnhancedCalculatorAstNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): EnhancedCalculatorAstNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : EnhancedCalculatorAstNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Lit -> copy(metas = metas)
                is Binary -> copy(metas = metas)
                is Let -> copy(metas = metas)
                is Variable -> copy(metas = metas)
            }
    
        class Lit(
            val value: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Binary(
            val op: Operator,
            val left: Expr,
            val right: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Binary =
                Binary(
                    op = op,
                    left = left,
                    right = right,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Binary =
                Binary(
                    op = op,
                    left = left,
                    right = right,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("binary"),
                    op.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                op: Operator = this.op,
                left: Expr = this.left,
                right: Expr = this.right,
                metas: MetaContainer = this.metas
            ) =
                Binary(
                    op,
                    left,
                    right,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Binary::class.java) return false
        
                other as Binary
                if (op != other.op) return false
                if (left != other.left) return false
                if (right != other.right) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = op.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Let(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val value: Expr,
            val body: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Let =
                Let(
                    name = name,
                    value = value,
                    body = body,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("let"),
                    name.toIonElement(),
                    value.toIonElement(),
                    body.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                value: Expr = this.value,
                body: Expr = this.body,
                metas: MetaContainer = this.metas
            ) =
                Let(
                    name,
                    value,
                    body,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Let::class.java) return false
        
                other as Let
                if (name != other.name) return false
                if (value != other.value) return false
                if (body != other.body) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + body.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Variable(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Variable =
                Variable(
                    name = name,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Variable =
                Variable(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("variable"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                metas: MetaContainer = this.metas
            ) =
                Variable(
                    name,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Variable::class.java) return false
        
                other as Variable
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [EnhancedCalculatorAst.Expr] to any [T]. */
        interface Converter<T> {
            fun convert(node: EnhancedCalculatorAst.Expr): T = when(node) {
                is EnhancedCalculatorAst.Expr.Lit -> convertLit(node)
                is EnhancedCalculatorAst.Expr.Binary -> convertBinary(node)
                is EnhancedCalculatorAst.Expr.Let -> convertLet(node)
                is EnhancedCalculatorAst.Expr.Variable -> convertVariable(node)
            }
    
            fun convertLit(node: EnhancedCalculatorAst.Expr.Lit): T
            fun convertBinary(node: EnhancedCalculatorAst.Expr.Binary): T
            fun convertLet(node: EnhancedCalculatorAst.Expr.Let): T
            fun convertVariable(node: EnhancedCalculatorAst.Expr.Variable): T
        }
    }
    
    sealed class Operator(override val metas: MetaContainer = emptyMetaContainer()) : EnhancedCalculatorAstNode() {
        override fun copy(metas: MetaContainer): Operator =
            when (this) {
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
            }
    
        class Plus(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class Minus(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2001
        }
    
        class Times(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2002
        }
    
        class Divide(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2003
        }
    
        class Modulo(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2004
        }
    
        /** Converts instances of [EnhancedCalculatorAst.Operator] to any [T]. */
        interface Converter<T> {
            fun convert(node: EnhancedCalculatorAst.Operator): T = when(node) {
                is EnhancedCalculatorAst.Operator.Plus -> convertPlus(node)
                is EnhancedCalculatorAst.Operator.Minus -> convertMinus(node)
                is EnhancedCalculatorAst.Operator.Times -> convertTimes(node)
                is EnhancedCalculatorAst.Operator.Divide -> convertDivide(node)
                is EnhancedCalculatorAst.Operator.Modulo -> convertModulo(node)
            }
    
            fun convertPlus(node: EnhancedCalculatorAst.Operator.Plus): T
            fun convertMinus(node: EnhancedCalculatorAst.Operator.Minus): T
            fun convertTimes(node: EnhancedCalculatorAst.Operator.Times): T
            fun convertDivide(node: EnhancedCalculatorAst.Operator.Divide): T
            fun convertModulo(node: EnhancedCalculatorAst.Operator.Modulo): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<EnhancedCalculatorAstNode>() {
    
        override fun innerTransform(sexp: SexpElement): EnhancedCalculatorAstNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    EnhancedCalculatorAst.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "binary" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val op = sexp.getRequired(0).transformExpect<Operator>()
                    val left = sexp.getRequired(1).transformExpect<Expr>()
                    val right = sexp.getRequired(2).transformExpect<Expr>()
                    EnhancedCalculatorAst.Expr.Binary(
                        op,
                        left,
                        right,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val body = sexp.getRequired(2).transformExpect<Expr>()
                    EnhancedCalculatorAst.Expr.Let(
                        name,
                        value,
                        body,
                        metas = sexp.metas)
                }
                "variable" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    EnhancedCalculatorAst.Expr.Variable(
                        name,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Operator'
                //////////////////////////////////////
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    EnhancedCalculatorAst.Operator.Plus(
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    EnhancedCalculatorAst.Operator.Minus(
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    EnhancedCalculatorAst.Operator.Times(
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    EnhancedCalculatorAst.Operator.Divide(
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    EnhancedCalculatorAst.Operator.Modulo(
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'enhanced_calculator_ast'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: EnhancedCalculatorAst.Expr) { }
        protected open fun visitExprLit(node: EnhancedCalculatorAst.Expr.Lit) { }
        protected open fun visitExprBinary(node: EnhancedCalculatorAst.Expr.Binary) { }
        protected open fun visitExprLet(node: EnhancedCalculatorAst.Expr.Let) { }
        protected open fun visitExprVariable(node: EnhancedCalculatorAst.Expr.Variable) { }
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        protected open fun visitOperator(node: EnhancedCalculatorAst.Operator) { }
        protected open fun visitOperatorPlus(node: EnhancedCalculatorAst.Operator.Plus) { }
        protected open fun visitOperatorMinus(node: EnhancedCalculatorAst.Operator.Minus) { }
        protected open fun visitOperatorTimes(node: EnhancedCalculatorAst.Operator.Times) { }
        protected open fun visitOperatorDivide(node: EnhancedCalculatorAst.Operator.Divide) { }
        protected open fun visitOperatorModulo(node: EnhancedCalculatorAst.Operator.Modulo) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: EnhancedCalculatorAst.Expr) {
            visitExpr(node)
            when(node) {
                is EnhancedCalculatorAst.Expr.Lit -> walkExprLit(node)
                is EnhancedCalculatorAst.Expr.Binary -> walkExprBinary(node)
                is EnhancedCalculatorAst.Expr.Let -> walkExprLet(node)
                is EnhancedCalculatorAst.Expr.Variable -> walkExprVariable(node)
            }
        }
    
        open fun walkExprLit(node: EnhancedCalculatorAst.Expr.Lit) {
            visitExprLit(node)
            walkLongPrimitive(node.value)
            walkMetas(node.metas)
        }
        open fun walkExprBinary(node: EnhancedCalculatorAst.Expr.Binary) {
            visitExprBinary(node)
            walkOperator(node.op)
            walkExpr(node.left)
            walkExpr(node.right)
            walkMetas(node.metas)
        }
        open fun walkExprLet(node: EnhancedCalculatorAst.Expr.Let) {
            visitExprLet(node)
            walkSymbolPrimitive(node.name)
            walkExpr(node.value)
            walkExpr(node.body)
            walkMetas(node.metas)
        }
        open fun walkExprVariable(node: EnhancedCalculatorAst.Expr.Variable) {
            visitExprVariable(node)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun walkOperator(node: EnhancedCalculatorAst.Operator) {
            visitOperator(node)
            when(node) {
                is EnhancedCalculatorAst.Operator.Plus -> walkOperatorPlus(node)
                is EnhancedCalculatorAst.Operator.Minus -> walkOperatorMinus(node)
                is EnhancedCalculatorAst.Operator.Times -> walkOperatorTimes(node)
                is EnhancedCalculatorAst.Operator.Divide -> walkOperatorDivide(node)
                is EnhancedCalculatorAst.Operator.Modulo -> walkOperatorModulo(node)
            }
        }
    
        open fun walkOperatorPlus(node: EnhancedCalculatorAst.Operator.Plus) {
            visitOperatorPlus(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorMinus(node: EnhancedCalculatorAst.Operator.Minus) {
            visitOperatorMinus(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorTimes(node: EnhancedCalculatorAst.Operator.Times) {
            visitOperatorTimes(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorDivide(node: EnhancedCalculatorAst.Operator.Divide) {
            visitOperatorDivide(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorModulo(node: EnhancedCalculatorAst.Operator.Modulo) {
            visitOperatorModulo(node)
            walkMetas(node.metas)
        }
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: EnhancedCalculatorAst.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: EnhancedCalculatorAst.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprBinary(node: EnhancedCalculatorAst.Expr.Binary, accumulator: T): T = accumulator
        open protected fun visitExprLet(node: EnhancedCalculatorAst.Expr.Let, accumulator: T): T = accumulator
        open protected fun visitExprVariable(node: EnhancedCalculatorAst.Expr.Variable, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open protected fun visitOperator(node: EnhancedCalculatorAst.Operator, accumulator: T): T = accumulator
        open protected fun visitOperatorPlus(node: EnhancedCalculatorAst.Operator.Plus, accumulator: T): T = accumulator
        open protected fun visitOperatorMinus(node: EnhancedCalculatorAst.Operator.Minus, accumulator: T): T = accumulator
        open protected fun visitOperatorTimes(node: EnhancedCalculatorAst.Operator.Times, accumulator: T): T = accumulator
        open protected fun visitOperatorDivide(node: EnhancedCalculatorAst.Operator.Divide, accumulator: T): T = accumulator
        open protected fun visitOperatorModulo(node: EnhancedCalculatorAst.Operator.Modulo, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: EnhancedCalculatorAst.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is EnhancedCalculatorAst.Expr.Lit -> walkExprLit(node, current)
                is EnhancedCalculatorAst.Expr.Binary -> walkExprBinary(node, current)
                is EnhancedCalculatorAst.Expr.Let -> walkExprLet(node, current)
                is EnhancedCalculatorAst.Expr.Variable -> walkExprVariable(node, current)
            }
        }
    
        open fun walkExprLit(node: EnhancedCalculatorAst.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBinary(node: EnhancedCalculatorAst.Expr.Binary, accumulator: T): T {
            var current = accumulator
            current = visitExprBinary(node, current)
            current = walkOperator(node.op, current)
            current = walkExpr(node.left, current)
            current = walkExpr(node.right, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLet(node: EnhancedCalculatorAst.Expr.Let, accumulator: T): T {
            var current = accumulator
            current = visitExprLet(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.body, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprVariable(node: EnhancedCalculatorAst.Expr.Variable, accumulator: T): T {
            var current = accumulator
            current = visitExprVariable(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun walkOperator(node: EnhancedCalculatorAst.Operator, accumulator: T): T {
            val current = visitOperator(node, accumulator)
            return when(node) {
                is EnhancedCalculatorAst.Operator.Plus -> walkOperatorPlus(node, current)
                is EnhancedCalculatorAst.Operator.Minus -> walkOperatorMinus(node, current)
                is EnhancedCalculatorAst.Operator.Times -> walkOperatorTimes(node, current)
                is EnhancedCalculatorAst.Operator.Divide -> walkOperatorDivide(node, current)
                is EnhancedCalculatorAst.Operator.Modulo -> walkOperatorModulo(node, current)
            }
        }
    
        open fun walkOperatorPlus(node: EnhancedCalculatorAst.Operator.Plus, accumulator: T): T {
            var current = accumulator
            current = visitOperatorPlus(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorMinus(node: EnhancedCalculatorAst.Operator.Minus, accumulator: T): T {
            var current = accumulator
            current = visitOperatorMinus(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorTimes(node: EnhancedCalculatorAst.Operator.Times, accumulator: T): T {
            var current = accumulator
            current = visitOperatorTimes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorDivide(node: EnhancedCalculatorAst.Operator.Divide, accumulator: T): T {
            var current = accumulator
            current = visitOperatorDivide(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorModulo(node: EnhancedCalculatorAst.Operator.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitOperatorModulo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: EnhancedCalculatorAst.Expr): EnhancedCalculatorAst.Expr =
            when(node) {
                is EnhancedCalculatorAst.Expr.Lit -> transformExprLit(node)
                is EnhancedCalculatorAst.Expr.Binary -> transformExprBinary(node)
                is EnhancedCalculatorAst.Expr.Let -> transformExprLet(node)
                is EnhancedCalculatorAst.Expr.Variable -> transformExprVariable(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: EnhancedCalculatorAst.Expr.Lit): EnhancedCalculatorAst.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: EnhancedCalculatorAst.Expr.Lit) =
            transformLongPrimitive(node.value)
        open fun transformExprLit_metas(node: EnhancedCalculatorAst.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprBinary
        open fun transformExprBinary(node: EnhancedCalculatorAst.Expr.Binary): EnhancedCalculatorAst.Expr {
            val new_op = transformExprBinary_op(node)
            val new_left = transformExprBinary_left(node)
            val new_right = transformExprBinary_right(node)
            val new_metas = transformExprBinary_metas(node)
            return if (
                node.op !== new_op ||
                node.left !== new_left ||
                node.right !== new_right ||
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Expr.Binary(
                    op = new_op,
                    left = new_left,
                    right = new_right,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBinary_op(node: EnhancedCalculatorAst.Expr.Binary) =
            transformOperator(node.op)
        open fun transformExprBinary_left(node: EnhancedCalculatorAst.Expr.Binary) =
            transformExpr(node.left)
        open fun transformExprBinary_right(node: EnhancedCalculatorAst.Expr.Binary) =
            transformExpr(node.right)
        open fun transformExprBinary_metas(node: EnhancedCalculatorAst.Expr.Binary) =
            transformMetas(node.metas)
    
        // Variant ExprLet
        open fun transformExprLet(node: EnhancedCalculatorAst.Expr.Let): EnhancedCalculatorAst.Expr {
            val new_name = transformExprLet_name(node)
            val new_value = transformExprLet_value(node)
            val new_body = transformExprLet_body(node)
            val new_metas = transformExprLet_metas(node)
            return if (
                node.name !== new_name ||
                node.value !== new_value ||
                node.body !== new_body ||
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Expr.Let(
                    name = new_name,
                    value = new_value,
                    body = new_body,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLet_name(node: EnhancedCalculatorAst.Expr.Let) =
            transformSymbolPrimitive(node.name)
        open fun transformExprLet_value(node: EnhancedCalculatorAst.Expr.Let) =
            transformExpr(node.value)
        open fun transformExprLet_body(node: EnhancedCalculatorAst.Expr.Let) =
            transformExpr(node.body)
        open fun transformExprLet_metas(node: EnhancedCalculatorAst.Expr.Let) =
            transformMetas(node.metas)
    
        // Variant ExprVariable
        open fun transformExprVariable(node: EnhancedCalculatorAst.Expr.Variable): EnhancedCalculatorAst.Expr {
            val new_name = transformExprVariable_name(node)
            val new_metas = transformExprVariable_metas(node)
            return if (
                node.name !== new_name ||
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Expr.Variable(
                    name = new_name,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprVariable_name(node: EnhancedCalculatorAst.Expr.Variable) =
            transformSymbolPrimitive(node.name)
        open fun transformExprVariable_metas(node: EnhancedCalculatorAst.Expr.Variable) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun transformOperator(node: EnhancedCalculatorAst.Operator): EnhancedCalculatorAst.Operator =
            when(node) {
                is EnhancedCalculatorAst.Operator.Plus -> transformOperatorPlus(node)
                is EnhancedCalculatorAst.Operator.Minus -> transformOperatorMinus(node)
                is EnhancedCalculatorAst.Operator.Times -> transformOperatorTimes(node)
                is EnhancedCalculatorAst.Operator.Divide -> transformOperatorDivide(node)
                is EnhancedCalculatorAst.Operator.Modulo -> transformOperatorModulo(node)
            }
        // Variant OperatorPlus
        open fun transformOperatorPlus(node: EnhancedCalculatorAst.Operator.Plus): EnhancedCalculatorAst.Operator {
            val new_metas = transformOperatorPlus_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Operator.Plus(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorPlus_metas(node: EnhancedCalculatorAst.Operator.Plus) =
            transformMetas(node.metas)
    
        // Variant OperatorMinus
        open fun transformOperatorMinus(node: EnhancedCalculatorAst.Operator.Minus): EnhancedCalculatorAst.Operator {
            val new_metas = transformOperatorMinus_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Operator.Minus(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorMinus_metas(node: EnhancedCalculatorAst.Operator.Minus) =
            transformMetas(node.metas)
    
        // Variant OperatorTimes
        open fun transformOperatorTimes(node: EnhancedCalculatorAst.Operator.Times): EnhancedCalculatorAst.Operator {
            val new_metas = transformOperatorTimes_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Operator.Times(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorTimes_metas(node: EnhancedCalculatorAst.Operator.Times) =
            transformMetas(node.metas)
    
        // Variant OperatorDivide
        open fun transformOperatorDivide(node: EnhancedCalculatorAst.Operator.Divide): EnhancedCalculatorAst.Operator {
            val new_metas = transformOperatorDivide_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Operator.Divide(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorDivide_metas(node: EnhancedCalculatorAst.Operator.Divide) =
            transformMetas(node.metas)
    
        // Variant OperatorModulo
        open fun transformOperatorModulo(node: EnhancedCalculatorAst.Operator.Modulo): EnhancedCalculatorAst.Operator {
            val new_metas = transformOperatorModulo_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                EnhancedCalculatorAst.Operator.Modulo(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorModulo_metas(node: EnhancedCalculatorAst.Operator.Modulo) =
            transformMetas(node.metas)
    
    }
}

