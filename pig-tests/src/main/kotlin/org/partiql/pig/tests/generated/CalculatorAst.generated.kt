
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*


class CalculatorAst private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = CalculatorAstBuilder
    
        fun <T: CalculatorAstNode> build(block: Builder.() -> T) =
            CalculatorAstBuilder.block()
    
        fun transform(element: AnyElement): CalculatorAstNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): CalculatorAstNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Variants for Sum: Operator 
        /**
         * Creates an instance of [CalculatorAst.Operator.Plus].
         */
        fun plus(
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Operator.Plus =
            CalculatorAst.Operator.Plus(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [CalculatorAst.Operator.Minus].
         */
        fun minus(
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Operator.Minus =
            CalculatorAst.Operator.Minus(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [CalculatorAst.Operator.Times].
         */
        fun times(
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Operator.Times =
            CalculatorAst.Operator.Times(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [CalculatorAst.Operator.Divide].
         */
        fun divide(
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Operator.Divide =
            CalculatorAst.Operator.Divide(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [CalculatorAst.Operator.Modulo].
         */
        fun modulo(
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Operator.Modulo =
            CalculatorAst.Operator.Modulo(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [CalculatorAst.Expr.Lit].
         */
        fun lit(
            value: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Expr.Lit =
            CalculatorAst.Expr.Lit(
                value = value.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [CalculatorAst.Expr.Lit].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun lit_(
            value: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Expr.Lit =
            CalculatorAst.Expr.Lit(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [CalculatorAst.Expr.Binary].
         */
        fun binary(
            op: Operator,
            left: Expr,
            right: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): CalculatorAst.Expr.Binary =
            CalculatorAst.Expr.Binary(
                op = op,
                left = left,
                right = right,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object CalculatorAstBuilder : Builder
    
    /** Base class for all CalculatorAst types. */
    abstract class CalculatorAstNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): CalculatorAstNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): CalculatorAstNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Operator(override val metas: MetaContainer = emptyMetaContainer()) : CalculatorAstNode() {
        override fun copy(metas: MetaContainer): Operator =
            when (this) {
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
            }
    
        class Plus(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1000
        }
    
        class Minus(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1001
        }
    
        class Times(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1002
        }
    
        class Divide(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1003
        }
    
        class Modulo(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Operator() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 1004
        }
    
        /** Converts instances of [CalculatorAst.Operator] to any [T]. */
        interface Converter<T> {
            fun convert(node: CalculatorAst.Operator): T = when(node) {
                is CalculatorAst.Operator.Plus -> convertPlus(node)
                is CalculatorAst.Operator.Minus -> convertMinus(node)
                is CalculatorAst.Operator.Times -> convertTimes(node)
                is CalculatorAst.Operator.Divide -> convertDivide(node)
                is CalculatorAst.Operator.Modulo -> convertModulo(node)
            }
    
            fun convertPlus(node: CalculatorAst.Operator.Plus): T
            fun convertMinus(node: CalculatorAst.Operator.Minus): T
            fun convertTimes(node: CalculatorAst.Operator.Times): T
            fun convertDivide(node: CalculatorAst.Operator.Divide): T
            fun convertModulo(node: CalculatorAst.Operator.Modulo): T
        }
    }
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : CalculatorAstNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Lit -> copy(metas = metas)
                is Binary -> copy(metas = metas)
            }
    
        class Lit(
            val value: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: org.partiql.pig.runtime.LongPrimitive = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Binary(
            val op: Operator,
            val left: Expr,
            val right: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Binary =
                Binary(
                    op = op,
                    left = left,
                    right = right,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Binary =
                Binary(
                    op = op,
                    left = left,
                    right = right,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("binary"),
                    op.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                op: Operator = this.op,
                left: Expr = this.left,
                right: Expr = this.right,
                metas: MetaContainer = this.metas
            ) =
                Binary(
                    op,
                    left,
                    right,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Binary::class.java) return false
        
                other as Binary
                if (op != other.op) return false
                if (left != other.left) return false
                if (right != other.right) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = op.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [CalculatorAst.Expr] to any [T]. */
        interface Converter<T> {
            fun convert(node: CalculatorAst.Expr): T = when(node) {
                is CalculatorAst.Expr.Lit -> convertLit(node)
                is CalculatorAst.Expr.Binary -> convertBinary(node)
            }
    
            fun convertLit(node: CalculatorAst.Expr.Lit): T
            fun convertBinary(node: CalculatorAst.Expr.Binary): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<CalculatorAstNode>() {
    
        override fun innerTransform(sexp: SexpElement): CalculatorAstNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Variants for Sum Type 'Operator'
                //////////////////////////////////////
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    CalculatorAst.Operator.Plus(
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    CalculatorAst.Operator.Minus(
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    CalculatorAst.Operator.Times(
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    CalculatorAst.Operator.Divide(
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    CalculatorAst.Operator.Modulo(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).toLongPrimitive()
                    CalculatorAst.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "binary" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val op = sexp.getRequired(0).transformExpect<Operator>()
                    val left = sexp.getRequired(1).transformExpect<Expr>()
                    val right = sexp.getRequired(2).transformExpect<Expr>()
                    CalculatorAst.Expr.Binary(
                        op,
                        left,
                        right,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'calculator_ast'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        protected open fun visitOperator(node: CalculatorAst.Operator) { }
        protected open fun visitOperatorPlus(node: CalculatorAst.Operator.Plus) { }
        protected open fun visitOperatorMinus(node: CalculatorAst.Operator.Minus) { }
        protected open fun visitOperatorTimes(node: CalculatorAst.Operator.Times) { }
        protected open fun visitOperatorDivide(node: CalculatorAst.Operator.Divide) { }
        protected open fun visitOperatorModulo(node: CalculatorAst.Operator.Modulo) { }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: CalculatorAst.Expr) { }
        protected open fun visitExprLit(node: CalculatorAst.Expr.Lit) { }
        protected open fun visitExprBinary(node: CalculatorAst.Expr.Binary) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun walkOperator(node: CalculatorAst.Operator) {
            visitOperator(node)
            when(node) {
                is CalculatorAst.Operator.Plus -> walkOperatorPlus(node)
                is CalculatorAst.Operator.Minus -> walkOperatorMinus(node)
                is CalculatorAst.Operator.Times -> walkOperatorTimes(node)
                is CalculatorAst.Operator.Divide -> walkOperatorDivide(node)
                is CalculatorAst.Operator.Modulo -> walkOperatorModulo(node)
            }
        }
    
        open fun walkOperatorPlus(node: CalculatorAst.Operator.Plus) {
            visitOperatorPlus(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorMinus(node: CalculatorAst.Operator.Minus) {
            visitOperatorMinus(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorTimes(node: CalculatorAst.Operator.Times) {
            visitOperatorTimes(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorDivide(node: CalculatorAst.Operator.Divide) {
            visitOperatorDivide(node)
            walkMetas(node.metas)
        }
        open fun walkOperatorModulo(node: CalculatorAst.Operator.Modulo) {
            visitOperatorModulo(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: CalculatorAst.Expr) {
            visitExpr(node)
            when(node) {
                is CalculatorAst.Expr.Lit -> walkExprLit(node)
                is CalculatorAst.Expr.Binary -> walkExprBinary(node)
            }
        }
    
        open fun walkExprLit(node: CalculatorAst.Expr.Lit) {
            visitExprLit(node)
            walkLongPrimitive(node.value)
            walkMetas(node.metas)
        }
        open fun walkExprBinary(node: CalculatorAst.Expr.Binary) {
            visitExprBinary(node)
            walkOperator(node.op)
            walkExpr(node.left)
            walkExpr(node.right)
            walkMetas(node.metas)
        }
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open protected fun visitOperator(node: CalculatorAst.Operator, accumulator: T): T = accumulator
        open protected fun visitOperatorPlus(node: CalculatorAst.Operator.Plus, accumulator: T): T = accumulator
        open protected fun visitOperatorMinus(node: CalculatorAst.Operator.Minus, accumulator: T): T = accumulator
        open protected fun visitOperatorTimes(node: CalculatorAst.Operator.Times, accumulator: T): T = accumulator
        open protected fun visitOperatorDivide(node: CalculatorAst.Operator.Divide, accumulator: T): T = accumulator
        open protected fun visitOperatorModulo(node: CalculatorAst.Operator.Modulo, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: CalculatorAst.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: CalculatorAst.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprBinary(node: CalculatorAst.Expr.Binary, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun walkOperator(node: CalculatorAst.Operator, accumulator: T): T {
            val current = visitOperator(node, accumulator)
            return when(node) {
                is CalculatorAst.Operator.Plus -> walkOperatorPlus(node, current)
                is CalculatorAst.Operator.Minus -> walkOperatorMinus(node, current)
                is CalculatorAst.Operator.Times -> walkOperatorTimes(node, current)
                is CalculatorAst.Operator.Divide -> walkOperatorDivide(node, current)
                is CalculatorAst.Operator.Modulo -> walkOperatorModulo(node, current)
            }
        }
    
        open fun walkOperatorPlus(node: CalculatorAst.Operator.Plus, accumulator: T): T {
            var current = accumulator
            current = visitOperatorPlus(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorMinus(node: CalculatorAst.Operator.Minus, accumulator: T): T {
            var current = accumulator
            current = visitOperatorMinus(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorTimes(node: CalculatorAst.Operator.Times, accumulator: T): T {
            var current = accumulator
            current = visitOperatorTimes(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorDivide(node: CalculatorAst.Operator.Divide, accumulator: T): T {
            var current = accumulator
            current = visitOperatorDivide(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOperatorModulo(node: CalculatorAst.Operator.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitOperatorModulo(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: CalculatorAst.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is CalculatorAst.Expr.Lit -> walkExprLit(node, current)
                is CalculatorAst.Expr.Binary -> walkExprBinary(node, current)
            }
        }
    
        open fun walkExprLit(node: CalculatorAst.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkLongPrimitive(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBinary(node: CalculatorAst.Expr.Binary, accumulator: T): T {
            var current = accumulator
            current = visitExprBinary(node, current)
            current = walkOperator(node.op, current)
            current = walkExpr(node.left, current)
            current = walkExpr(node.right, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Sum Type: Operator
        //////////////////////////////////////
        open fun transformOperator(node: CalculatorAst.Operator): CalculatorAst.Operator =
            when(node) {
                is CalculatorAst.Operator.Plus -> transformOperatorPlus(node)
                is CalculatorAst.Operator.Minus -> transformOperatorMinus(node)
                is CalculatorAst.Operator.Times -> transformOperatorTimes(node)
                is CalculatorAst.Operator.Divide -> transformOperatorDivide(node)
                is CalculatorAst.Operator.Modulo -> transformOperatorModulo(node)
            }
        // Variant OperatorPlus
        open fun transformOperatorPlus(node: CalculatorAst.Operator.Plus): CalculatorAst.Operator {
            val new_metas = transformOperatorPlus_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                CalculatorAst.Operator.Plus(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorPlus_metas(node: CalculatorAst.Operator.Plus) =
            transformMetas(node.metas)
    
        // Variant OperatorMinus
        open fun transformOperatorMinus(node: CalculatorAst.Operator.Minus): CalculatorAst.Operator {
            val new_metas = transformOperatorMinus_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                CalculatorAst.Operator.Minus(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorMinus_metas(node: CalculatorAst.Operator.Minus) =
            transformMetas(node.metas)
    
        // Variant OperatorTimes
        open fun transformOperatorTimes(node: CalculatorAst.Operator.Times): CalculatorAst.Operator {
            val new_metas = transformOperatorTimes_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                CalculatorAst.Operator.Times(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorTimes_metas(node: CalculatorAst.Operator.Times) =
            transformMetas(node.metas)
    
        // Variant OperatorDivide
        open fun transformOperatorDivide(node: CalculatorAst.Operator.Divide): CalculatorAst.Operator {
            val new_metas = transformOperatorDivide_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                CalculatorAst.Operator.Divide(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorDivide_metas(node: CalculatorAst.Operator.Divide) =
            transformMetas(node.metas)
    
        // Variant OperatorModulo
        open fun transformOperatorModulo(node: CalculatorAst.Operator.Modulo): CalculatorAst.Operator {
            val new_metas = transformOperatorModulo_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                CalculatorAst.Operator.Modulo(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOperatorModulo_metas(node: CalculatorAst.Operator.Modulo) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: CalculatorAst.Expr): CalculatorAst.Expr =
            when(node) {
                is CalculatorAst.Expr.Lit -> transformExprLit(node)
                is CalculatorAst.Expr.Binary -> transformExprBinary(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: CalculatorAst.Expr.Lit): CalculatorAst.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                CalculatorAst.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: CalculatorAst.Expr.Lit) =
            transformLongPrimitive(node.value)
        open fun transformExprLit_metas(node: CalculatorAst.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprBinary
        open fun transformExprBinary(node: CalculatorAst.Expr.Binary): CalculatorAst.Expr {
            val new_op = transformExprBinary_op(node)
            val new_left = transformExprBinary_left(node)
            val new_right = transformExprBinary_right(node)
            val new_metas = transformExprBinary_metas(node)
            return if (
                node.op !== new_op ||
                node.left !== new_left ||
                node.right !== new_right ||
                node.metas !== new_metas
            ) {
                CalculatorAst.Expr.Binary(
                    op = new_op,
                    left = new_left,
                    right = new_right,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBinary_op(node: CalculatorAst.Expr.Binary) =
            transformOperator(node.op)
        open fun transformExprBinary_left(node: CalculatorAst.Expr.Binary) =
            transformExpr(node.left)
        open fun transformExprBinary_right(node: CalculatorAst.Expr.Binary) =
            transformExpr(node.right)
        open fun transformExprBinary_metas(node: CalculatorAst.Expr.Binary) =
            transformMetas(node.metas)
    
    }
}

