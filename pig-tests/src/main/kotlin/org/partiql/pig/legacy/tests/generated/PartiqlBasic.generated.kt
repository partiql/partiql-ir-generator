
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
"CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
"USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.pig.legacy.tests.generated

import com.amazon.ionelement.api.*
import org.partiql.pig.legacy.runtime.*


class PartiqlBasic private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = PartiqlBasicBuilder
    
        fun <T: PartiqlBasicNode> build(block: Builder.() -> T) =
            PartiqlBasicBuilder.block()
    
        fun transform(element: AnyElement): PartiqlBasicNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): PartiqlBasicNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [PartiqlBasic.ExprPair].
         */
        fun exprPair(
            first: Expr,
            second: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ExprPair =
            PartiqlBasic.ExprPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByItem].
         */
        fun groupByItem(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByItem].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupByItem_(
            value: Expr,
            asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByItem =
            PartiqlBasic.GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByList].
         */
        fun groupByList(
            items: kotlin.collections.List<GroupByItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = items,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.GroupByList].
         */
        fun groupByList(
            items0: GroupByItem,
            vararg items: GroupByItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupByList =
            PartiqlBasic.GroupByList(
                items = listOf(items0) + items.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.GroupBy].
         */
        fun groupBy(
            items: GroupByList,
            groupAsAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.GroupBy].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupBy_(
            items: GroupByList,
            groupAsAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.GroupBy =
            PartiqlBasic.GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Projection 
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectList].
         */
        fun projectList(
            items: kotlin.collections.List<ProjectItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = items,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectList].
         */
        fun projectList(
            items0: ProjectItem,
            vararg items: ProjectItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectList =
            PartiqlBasic.Projection.ProjectList(
                items = listOf(items0) + items.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Projection.ProjectValue].
         */
        fun projectValue(
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Projection.ProjectValue =
            PartiqlBasic.Projection.ProjectValue(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ProjectItem 
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectAll].
         */
        fun projectAll(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectAll =
            PartiqlBasic.ProjectItem.ProjectAll(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectExpr].
         */
        fun projectExpr(
            value: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.ProjectItem.ProjectExpr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun projectExpr_(
            value: Expr,
            asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ProjectItem.ProjectExpr =
            PartiqlBasic.ProjectItem.ProjectExpr(
                value = value,
                asAlias = asAlias,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: JoinType 
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Inner].
         */
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Inner =
            PartiqlBasic.JoinType.Inner(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Left].
         */
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Left =
            PartiqlBasic.JoinType.Left(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Right].
         */
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Right =
            PartiqlBasic.JoinType.Right(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.JoinType.Outer].
         */
        fun outer(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.JoinType.Outer =
            PartiqlBasic.JoinType.Outer(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: FromSource 
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Scan].
         */
        fun scan(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Scan].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun scan_(
            expr: Expr,
            asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            atAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            byAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Scan =
            PartiqlBasic.FromSource.Scan(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.FromSource.Join].
         */
        fun join(
            type: JoinType,
            left: FromSource,
            right: FromSource,
            predicate: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.FromSource.Join =
            PartiqlBasic.FromSource.Join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: CaseSensitivity 
        /**
         * Creates an instance of [PartiqlBasic.CaseSensitivity.CaseSensitive].
         */
        fun caseSensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseSensitive =
            PartiqlBasic.CaseSensitivity.CaseSensitive(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.CaseSensitivity.CaseInsensitive].
         */
        fun caseInsensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.CaseSensitivity.CaseInsensitive =
            PartiqlBasic.CaseSensitivity.CaseInsensitive(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ScopeQualifier 
        /**
         * Creates an instance of [PartiqlBasic.ScopeQualifier.Unqualified].
         */
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Unqualified =
            PartiqlBasic.ScopeQualifier.Unqualified(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.ScopeQualifier.Qualified].
         */
        fun qualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.ScopeQualifier.Qualified =
            PartiqlBasic.ScopeQualifier.Qualified(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SetQuantifier 
        /**
         * Creates an instance of [PartiqlBasic.SetQuantifier.All].
         */
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.All =
            PartiqlBasic.SetQuantifier.All(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.SetQuantifier.Distinct].
         */
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.SetQuantifier.Distinct =
            PartiqlBasic.SetQuantifier.Distinct(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: PathElement 
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathExpr].
         */
        fun pathExpr(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathExpr =
            PartiqlBasic.PathElement.PathExpr(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathWildcard].
         */
        fun pathWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathWildcard =
            PartiqlBasic.PathElement.PathWildcard(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.PathElement.PathUnpivot].
         */
        fun pathUnpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.PathElement.PathUnpivot =
            PartiqlBasic.PathElement.PathUnpivot(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [PartiqlBasic.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Lit =
            PartiqlBasic.Expr.Lit(
                value = value.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Id].
         */
        fun id(
            name: String,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name.asPrimitive(),
                case = case,
                scopeQualifier = scopeQualifier,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Id].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun id_(
            name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            case: CaseSensitivity,
            scopeQualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Id =
            PartiqlBasic.Expr.Id(
                name = name,
                case = case,
                scopeQualifier = scopeQualifier,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Parameter].
         */
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Parameter].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun parameter_(
            index: org.partiql.pig.legacy.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Parameter =
            PartiqlBasic.Expr.Parameter(
                index = index,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Not =
            PartiqlBasic.Expr.Not(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Plus =
            PartiqlBasic.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Minus =
            PartiqlBasic.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Times =
            PartiqlBasic.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Divide =
            PartiqlBasic.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Modulo =
            PartiqlBasic.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Concat].
         */
        fun concat(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Concat].
         */
        fun concat(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Concat =
            PartiqlBasic.Expr.Concat(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Like].
         */
        fun like(
            left: Expr,
            right: Expr,
            escape: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Like =
            PartiqlBasic.Expr.Like(
                left = left,
                right = right,
                escape = escape,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Between].
         */
        fun between(
            value: Expr,
            from: Expr,
            to: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Between =
            PartiqlBasic.Expr.Between(
                value = value,
                from = from,
                to = to,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Path].
         */
        fun path(
            root: Expr,
            elements: kotlin.collections.List<PathElement>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = elements,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Path].
         */
        fun path(
            root: Expr,
            elements0: PathElement,
            vararg elements: PathElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Path =
            PartiqlBasic.Expr.Path(
                root = root,
                elements = listOf(elements0) + elements.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         */
        fun call(
            name: String,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name.asPrimitive(),
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         */
        fun call(
            name: String,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name?.asPrimitive(),
                args = listOf(args0) + args.toList(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Call =
            PartiqlBasic.Expr.Call(
                name = name,
                args = listOf(args0) + args.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.CallAgg].
         */
        fun callAgg(
            name: String,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name.asPrimitive(),
                setQuantifier = setQuantifier,
                arg = arg,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.CallAgg].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun callAgg_(
            name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            setQuantifier: SetQuantifier,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.CallAgg =
            PartiqlBasic.Expr.CallAgg(
                name = name,
                setQuantifier = setQuantifier,
                arg = arg,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SimpleCase].
         */
        fun simpleCase(
            value: Expr,
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = branches,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SimpleCase].
         */
        fun simpleCase(
            value: Expr,
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SimpleCase =
            PartiqlBasic.Expr.SimpleCase(
                value = value,
                branches = listOf(branches0) + branches.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SearchedCase].
         */
        fun searchedCase(
            branches: kotlin.collections.List<ExprPair>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = branches,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.SearchedCase].
         */
        fun searchedCase(
            branches0: ExprPair,
            vararg branches: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.SearchedCase =
            PartiqlBasic.Expr.SearchedCase(
                branches = listOf(branches0) + branches.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Struct].
         */
        fun struct(
            fields: kotlin.collections.List<ExprPair> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Struct].
         */
        fun struct(
            vararg fields: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Struct =
            PartiqlBasic.Expr.Struct(
                fields = fields.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Bag].
         */
        fun bag(
            values: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Bag].
         */
        fun bag(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Bag =
            PartiqlBasic.Expr.Bag(
                values = values.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.List].
         */
        fun list(
            values: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.List].
         */
        fun list(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.List =
            PartiqlBasic.Expr.List(
                values = values.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlBasic.Expr.Select].
         */
        fun select(
            setq: SetQuantifier? = null,
            project: Projection,
            from: FromSource,
            where: Expr? = null,
            group: GroupBy? = null,
            having: Expr? = null,
            limit: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlBasic.Expr.Select =
            PartiqlBasic.Expr.Select(
                setq = setq,
                project = project,
                from = from,
                where = where,
                group = group,
                having = having,
                limit = limit,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object PartiqlBasicBuilder : Builder
    
    /** Base class for all PartiqlBasic types. */
    abstract class PartiqlBasicNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): PartiqlBasicNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): PartiqlBasicNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class ExprPair(
        val first: Expr,
        val second: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun copy(metas: MetaContainer): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Expr = this.first,
            second: Expr = this.second,
            metas: MetaContainer = this.metas
        ) =
            ExprPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPair::class.java) return false
    
            other as ExprPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByItem(
        val value: Expr,
        val asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun copy(metas: MetaContainer): GroupByItem =
            GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByItem =
            GroupByItem(
                value = value,
                asAlias = asAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_item"),
                value.toIonElement(),
                asAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            value: Expr = this.value,
            asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.asAlias,
            metas: MetaContainer = this.metas
        ) =
            GroupByItem(
                value,
                asAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByItem::class.java) return false
    
            other as GroupByItem
            if (value != other.value) return false
            if (asAlias != other.asAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = value.hashCode()
            hc = 31 * hc + asAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupByList(
        val items: kotlin.collections.List<GroupByItem>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun copy(metas: MetaContainer): GroupByList =
            GroupByList(
                items = items,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupByList =
            GroupByList(
                items = items,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by_list"),
                *items.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            items: kotlin.collections.List<GroupByItem> = this.items,
            metas: MetaContainer = this.metas
        ) =
            GroupByList(
                items,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupByList::class.java) return false
    
            other as GroupByList
            if (items != other.items) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = items.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupBy(
        val items: GroupByList,
        val groupAsAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlBasicNode() {
    
        override fun copy(metas: MetaContainer): GroupBy =
            GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupBy =
            GroupBy(
                items = items,
                groupAsAlias = groupAsAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                items.toIonElement(),
                groupAsAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            items: GroupByList = this.items,
            groupAsAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.groupAsAlias,
            metas: MetaContainer = this.metas
        ) =
            GroupBy(
                items,
                groupAsAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupBy::class.java) return false
    
            other as GroupBy
            if (items != other.items) return false
            if (groupAsAlias != other.groupAsAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = items.hashCode()
            hc = 31 * hc + groupAsAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Projection(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): Projection =
            when (this) {
                is ProjectList -> copy(metas = metas)
                is ProjectValue -> copy(metas = metas)
            }
    
        class ProjectList(
            val items: kotlin.collections.List<ProjectItem>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectList =
                ProjectList(
                    items = items,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectList =
                ProjectList(
                    items = items,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *items.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                items: kotlin.collections.List<ProjectItem> = this.items,
                metas: MetaContainer = this.metas
            ) =
                ProjectList(
                    items,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectList::class.java) return false
        
                other as ProjectList
                if (items != other.items) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = items.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectValue(
            val value: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                metas: MetaContainer = this.metas
            ) =
                ProjectValue(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectValue::class.java) return false
        
                other as ProjectValue
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlBasic.Projection] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.Projection): T = when(node) {
                is PartiqlBasic.Projection.ProjectList -> convertProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> convertProjectValue(node)
            }
    
            fun convertProjectList(node: PartiqlBasic.Projection.ProjectList): T
            fun convertProjectValue(node: PartiqlBasic.Projection.ProjectValue): T
        }
    }
    
    sealed class ProjectItem(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): ProjectItem =
            when (this) {
                is ProjectAll -> copy(metas = metas)
                is ProjectExpr -> copy(metas = metas)
            }
    
        class ProjectAll(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun copy(metas: MetaContainer): ProjectAll =
                ProjectAll(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectAll =
                ProjectAll(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectAll::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class ProjectExpr(
            val value: Expr,
            val asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun copy(metas: MetaContainer): ProjectExpr =
                ProjectExpr(
                    value = value,
                    asAlias = asAlias,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectExpr =
                ProjectExpr(
                    value = value,
                    asAlias = asAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    value.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.asAlias,
                metas: MetaContainer = this.metas
            ) =
                ProjectExpr(
                    value,
                    asAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectExpr::class.java) return false
        
                other as ProjectExpr
                if (value != other.value) return false
                if (asAlias != other.asAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlBasic.ProjectItem] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.ProjectItem): T = when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> convertProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> convertProjectExpr(node)
            }
    
            fun convertProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll): T
            fun convertProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr): T
        }
    }
    
    sealed class JoinType(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): JoinType =
            when (this) {
                is Inner -> copy(metas = metas)
                is Left -> copy(metas = metas)
                is Right -> copy(metas = metas)
                is Outer -> copy(metas = metas)
            }
    
        class Inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Inner =
                Inner(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Inner =
                Inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3000
        }
    
        class Left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Left =
                Left(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Left =
                Left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class Right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Right =
                Right(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Right =
                Right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        class Outer(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Outer =
                Outer(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Outer =
                Outer(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("outer"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Outer::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3003
        }
    
        /** Converts instances of [PartiqlBasic.JoinType] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.JoinType): T = when(node) {
                is PartiqlBasic.JoinType.Inner -> convertInner(node)
                is PartiqlBasic.JoinType.Left -> convertLeft(node)
                is PartiqlBasic.JoinType.Right -> convertRight(node)
                is PartiqlBasic.JoinType.Outer -> convertOuter(node)
            }
    
            fun convertInner(node: PartiqlBasic.JoinType.Inner): T
            fun convertLeft(node: PartiqlBasic.JoinType.Left): T
            fun convertRight(node: PartiqlBasic.JoinType.Right): T
            fun convertOuter(node: PartiqlBasic.JoinType.Outer): T
        }
    }
    
    sealed class FromSource(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): FromSource =
            when (this) {
                is Scan -> copy(metas = metas)
                is Join -> copy(metas = metas)
            }
    
        class Scan(
            val expr: Expr,
            val asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
            val atAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
            val byAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun copy(metas: MetaContainer): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                asAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.asAlias,
                atAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.atAlias,
                byAlias: org.partiql.pig.legacy.runtime.SymbolPrimitive? = this.byAlias,
                metas: MetaContainer = this.metas
            ) =
                Scan(
                    expr,
                    asAlias,
                    atAlias,
                    byAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Scan::class.java) return false
        
                other as Scan
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Join(
            val type: JoinType,
            val left: FromSource,
            val right: FromSource,
            val predicate: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun copy(metas: MetaContainer): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                type: JoinType = this.type,
                left: FromSource = this.left,
                right: FromSource = this.right,
                predicate: Expr? = this.predicate,
                metas: MetaContainer = this.metas
            ) =
                Join(
                    type,
                    left,
                    right,
                    predicate,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Join::class.java) return false
        
                other as Join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlBasic.FromSource] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.FromSource): T = when(node) {
                is PartiqlBasic.FromSource.Scan -> convertScan(node)
                is PartiqlBasic.FromSource.Join -> convertJoin(node)
            }
    
            fun convertScan(node: PartiqlBasic.FromSource.Scan): T
            fun convertJoin(node: PartiqlBasic.FromSource.Join): T
        }
    }
    
    sealed class CaseSensitivity(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): CaseSensitivity =
            when (this) {
                is CaseSensitive -> copy(metas = metas)
                is CaseInsensitive -> copy(metas = metas)
            }
    
        class CaseSensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun copy(metas: MetaContainer): CaseSensitive =
                CaseSensitive(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseSensitive =
                CaseSensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseSensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5000
        }
    
        class CaseInsensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun copy(metas: MetaContainer): CaseInsensitive =
                CaseInsensitive(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseInsensitive =
                CaseInsensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseInsensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 5001
        }
    
        /** Converts instances of [PartiqlBasic.CaseSensitivity] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.CaseSensitivity): T = when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> convertCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> convertCaseInsensitive(node)
            }
    
            fun convertCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive): T
            fun convertCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive): T
        }
    }
    
    sealed class ScopeQualifier(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): ScopeQualifier =
            when (this) {
                is Unqualified -> copy(metas = metas)
                is Qualified -> copy(metas = metas)
            }
    
        class Unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun copy(metas: MetaContainer): Unqualified =
                Unqualified(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Unqualified =
                Unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6000
        }
    
        class Qualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun copy(metas: MetaContainer): Qualified =
                Qualified(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Qualified =
                Qualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("qualified"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Qualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 6001
        }
    
        /** Converts instances of [PartiqlBasic.ScopeQualifier] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.ScopeQualifier): T = when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> convertUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> convertQualified(node)
            }
    
            fun convertUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified): T
            fun convertQualified(node: PartiqlBasic.ScopeQualifier.Qualified): T
        }
    }
    
    sealed class SetQuantifier(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): SetQuantifier =
            when (this) {
                is All -> copy(metas = metas)
                is Distinct -> copy(metas = metas)
            }
    
        class All(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun copy(metas: MetaContainer): All =
                All(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): All =
                All(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != All::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class Distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun copy(metas: MetaContainer): Distinct =
                Distinct(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Distinct =
                Distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
        /** Converts instances of [PartiqlBasic.SetQuantifier] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.SetQuantifier): T = when(node) {
                is PartiqlBasic.SetQuantifier.All -> convertAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> convertDistinct(node)
            }
    
            fun convertAll(node: PartiqlBasic.SetQuantifier.All): T
            fun convertDistinct(node: PartiqlBasic.SetQuantifier.Distinct): T
        }
    }
    
    sealed class PathElement(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): PathElement =
            when (this) {
                is PathExpr -> copy(metas = metas)
                is PathWildcard -> copy(metas = metas)
                is PathUnpivot -> copy(metas = metas)
            }
    
        class PathExpr(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun copy(metas: MetaContainer): PathExpr =
                PathExpr(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathExpr =
                PathExpr(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                PathExpr(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathExpr::class.java) return false
        
                other as PathExpr
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class PathWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun copy(metas: MetaContainer): PathWildcard =
                PathWildcard(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathWildcard =
                PathWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        class PathUnpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathElement() {
        
            override fun copy(metas: MetaContainer): PathUnpivot =
                PathUnpivot(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathUnpivot =
                PathUnpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathUnpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8002
        }
    
        /** Converts instances of [PartiqlBasic.PathElement] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.PathElement): T = when(node) {
                is PartiqlBasic.PathElement.PathExpr -> convertPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> convertPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> convertPathUnpivot(node)
            }
    
            fun convertPathExpr(node: PartiqlBasic.PathElement.PathExpr): T
            fun convertPathWildcard(node: PartiqlBasic.PathElement.PathWildcard): T
            fun convertPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot): T
        }
    }
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlBasicNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Lit -> copy(metas = metas)
                is Id -> copy(metas = metas)
                is Parameter -> copy(metas = metas)
                is Not -> copy(metas = metas)
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
                is Concat -> copy(metas = metas)
                is Like -> copy(metas = metas)
                is Between -> copy(metas = metas)
                is Path -> copy(metas = metas)
                is Call -> copy(metas = metas)
                is CallAgg -> copy(metas = metas)
                is SimpleCase -> copy(metas = metas)
                is SearchedCase -> copy(metas = metas)
                is Struct -> copy(metas = metas)
                is Bag -> copy(metas = metas)
                is List -> copy(metas = metas)
                is Select -> copy(metas = metas)
            }
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Id(
            val name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            val case: CaseSensitivity,
            val scopeQualifier: ScopeQualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Id =
                Id(
                    name = name,
                    case = case,
                    scopeQualifier = scopeQualifier,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Id =
                Id(
                    name = name,
                    case = case,
                    scopeQualifier = scopeQualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    scopeQualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.legacy.runtime.SymbolPrimitive = this.name,
                case: CaseSensitivity = this.case,
                scopeQualifier: ScopeQualifier = this.scopeQualifier,
                metas: MetaContainer = this.metas
            ) =
                Id(
                    name,
                    case,
                    scopeQualifier,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Id::class.java) return false
        
                other as Id
                if (name != other.name) return false
                if (case != other.case) return false
                if (scopeQualifier != other.scopeQualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + scopeQualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Parameter(
            val index: org.partiql.pig.legacy.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Parameter =
                Parameter(
                    index = index,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Parameter =
                Parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: org.partiql.pig.legacy.runtime.LongPrimitive = this.index,
                metas: MetaContainer = this.metas
            ) =
                Parameter(
                    index,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Parameter::class.java) return false
        
                other as Parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Not =
                Not(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Concat(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Concat =
                Concat(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Concat =
                Concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Concat(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Concat::class.java) return false
        
                other as Concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Like(
            val left: Expr,
            val right: Expr,
            val escape: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Like =
                Like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Like =
                Like(
                    left = left,
                    right = right,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    left.toIonElement(),
                    right.toIonElement(),
                    escape.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                left: Expr = this.left,
                right: Expr = this.right,
                escape: Expr = this.escape,
                metas: MetaContainer = this.metas
            ) =
                Like(
                    left,
                    right,
                    escape,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Like::class.java) return false
        
                other as Like
                if (left != other.left) return false
                if (right != other.right) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Between(
            val value: Expr,
            val from: Expr,
            val to: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                from: Expr = this.from,
                to: Expr = this.to,
                metas: MetaContainer = this.metas
            ) =
                Between(
                    value,
                    from,
                    to,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Between::class.java) return false
        
                other as Between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Path(
            val root: Expr,
            val elements: kotlin.collections.List<PathElement>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Path =
                Path(
                    root = root,
                    elements = elements,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Path =
                Path(
                    root = root,
                    elements = elements,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *elements.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                root: Expr = this.root,
                elements: kotlin.collections.List<PathElement> = this.elements,
                metas: MetaContainer = this.metas
            ) =
                Path(
                    root,
                    elements,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Path::class.java) return false
        
                other as Path
                if (root != other.root) return false
                if (elements != other.elements) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = root.hashCode()
                hc = 31 * hc + elements.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Call =
                Call(
                    name = name,
                    args = args,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    name = name,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    name.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.legacy.runtime.SymbolPrimitive = this.name,
                args: kotlin.collections.List<Expr> = this.args,
                metas: MetaContainer = this.metas
            ) =
                Call(
                    name,
                    args,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (name != other.name) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CallAgg(
            val name: org.partiql.pig.legacy.runtime.SymbolPrimitive,
            val setQuantifier: SetQuantifier,
            val arg: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): CallAgg =
                CallAgg(
                    name = name,
                    setQuantifier = setQuantifier,
                    arg = arg,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CallAgg =
                CallAgg(
                    name = name,
                    setQuantifier = setQuantifier,
                    arg = arg,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    name.toIonElement(),
                    setQuantifier.toIonElement(),
                    arg.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.legacy.runtime.SymbolPrimitive = this.name,
                setQuantifier: SetQuantifier = this.setQuantifier,
                arg: Expr = this.arg,
                metas: MetaContainer = this.metas
            ) =
                CallAgg(
                    name,
                    setQuantifier,
                    arg,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CallAgg::class.java) return false
        
                other as CallAgg
                if (name != other.name) return false
                if (setQuantifier != other.setQuantifier) return false
                if (arg != other.arg) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc = 31 * hc + setQuantifier.hashCode()
                hc = 31 * hc + arg.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SimpleCase(
            val value: Expr,
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): SimpleCase =
                SimpleCase(
                    value = value,
                    branches = branches,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SimpleCase =
                SimpleCase(
                    value = value,
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    value.toIonElement(),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                branches: kotlin.collections.List<ExprPair> = this.branches,
                metas: MetaContainer = this.metas
            ) =
                SimpleCase(
                    value,
                    branches,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SimpleCase::class.java) return false
        
                other as SimpleCase
                if (value != other.value) return false
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SearchedCase(
            val branches: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): SearchedCase =
                SearchedCase(
                    branches = branches,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SearchedCase =
                SearchedCase(
                    branches = branches,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    *branches.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                branches: kotlin.collections.List<ExprPair> = this.branches,
                metas: MetaContainer = this.metas
            ) =
                SearchedCase(
                    branches,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SearchedCase::class.java) return false
        
                other as SearchedCase
                if (branches != other.branches) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = branches.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Struct(
            val fields: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Struct =
                Struct(
                    fields = fields,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Struct =
                Struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                fields: kotlin.collections.List<ExprPair> = this.fields,
                metas: MetaContainer = this.metas
            ) =
                Struct(
                    fields,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Struct::class.java) return false
        
                other as Struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Bag(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Bag =
                Bag(
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Bag =
                Bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas
            ) =
                Bag(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Bag::class.java) return false
        
                other as Bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class List(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): List =
                List(
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): List =
                List(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas
            ) =
                List(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != List::class.java) return false
        
                other as List
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Select(
            val setq: SetQuantifier?,
            val project: Projection,
            val from: FromSource,
            val where: Expr?,
            val group: GroupBy?,
            val having: Expr?,
            val limit: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    where = where,
                    group = group,
                    having = having,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                setq: SetQuantifier? = this.setq,
                project: Projection = this.project,
                from: FromSource = this.from,
                where: Expr? = this.where,
                group: GroupBy? = this.group,
                having: Expr? = this.having,
                limit: Expr? = this.limit,
                metas: MetaContainer = this.metas
            ) =
                Select(
                    setq,
                    project,
                    from,
                    where,
                    group,
                    having,
                    limit,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Select::class.java) return false
        
                other as Select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlBasic.Expr] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlBasic.Expr): T = when(node) {
                is PartiqlBasic.Expr.Lit -> convertLit(node)
                is PartiqlBasic.Expr.Id -> convertId(node)
                is PartiqlBasic.Expr.Parameter -> convertParameter(node)
                is PartiqlBasic.Expr.Not -> convertNot(node)
                is PartiqlBasic.Expr.Plus -> convertPlus(node)
                is PartiqlBasic.Expr.Minus -> convertMinus(node)
                is PartiqlBasic.Expr.Times -> convertTimes(node)
                is PartiqlBasic.Expr.Divide -> convertDivide(node)
                is PartiqlBasic.Expr.Modulo -> convertModulo(node)
                is PartiqlBasic.Expr.Concat -> convertConcat(node)
                is PartiqlBasic.Expr.Like -> convertLike(node)
                is PartiqlBasic.Expr.Between -> convertBetween(node)
                is PartiqlBasic.Expr.Path -> convertPath(node)
                is PartiqlBasic.Expr.Call -> convertCall(node)
                is PartiqlBasic.Expr.CallAgg -> convertCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> convertSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> convertSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> convertStruct(node)
                is PartiqlBasic.Expr.Bag -> convertBag(node)
                is PartiqlBasic.Expr.List -> convertList(node)
                is PartiqlBasic.Expr.Select -> convertSelect(node)
            }
    
            fun convertLit(node: PartiqlBasic.Expr.Lit): T
            fun convertId(node: PartiqlBasic.Expr.Id): T
            fun convertParameter(node: PartiqlBasic.Expr.Parameter): T
            fun convertNot(node: PartiqlBasic.Expr.Not): T
            fun convertPlus(node: PartiqlBasic.Expr.Plus): T
            fun convertMinus(node: PartiqlBasic.Expr.Minus): T
            fun convertTimes(node: PartiqlBasic.Expr.Times): T
            fun convertDivide(node: PartiqlBasic.Expr.Divide): T
            fun convertModulo(node: PartiqlBasic.Expr.Modulo): T
            fun convertConcat(node: PartiqlBasic.Expr.Concat): T
            fun convertLike(node: PartiqlBasic.Expr.Like): T
            fun convertBetween(node: PartiqlBasic.Expr.Between): T
            fun convertPath(node: PartiqlBasic.Expr.Path): T
            fun convertCall(node: PartiqlBasic.Expr.Call): T
            fun convertCallAgg(node: PartiqlBasic.Expr.CallAgg): T
            fun convertSimpleCase(node: PartiqlBasic.Expr.SimpleCase): T
            fun convertSearchedCase(node: PartiqlBasic.Expr.SearchedCase): T
            fun convertStruct(node: PartiqlBasic.Expr.Struct): T
            fun convertBag(node: PartiqlBasic.Expr.Bag): T
            fun convertList(node: PartiqlBasic.Expr.List): T
            fun convertSelect(node: PartiqlBasic.Expr.Select): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<PartiqlBasicNode>() {
    
        override fun innerTransform(sexp: SexpElement): PartiqlBasicNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Expr>()
                    val second = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlBasic.ExprPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "group_by_item" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupByItem(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                "group_by_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<GroupByItem>() }
                    PartiqlBasic.GroupByList(
                        items,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val items = sexp.getRequired(0).transformExpect<GroupByList>()
                    val groupAsAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.GroupBy(
                        items,
                        groupAsAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Projection'
                //////////////////////////////////////
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val items = sexp.values.drop(1).map { it.transformExpect<ProjectItem>() }
                    PartiqlBasic.Projection.ProjectList(
                        items,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Projection.ProjectValue(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ProjectItem'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ProjectItem.ProjectAll(
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlBasic.ProjectItem.ProjectExpr(
                        value,
                        asAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'JoinType'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Right(
                        metas = sexp.metas)
                }
                "outer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.JoinType.Outer(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'FromSource'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlBasic.FromSource.Scan(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<JoinType>()
                    val left = sexp.getRequired(1).transformExpect<FromSource>()
                    val right = sexp.getRequired(2).transformExpect<FromSource>()
                    val predicate = sexp.getOptional(3)?.transformExpect<Expr>()
                    PartiqlBasic.FromSource.Join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'CaseSensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseSensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.CaseSensitivity.CaseInsensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ScopeQualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Unqualified(
                        metas = sexp.metas)
                }
                "qualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.ScopeQualifier.Qualified(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SetQuantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.All(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.SetQuantifier.Distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'PathElement'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.PathElement.PathExpr(
                        expr,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathWildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlBasic.PathElement.PathUnpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    PartiqlBasic.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    val scopeQualifier = sexp.getRequired(2).transformExpect<ScopeQualifier>()
                    PartiqlBasic.Expr.Id(
                        name,
                        case,
                        scopeQualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    PartiqlBasic.Expr.Parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlBasic.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Concat(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val left = sexp.getRequired(0).transformExpect<Expr>()
                    val right = sexp.getRequired(1).transformExpect<Expr>()
                    val escape = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Like(
                        left,
                        right,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val from = sexp.getRequired(1).transformExpect<Expr>()
                    val to = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.Between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<Expr>()
                    val elements = sexp.values.drop(2).map { it.transformExpect<PathElement>() }
                    PartiqlBasic.Expr.Path(
                        root,
                        elements,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Call(
                        name,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val setQuantifier = sexp.getRequired(1).transformExpect<SetQuantifier>()
                    val arg = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlBasic.Expr.CallAgg(
                        name,
                        setQuantifier,
                        arg,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val branches = sexp.values.drop(2).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SimpleCase(
                        value,
                        branches,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val branches = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.SearchedCase(
                        branches,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlBasic.Expr.Struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.Bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlBasic.Expr.List(
                        values,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<SetQuantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<Projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<FromSource>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<GroupBy>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<Expr>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<Expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Expr.Select(setq, project, from, where, group, having, limit, metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_basic'")
            }
        }
    }
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitExprPair(node: PartiqlBasic.ExprPair) { }
        open fun visitGroupByItem(node: PartiqlBasic.GroupByItem) { }
        open fun visitGroupByList(node: PartiqlBasic.GroupByList) { }
        open fun visitGroupBy(node: PartiqlBasic.GroupBy) { }
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        protected open fun visitProjection(node: PartiqlBasic.Projection) { }
        protected open fun visitProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) { }
        protected open fun visitProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) { }
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        protected open fun visitProjectItem(node: PartiqlBasic.ProjectItem) { }
        protected open fun visitProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) { }
        protected open fun visitProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) { }
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        protected open fun visitJoinType(node: PartiqlBasic.JoinType) { }
        protected open fun visitJoinTypeInner(node: PartiqlBasic.JoinType.Inner) { }
        protected open fun visitJoinTypeLeft(node: PartiqlBasic.JoinType.Left) { }
        protected open fun visitJoinTypeRight(node: PartiqlBasic.JoinType.Right) { }
        protected open fun visitJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) { }
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        protected open fun visitFromSource(node: PartiqlBasic.FromSource) { }
        protected open fun visitFromSourceScan(node: PartiqlBasic.FromSource.Scan) { }
        protected open fun visitFromSourceJoin(node: PartiqlBasic.FromSource.Join) { }
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        protected open fun visitCaseSensitivity(node: PartiqlBasic.CaseSensitivity) { }
        protected open fun visitCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) { }
        protected open fun visitCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) { }
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        protected open fun visitScopeQualifier(node: PartiqlBasic.ScopeQualifier) { }
        protected open fun visitScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) { }
        protected open fun visitScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) { }
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        protected open fun visitSetQuantifier(node: PartiqlBasic.SetQuantifier) { }
        protected open fun visitSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) { }
        protected open fun visitSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) { }
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        protected open fun visitPathElement(node: PartiqlBasic.PathElement) { }
        protected open fun visitPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) { }
        protected open fun visitPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) { }
        protected open fun visitPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) { }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: PartiqlBasic.Expr) { }
        protected open fun visitExprLit(node: PartiqlBasic.Expr.Lit) { }
        protected open fun visitExprId(node: PartiqlBasic.Expr.Id) { }
        protected open fun visitExprParameter(node: PartiqlBasic.Expr.Parameter) { }
        protected open fun visitExprNot(node: PartiqlBasic.Expr.Not) { }
        protected open fun visitExprPlus(node: PartiqlBasic.Expr.Plus) { }
        protected open fun visitExprMinus(node: PartiqlBasic.Expr.Minus) { }
        protected open fun visitExprTimes(node: PartiqlBasic.Expr.Times) { }
        protected open fun visitExprDivide(node: PartiqlBasic.Expr.Divide) { }
        protected open fun visitExprModulo(node: PartiqlBasic.Expr.Modulo) { }
        protected open fun visitExprConcat(node: PartiqlBasic.Expr.Concat) { }
        protected open fun visitExprLike(node: PartiqlBasic.Expr.Like) { }
        protected open fun visitExprBetween(node: PartiqlBasic.Expr.Between) { }
        protected open fun visitExprPath(node: PartiqlBasic.Expr.Path) { }
        protected open fun visitExprCall(node: PartiqlBasic.Expr.Call) { }
        protected open fun visitExprCallAgg(node: PartiqlBasic.Expr.CallAgg) { }
        protected open fun visitExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) { }
        protected open fun visitExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) { }
        protected open fun visitExprStruct(node: PartiqlBasic.Expr.Struct) { }
        protected open fun visitExprBag(node: PartiqlBasic.Expr.Bag) { }
        protected open fun visitExprList(node: PartiqlBasic.Expr.List) { }
        protected open fun visitExprSelect(node: PartiqlBasic.Expr.Select) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkExprPair(node: PartiqlBasic.ExprPair) {
            visitExprPair(node)
            walkExpr(node.first)
            walkExpr(node.second)
            walkMetas(node.metas)
        }
        open fun walkGroupByItem(node: PartiqlBasic.GroupByItem) {
            visitGroupByItem(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
        open fun walkGroupByList(node: PartiqlBasic.GroupByList) {
            visitGroupByList(node)
            node.items.map { walkGroupByItem(it) }
            walkMetas(node.metas)
        }
        open fun walkGroupBy(node: PartiqlBasic.GroupBy) {
            visitGroupBy(node)
            walkGroupByList(node.items)
            node.groupAsAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlBasic.Projection) {
            visitProjection(node)
            when(node) {
                is PartiqlBasic.Projection.ProjectList -> walkProjectionProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> walkProjectionProjectValue(node)
            }
        }
    
        open fun walkProjectionProjectList(node: PartiqlBasic.Projection.ProjectList) {
            visitProjectionProjectList(node)
            node.items.map { walkProjectItem(it) }
            walkMetas(node.metas)
        }
        open fun walkProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue) {
            visitProjectionProjectValue(node)
            walkExpr(node.value)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlBasic.ProjectItem) {
            visitProjectItem(node)
            when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll) {
            visitProjectItemProjectAll(node)
            walkMetas(node.metas)
        }
        open fun walkProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr) {
            visitProjectItemProjectExpr(node)
            walkExpr(node.value)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlBasic.JoinType) {
            visitJoinType(node)
            when(node) {
                is PartiqlBasic.JoinType.Inner -> walkJoinTypeInner(node)
                is PartiqlBasic.JoinType.Left -> walkJoinTypeLeft(node)
                is PartiqlBasic.JoinType.Right -> walkJoinTypeRight(node)
                is PartiqlBasic.JoinType.Outer -> walkJoinTypeOuter(node)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlBasic.JoinType.Inner) {
            visitJoinTypeInner(node)
            walkMetas(node.metas)
        }
        open fun walkJoinTypeLeft(node: PartiqlBasic.JoinType.Left) {
            visitJoinTypeLeft(node)
            walkMetas(node.metas)
        }
        open fun walkJoinTypeRight(node: PartiqlBasic.JoinType.Right) {
            visitJoinTypeRight(node)
            walkMetas(node.metas)
        }
        open fun walkJoinTypeOuter(node: PartiqlBasic.JoinType.Outer) {
            visitJoinTypeOuter(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlBasic.FromSource) {
            visitFromSource(node)
            when(node) {
                is PartiqlBasic.FromSource.Scan -> walkFromSourceScan(node)
                is PartiqlBasic.FromSource.Join -> walkFromSourceJoin(node)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlBasic.FromSource.Scan) {
            visitFromSourceScan(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            node.atAlias?.let { walkSymbolPrimitive(it) }
            node.byAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
        open fun walkFromSourceJoin(node: PartiqlBasic.FromSource.Join) {
            visitFromSourceJoin(node)
            walkJoinType(node.type)
            walkFromSource(node.left)
            walkFromSource(node.right)
            node.predicate?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlBasic.CaseSensitivity) {
            visitCaseSensitivity(node)
            when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive) {
            visitCaseSensitivityCaseSensitive(node)
            walkMetas(node.metas)
        }
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) {
            visitCaseSensitivityCaseInsensitive(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlBasic.ScopeQualifier) {
            visitScopeQualifier(node)
            when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> walkScopeQualifierQualified(node)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified) {
            visitScopeQualifierUnqualified(node)
            walkMetas(node.metas)
        }
        open fun walkScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified) {
            visitScopeQualifierQualified(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlBasic.SetQuantifier) {
            visitSetQuantifier(node)
            when(node) {
                is PartiqlBasic.SetQuantifier.All -> walkSetQuantifierAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All) {
            visitSetQuantifierAll(node)
            walkMetas(node.metas)
        }
        open fun walkSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct) {
            visitSetQuantifierDistinct(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun walkPathElement(node: PartiqlBasic.PathElement) {
            visitPathElement(node)
            when(node) {
                is PartiqlBasic.PathElement.PathExpr -> walkPathElementPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> walkPathElementPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> walkPathElementPathUnpivot(node)
            }
        }
    
        open fun walkPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr) {
            visitPathElementPathExpr(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
        open fun walkPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard) {
            visitPathElementPathWildcard(node)
            walkMetas(node.metas)
        }
        open fun walkPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot) {
            visitPathElementPathUnpivot(node)
            walkMetas(node.metas)
        }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlBasic.Expr) {
            visitExpr(node)
            when(node) {
                is PartiqlBasic.Expr.Lit -> walkExprLit(node)
                is PartiqlBasic.Expr.Id -> walkExprId(node)
                is PartiqlBasic.Expr.Parameter -> walkExprParameter(node)
                is PartiqlBasic.Expr.Not -> walkExprNot(node)
                is PartiqlBasic.Expr.Plus -> walkExprPlus(node)
                is PartiqlBasic.Expr.Minus -> walkExprMinus(node)
                is PartiqlBasic.Expr.Times -> walkExprTimes(node)
                is PartiqlBasic.Expr.Divide -> walkExprDivide(node)
                is PartiqlBasic.Expr.Modulo -> walkExprModulo(node)
                is PartiqlBasic.Expr.Concat -> walkExprConcat(node)
                is PartiqlBasic.Expr.Like -> walkExprLike(node)
                is PartiqlBasic.Expr.Between -> walkExprBetween(node)
                is PartiqlBasic.Expr.Path -> walkExprPath(node)
                is PartiqlBasic.Expr.Call -> walkExprCall(node)
                is PartiqlBasic.Expr.CallAgg -> walkExprCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> walkExprSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> walkExprSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> walkExprStruct(node)
                is PartiqlBasic.Expr.Bag -> walkExprBag(node)
                is PartiqlBasic.Expr.List -> walkExprList(node)
                is PartiqlBasic.Expr.Select -> walkExprSelect(node)
            }
        }
    
        open fun walkExprLit(node: PartiqlBasic.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
        open fun walkExprId(node: PartiqlBasic.Expr.Id) {
            visitExprId(node)
            walkSymbolPrimitive(node.name)
            walkCaseSensitivity(node.case)
            walkScopeQualifier(node.scopeQualifier)
            walkMetas(node.metas)
        }
        open fun walkExprParameter(node: PartiqlBasic.Expr.Parameter) {
            visitExprParameter(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
        open fun walkExprNot(node: PartiqlBasic.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
        open fun walkExprPlus(node: PartiqlBasic.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprMinus(node: PartiqlBasic.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprTimes(node: PartiqlBasic.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprDivide(node: PartiqlBasic.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprModulo(node: PartiqlBasic.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprConcat(node: PartiqlBasic.Expr.Concat) {
            visitExprConcat(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprLike(node: PartiqlBasic.Expr.Like) {
            visitExprLike(node)
            walkExpr(node.left)
            walkExpr(node.right)
            walkExpr(node.escape)
            walkMetas(node.metas)
        }
        open fun walkExprBetween(node: PartiqlBasic.Expr.Between) {
            visitExprBetween(node)
            walkExpr(node.value)
            walkExpr(node.from)
            walkExpr(node.to)
            walkMetas(node.metas)
        }
        open fun walkExprPath(node: PartiqlBasic.Expr.Path) {
            visitExprPath(node)
            walkExpr(node.root)
            node.elements.map { walkPathElement(it) }
            walkMetas(node.metas)
        }
        open fun walkExprCall(node: PartiqlBasic.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.name)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprCallAgg(node: PartiqlBasic.Expr.CallAgg) {
            visitExprCallAgg(node)
            walkSymbolPrimitive(node.name)
            walkSetQuantifier(node.setQuantifier)
            walkExpr(node.arg)
            walkMetas(node.metas)
        }
        open fun walkExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase) {
            visitExprSimpleCase(node)
            walkExpr(node.value)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
        open fun walkExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase) {
            visitExprSearchedCase(node)
            node.branches.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
        open fun walkExprStruct(node: PartiqlBasic.Expr.Struct) {
            visitExprStruct(node)
            node.fields.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
        open fun walkExprBag(node: PartiqlBasic.Expr.Bag) {
            visitExprBag(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprList(node: PartiqlBasic.Expr.List) {
            visitExprList(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
        open fun walkExprSelect(node: PartiqlBasic.Expr.Select) {
            visitExprSelect(node)
            node.setq?.let { walkSetQuantifier(it) }
            walkProjection(node.project)
            walkFromSource(node.from)
            node.where?.let { walkExpr(it) }
            node.group?.let { walkGroupBy(it) }
            node.having?.let { walkExpr(it) }
            node.limit?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    }
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitExprPair(node: PartiqlBasic.ExprPair, accumulator: T): T = accumulator
        open protected fun visitGroupByItem(node: PartiqlBasic.GroupByItem, accumulator: T): T = accumulator
        open protected fun visitGroupByList(node: PartiqlBasic.GroupByList, accumulator: T): T = accumulator
        open protected fun visitGroupBy(node: PartiqlBasic.GroupBy, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open protected fun visitProjection(node: PartiqlBasic.Projection, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectList(node: PartiqlBasic.Projection.ProjectList, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open protected fun visitProjectItem(node: PartiqlBasic.ProjectItem, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open protected fun visitJoinType(node: PartiqlBasic.JoinType, accumulator: T): T = accumulator
        open protected fun visitJoinTypeInner(node: PartiqlBasic.JoinType.Inner, accumulator: T): T = accumulator
        open protected fun visitJoinTypeLeft(node: PartiqlBasic.JoinType.Left, accumulator: T): T = accumulator
        open protected fun visitJoinTypeRight(node: PartiqlBasic.JoinType.Right, accumulator: T): T = accumulator
        open protected fun visitJoinTypeOuter(node: PartiqlBasic.JoinType.Outer, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open protected fun visitFromSource(node: PartiqlBasic.FromSource, accumulator: T): T = accumulator
        open protected fun visitFromSourceScan(node: PartiqlBasic.FromSource.Scan, accumulator: T): T = accumulator
        open protected fun visitFromSourceJoin(node: PartiqlBasic.FromSource.Join, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open protected fun visitCaseSensitivity(node: PartiqlBasic.CaseSensitivity, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open protected fun visitScopeQualifier(node: PartiqlBasic.ScopeQualifier, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open protected fun visitSetQuantifier(node: PartiqlBasic.SetQuantifier, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open protected fun visitPathElement(node: PartiqlBasic.PathElement, accumulator: T): T = accumulator
        open protected fun visitPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr, accumulator: T): T = accumulator
        open protected fun visitPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard, accumulator: T): T = accumulator
        open protected fun visitPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: PartiqlBasic.Expr, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: PartiqlBasic.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprId(node: PartiqlBasic.Expr.Id, accumulator: T): T = accumulator
        open protected fun visitExprParameter(node: PartiqlBasic.Expr.Parameter, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: PartiqlBasic.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: PartiqlBasic.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: PartiqlBasic.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: PartiqlBasic.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: PartiqlBasic.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: PartiqlBasic.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprConcat(node: PartiqlBasic.Expr.Concat, accumulator: T): T = accumulator
        open protected fun visitExprLike(node: PartiqlBasic.Expr.Like, accumulator: T): T = accumulator
        open protected fun visitExprBetween(node: PartiqlBasic.Expr.Between, accumulator: T): T = accumulator
        open protected fun visitExprPath(node: PartiqlBasic.Expr.Path, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: PartiqlBasic.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprCallAgg(node: PartiqlBasic.Expr.CallAgg, accumulator: T): T = accumulator
        open protected fun visitExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase, accumulator: T): T = accumulator
        open protected fun visitExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase, accumulator: T): T = accumulator
        open protected fun visitExprStruct(node: PartiqlBasic.Expr.Struct, accumulator: T): T = accumulator
        open protected fun visitExprBag(node: PartiqlBasic.Expr.Bag, accumulator: T): T = accumulator
        open protected fun visitExprList(node: PartiqlBasic.Expr.List, accumulator: T): T = accumulator
        open protected fun visitExprSelect(node: PartiqlBasic.Expr.Select, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkExprPair(node: PartiqlBasic.ExprPair, accumulator: T): T {
            var current = accumulator
            current = visitExprPair(node, current)
            current = walkExpr(node.first, current)
            current = walkExpr(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupByItem(node: PartiqlBasic.GroupByItem, accumulator: T): T {
            var current = accumulator
            current = visitGroupByItem(node, current)
            current = walkExpr(node.value, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupByList(node: PartiqlBasic.GroupByList, accumulator: T): T {
            var current = accumulator
            current = visitGroupByList(node, current)
            node.items.map { current = walkGroupByItem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupBy(node: PartiqlBasic.GroupBy, accumulator: T): T {
            var current = accumulator
            current = visitGroupBy(node, current)
            current = walkGroupByList(node.items, current)
            node.groupAsAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlBasic.Projection, accumulator: T): T {
            val current = visitProjection(node, accumulator)
            return when(node) {
                is PartiqlBasic.Projection.ProjectList -> walkProjectionProjectList(node, current)
                is PartiqlBasic.Projection.ProjectValue -> walkProjectionProjectValue(node, current)
            }
        }
    
        open fun walkProjectionProjectList(node: PartiqlBasic.Projection.ProjectList, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectList(node, current)
            node.items.map { current = walkProjectItem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectValue(node, current)
            current = walkExpr(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlBasic.ProjectItem, accumulator: T): T {
            val current = visitProjectItem(node, accumulator)
            return when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node, current)
                is PartiqlBasic.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node, current)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectAll(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectExpr(node, current)
            current = walkExpr(node.value, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlBasic.JoinType, accumulator: T): T {
            val current = visitJoinType(node, accumulator)
            return when(node) {
                is PartiqlBasic.JoinType.Inner -> walkJoinTypeInner(node, current)
                is PartiqlBasic.JoinType.Left -> walkJoinTypeLeft(node, current)
                is PartiqlBasic.JoinType.Right -> walkJoinTypeRight(node, current)
                is PartiqlBasic.JoinType.Outer -> walkJoinTypeOuter(node, current)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlBasic.JoinType.Inner, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeInner(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeLeft(node: PartiqlBasic.JoinType.Left, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeLeft(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeRight(node: PartiqlBasic.JoinType.Right, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeRight(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeOuter(node: PartiqlBasic.JoinType.Outer, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeOuter(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlBasic.FromSource, accumulator: T): T {
            val current = visitFromSource(node, accumulator)
            return when(node) {
                is PartiqlBasic.FromSource.Scan -> walkFromSourceScan(node, current)
                is PartiqlBasic.FromSource.Join -> walkFromSourceJoin(node, current)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlBasic.FromSource.Scan, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceScan(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.atAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.byAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkFromSourceJoin(node: PartiqlBasic.FromSource.Join, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceJoin(node, current)
            current = walkJoinType(node.type, current)
            current = walkFromSource(node.left, current)
            current = walkFromSource(node.right, current)
            node.predicate?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlBasic.CaseSensitivity, accumulator: T): T {
            val current = visitCaseSensitivity(node, accumulator)
            return when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node, current)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node, current)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseSensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseInsensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlBasic.ScopeQualifier, accumulator: T): T {
            val current = visitScopeQualifier(node, accumulator)
            return when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node, current)
                is PartiqlBasic.ScopeQualifier.Qualified -> walkScopeQualifierQualified(node, current)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierUnqualified(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierQualified(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlBasic.SetQuantifier, accumulator: T): T {
            val current = visitSetQuantifier(node, accumulator)
            return when(node) {
                is PartiqlBasic.SetQuantifier.All -> walkSetQuantifierAll(node, current)
                is PartiqlBasic.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node, current)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierAll(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierDistinct(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun walkPathElement(node: PartiqlBasic.PathElement, accumulator: T): T {
            val current = visitPathElement(node, accumulator)
            return when(node) {
                is PartiqlBasic.PathElement.PathExpr -> walkPathElementPathExpr(node, current)
                is PartiqlBasic.PathElement.PathWildcard -> walkPathElementPathWildcard(node, current)
                is PartiqlBasic.PathElement.PathUnpivot -> walkPathElementPathUnpivot(node, current)
            }
        }
    
        open fun walkPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathExpr(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathWildcard(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot, accumulator: T): T {
            var current = accumulator
            current = visitPathElementPathUnpivot(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlBasic.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is PartiqlBasic.Expr.Lit -> walkExprLit(node, current)
                is PartiqlBasic.Expr.Id -> walkExprId(node, current)
                is PartiqlBasic.Expr.Parameter -> walkExprParameter(node, current)
                is PartiqlBasic.Expr.Not -> walkExprNot(node, current)
                is PartiqlBasic.Expr.Plus -> walkExprPlus(node, current)
                is PartiqlBasic.Expr.Minus -> walkExprMinus(node, current)
                is PartiqlBasic.Expr.Times -> walkExprTimes(node, current)
                is PartiqlBasic.Expr.Divide -> walkExprDivide(node, current)
                is PartiqlBasic.Expr.Modulo -> walkExprModulo(node, current)
                is PartiqlBasic.Expr.Concat -> walkExprConcat(node, current)
                is PartiqlBasic.Expr.Like -> walkExprLike(node, current)
                is PartiqlBasic.Expr.Between -> walkExprBetween(node, current)
                is PartiqlBasic.Expr.Path -> walkExprPath(node, current)
                is PartiqlBasic.Expr.Call -> walkExprCall(node, current)
                is PartiqlBasic.Expr.CallAgg -> walkExprCallAgg(node, current)
                is PartiqlBasic.Expr.SimpleCase -> walkExprSimpleCase(node, current)
                is PartiqlBasic.Expr.SearchedCase -> walkExprSearchedCase(node, current)
                is PartiqlBasic.Expr.Struct -> walkExprStruct(node, current)
                is PartiqlBasic.Expr.Bag -> walkExprBag(node, current)
                is PartiqlBasic.Expr.List -> walkExprList(node, current)
                is PartiqlBasic.Expr.Select -> walkExprSelect(node, current)
            }
        }
    
        open fun walkExprLit(node: PartiqlBasic.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprId(node: PartiqlBasic.Expr.Id, accumulator: T): T {
            var current = accumulator
            current = visitExprId(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkCaseSensitivity(node.case, current)
            current = walkScopeQualifier(node.scopeQualifier, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprParameter(node: PartiqlBasic.Expr.Parameter, accumulator: T): T {
            var current = accumulator
            current = visitExprParameter(node, current)
            current = walkLongPrimitive(node.index, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: PartiqlBasic.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: PartiqlBasic.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: PartiqlBasic.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: PartiqlBasic.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: PartiqlBasic.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: PartiqlBasic.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprConcat(node: PartiqlBasic.Expr.Concat, accumulator: T): T {
            var current = accumulator
            current = visitExprConcat(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLike(node: PartiqlBasic.Expr.Like, accumulator: T): T {
            var current = accumulator
            current = visitExprLike(node, current)
            current = walkExpr(node.left, current)
            current = walkExpr(node.right, current)
            current = walkExpr(node.escape, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBetween(node: PartiqlBasic.Expr.Between, accumulator: T): T {
            var current = accumulator
            current = visitExprBetween(node, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.from, current)
            current = walkExpr(node.to, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPath(node: PartiqlBasic.Expr.Path, accumulator: T): T {
            var current = accumulator
            current = visitExprPath(node, current)
            current = walkExpr(node.root, current)
            node.elements.map { current = walkPathElement(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: PartiqlBasic.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.name, current)
            node.args.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCallAgg(node: PartiqlBasic.Expr.CallAgg, accumulator: T): T {
            var current = accumulator
            current = visitExprCallAgg(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkSetQuantifier(node.setQuantifier, current)
            current = walkExpr(node.arg, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSimpleCase(node, current)
            current = walkExpr(node.value, current)
            node.branches.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSearchedCase(node, current)
            node.branches.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprStruct(node: PartiqlBasic.Expr.Struct, accumulator: T): T {
            var current = accumulator
            current = visitExprStruct(node, current)
            node.fields.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBag(node: PartiqlBasic.Expr.Bag, accumulator: T): T {
            var current = accumulator
            current = visitExprBag(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprList(node: PartiqlBasic.Expr.List, accumulator: T): T {
            var current = accumulator
            current = visitExprList(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSelect(node: PartiqlBasic.Expr.Select, accumulator: T): T {
            var current = accumulator
            current = visitExprSelect(node, current)
            node.setq?.let { current = walkSetQuantifier(it, current) }
            current = walkProjection(node.project, current)
            current = walkFromSource(node.from, current)
            node.where?.let { current = walkExpr(it, current) }
            node.group?.let { current = walkGroupBy(it, current) }
            node.having?.let { current = walkExpr(it, current) }
            node.limit?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple ExprPair
        open fun transformExprPair(node: PartiqlBasic.ExprPair): PartiqlBasic.ExprPair {
            val new_first = transformExprPair_first(node)
            val new_second = transformExprPair_second(node)
            val new_metas = transformExprPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.ExprPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPair_first(node: PartiqlBasic.ExprPair) =
            transformExpr(node.first)
        open fun transformExprPair_second(node: PartiqlBasic.ExprPair) =
            transformExpr(node.second)
        open fun transformExprPair_metas(node: PartiqlBasic.ExprPair) =
            transformMetas(node.metas)
    
        // Tuple GroupByItem
        open fun transformGroupByItem(node: PartiqlBasic.GroupByItem): PartiqlBasic.GroupByItem {
            val new_value = transformGroupByItem_value(node)
            val new_asAlias = transformGroupByItem_asAlias(node)
            val new_metas = transformGroupByItem_metas(node)
            return if (
                node.value !== new_value ||
                node.asAlias !== new_asAlias ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.GroupByItem(
                    value = new_value,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupByItem_value(node: PartiqlBasic.GroupByItem) =
            transformExpr(node.value)
        open fun transformGroupByItem_asAlias(node: PartiqlBasic.GroupByItem) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupByItem_metas(node: PartiqlBasic.GroupByItem) =
            transformMetas(node.metas)
    
        // Tuple GroupByList
        open fun transformGroupByList(node: PartiqlBasic.GroupByList): PartiqlBasic.GroupByList {
            val new_items = transformGroupByList_items(node)
            val new_metas = transformGroupByList_metas(node)
            return if (
                node.items !== new_items ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.GroupByList(
                    items = new_items,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupByList_items(node: PartiqlBasic.GroupByList) =
            node.items.map { transformGroupByItem(it) }
        open fun transformGroupByList_metas(node: PartiqlBasic.GroupByList) =
            transformMetas(node.metas)
    
        // Tuple GroupBy
        open fun transformGroupBy(node: PartiqlBasic.GroupBy): PartiqlBasic.GroupBy {
            val new_items = transformGroupBy_items(node)
            val new_groupAsAlias = transformGroupBy_groupAsAlias(node)
            val new_metas = transformGroupBy_metas(node)
            return if (
                node.items !== new_items ||
                node.groupAsAlias !== new_groupAsAlias ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.GroupBy(
                    items = new_items,
                    groupAsAlias = new_groupAsAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupBy_items(node: PartiqlBasic.GroupBy) =
            transformGroupByList(node.items)
        open fun transformGroupBy_groupAsAlias(node: PartiqlBasic.GroupBy) =
            node.groupAsAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupBy_metas(node: PartiqlBasic.GroupBy) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun transformProjection(node: PartiqlBasic.Projection): PartiqlBasic.Projection =
            when(node) {
                is PartiqlBasic.Projection.ProjectList -> transformProjectionProjectList(node)
                is PartiqlBasic.Projection.ProjectValue -> transformProjectionProjectValue(node)
            }
        // Variant ProjectionProjectList
        open fun transformProjectionProjectList(node: PartiqlBasic.Projection.ProjectList): PartiqlBasic.Projection {
            val new_items = transformProjectionProjectList_items(node)
            val new_metas = transformProjectionProjectList_metas(node)
            return if (
                node.items !== new_items ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Projection.ProjectList(
                    items = new_items,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectList_items(node: PartiqlBasic.Projection.ProjectList) =
            node.items.map { transformProjectItem(it) }
        open fun transformProjectionProjectList_metas(node: PartiqlBasic.Projection.ProjectList) =
            transformMetas(node.metas)
    
        // Variant ProjectionProjectValue
        open fun transformProjectionProjectValue(node: PartiqlBasic.Projection.ProjectValue): PartiqlBasic.Projection {
            val new_value = transformProjectionProjectValue_value(node)
            val new_metas = transformProjectionProjectValue_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Projection.ProjectValue(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectValue_value(node: PartiqlBasic.Projection.ProjectValue) =
            transformExpr(node.value)
        open fun transformProjectionProjectValue_metas(node: PartiqlBasic.Projection.ProjectValue) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun transformProjectItem(node: PartiqlBasic.ProjectItem): PartiqlBasic.ProjectItem =
            when(node) {
                is PartiqlBasic.ProjectItem.ProjectAll -> transformProjectItemProjectAll(node)
                is PartiqlBasic.ProjectItem.ProjectExpr -> transformProjectItemProjectExpr(node)
            }
        // Variant ProjectItemProjectAll
        open fun transformProjectItemProjectAll(node: PartiqlBasic.ProjectItem.ProjectAll): PartiqlBasic.ProjectItem {
            val new_metas = transformProjectItemProjectAll_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.ProjectItem.ProjectAll(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectItemProjectAll_metas(node: PartiqlBasic.ProjectItem.ProjectAll) =
            transformMetas(node.metas)
    
        // Variant ProjectItemProjectExpr
        open fun transformProjectItemProjectExpr(node: PartiqlBasic.ProjectItem.ProjectExpr): PartiqlBasic.ProjectItem {
            val new_value = transformProjectItemProjectExpr_value(node)
            val new_asAlias = transformProjectItemProjectExpr_asAlias(node)
            val new_metas = transformProjectItemProjectExpr_metas(node)
            return if (
                node.value !== new_value ||
                node.asAlias !== new_asAlias ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.ProjectItem.ProjectExpr(
                    value = new_value,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectItemProjectExpr_value(node: PartiqlBasic.ProjectItem.ProjectExpr) =
            transformExpr(node.value)
        open fun transformProjectItemProjectExpr_asAlias(node: PartiqlBasic.ProjectItem.ProjectExpr) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformProjectItemProjectExpr_metas(node: PartiqlBasic.ProjectItem.ProjectExpr) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun transformJoinType(node: PartiqlBasic.JoinType): PartiqlBasic.JoinType =
            when(node) {
                is PartiqlBasic.JoinType.Inner -> transformJoinTypeInner(node)
                is PartiqlBasic.JoinType.Left -> transformJoinTypeLeft(node)
                is PartiqlBasic.JoinType.Right -> transformJoinTypeRight(node)
                is PartiqlBasic.JoinType.Outer -> transformJoinTypeOuter(node)
            }
        // Variant JoinTypeInner
        open fun transformJoinTypeInner(node: PartiqlBasic.JoinType.Inner): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeInner_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.JoinType.Inner(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeInner_metas(node: PartiqlBasic.JoinType.Inner) =
            transformMetas(node.metas)
    
        // Variant JoinTypeLeft
        open fun transformJoinTypeLeft(node: PartiqlBasic.JoinType.Left): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeLeft_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.JoinType.Left(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeLeft_metas(node: PartiqlBasic.JoinType.Left) =
            transformMetas(node.metas)
    
        // Variant JoinTypeRight
        open fun transformJoinTypeRight(node: PartiqlBasic.JoinType.Right): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeRight_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.JoinType.Right(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeRight_metas(node: PartiqlBasic.JoinType.Right) =
            transformMetas(node.metas)
    
        // Variant JoinTypeOuter
        open fun transformJoinTypeOuter(node: PartiqlBasic.JoinType.Outer): PartiqlBasic.JoinType {
            val new_metas = transformJoinTypeOuter_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.JoinType.Outer(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeOuter_metas(node: PartiqlBasic.JoinType.Outer) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun transformFromSource(node: PartiqlBasic.FromSource): PartiqlBasic.FromSource =
            when(node) {
                is PartiqlBasic.FromSource.Scan -> transformFromSourceScan(node)
                is PartiqlBasic.FromSource.Join -> transformFromSourceJoin(node)
            }
        // Variant FromSourceScan
        open fun transformFromSourceScan(node: PartiqlBasic.FromSource.Scan): PartiqlBasic.FromSource {
            val new_expr = transformFromSourceScan_expr(node)
            val new_asAlias = transformFromSourceScan_asAlias(node)
            val new_atAlias = transformFromSourceScan_atAlias(node)
            val new_byAlias = transformFromSourceScan_byAlias(node)
            val new_metas = transformFromSourceScan_metas(node)
            return if (
                node.expr !== new_expr ||
                node.asAlias !== new_asAlias ||
                node.atAlias !== new_atAlias ||
                node.byAlias !== new_byAlias ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.FromSource.Scan(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    atAlias = new_atAlias,
                    byAlias = new_byAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformFromSourceScan_expr(node: PartiqlBasic.FromSource.Scan) =
            transformExpr(node.expr)
        open fun transformFromSourceScan_asAlias(node: PartiqlBasic.FromSource.Scan) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_atAlias(node: PartiqlBasic.FromSource.Scan) =
            node.atAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_byAlias(node: PartiqlBasic.FromSource.Scan) =
            node.byAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_metas(node: PartiqlBasic.FromSource.Scan) =
            transformMetas(node.metas)
    
        // Variant FromSourceJoin
        open fun transformFromSourceJoin(node: PartiqlBasic.FromSource.Join): PartiqlBasic.FromSource {
            val new_type = transformFromSourceJoin_type(node)
            val new_left = transformFromSourceJoin_left(node)
            val new_right = transformFromSourceJoin_right(node)
            val new_predicate = transformFromSourceJoin_predicate(node)
            val new_metas = transformFromSourceJoin_metas(node)
            return if (
                node.type !== new_type ||
                node.left !== new_left ||
                node.right !== new_right ||
                node.predicate !== new_predicate ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.FromSource.Join(
                    type = new_type,
                    left = new_left,
                    right = new_right,
                    predicate = new_predicate,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformFromSourceJoin_type(node: PartiqlBasic.FromSource.Join) =
            transformJoinType(node.type)
        open fun transformFromSourceJoin_left(node: PartiqlBasic.FromSource.Join) =
            transformFromSource(node.left)
        open fun transformFromSourceJoin_right(node: PartiqlBasic.FromSource.Join) =
            transformFromSource(node.right)
        open fun transformFromSourceJoin_predicate(node: PartiqlBasic.FromSource.Join) =
            node.predicate?.let { transformExpr(it) }
        open fun transformFromSourceJoin_metas(node: PartiqlBasic.FromSource.Join) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun transformCaseSensitivity(node: PartiqlBasic.CaseSensitivity): PartiqlBasic.CaseSensitivity =
            when(node) {
                is PartiqlBasic.CaseSensitivity.CaseSensitive -> transformCaseSensitivityCaseSensitive(node)
                is PartiqlBasic.CaseSensitivity.CaseInsensitive -> transformCaseSensitivityCaseInsensitive(node)
            }
        // Variant CaseSensitivityCaseSensitive
        open fun transformCaseSensitivityCaseSensitive(node: PartiqlBasic.CaseSensitivity.CaseSensitive): PartiqlBasic.CaseSensitivity {
            val new_metas = transformCaseSensitivityCaseSensitive_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.CaseSensitivity.CaseSensitive(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformCaseSensitivityCaseSensitive_metas(node: PartiqlBasic.CaseSensitivity.CaseSensitive) =
            transformMetas(node.metas)
    
        // Variant CaseSensitivityCaseInsensitive
        open fun transformCaseSensitivityCaseInsensitive(node: PartiqlBasic.CaseSensitivity.CaseInsensitive): PartiqlBasic.CaseSensitivity {
            val new_metas = transformCaseSensitivityCaseInsensitive_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.CaseSensitivity.CaseInsensitive(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformCaseSensitivityCaseInsensitive_metas(node: PartiqlBasic.CaseSensitivity.CaseInsensitive) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun transformScopeQualifier(node: PartiqlBasic.ScopeQualifier): PartiqlBasic.ScopeQualifier =
            when(node) {
                is PartiqlBasic.ScopeQualifier.Unqualified -> transformScopeQualifierUnqualified(node)
                is PartiqlBasic.ScopeQualifier.Qualified -> transformScopeQualifierQualified(node)
            }
        // Variant ScopeQualifierUnqualified
        open fun transformScopeQualifierUnqualified(node: PartiqlBasic.ScopeQualifier.Unqualified): PartiqlBasic.ScopeQualifier {
            val new_metas = transformScopeQualifierUnqualified_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.ScopeQualifier.Unqualified(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformScopeQualifierUnqualified_metas(node: PartiqlBasic.ScopeQualifier.Unqualified) =
            transformMetas(node.metas)
    
        // Variant ScopeQualifierQualified
        open fun transformScopeQualifierQualified(node: PartiqlBasic.ScopeQualifier.Qualified): PartiqlBasic.ScopeQualifier {
            val new_metas = transformScopeQualifierQualified_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.ScopeQualifier.Qualified(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformScopeQualifierQualified_metas(node: PartiqlBasic.ScopeQualifier.Qualified) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun transformSetQuantifier(node: PartiqlBasic.SetQuantifier): PartiqlBasic.SetQuantifier =
            when(node) {
                is PartiqlBasic.SetQuantifier.All -> transformSetQuantifierAll(node)
                is PartiqlBasic.SetQuantifier.Distinct -> transformSetQuantifierDistinct(node)
            }
        // Variant SetQuantifierAll
        open fun transformSetQuantifierAll(node: PartiqlBasic.SetQuantifier.All): PartiqlBasic.SetQuantifier {
            val new_metas = transformSetQuantifierAll_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.SetQuantifier.All(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSetQuantifierAll_metas(node: PartiqlBasic.SetQuantifier.All) =
            transformMetas(node.metas)
    
        // Variant SetQuantifierDistinct
        open fun transformSetQuantifierDistinct(node: PartiqlBasic.SetQuantifier.Distinct): PartiqlBasic.SetQuantifier {
            val new_metas = transformSetQuantifierDistinct_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.SetQuantifier.Distinct(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSetQuantifierDistinct_metas(node: PartiqlBasic.SetQuantifier.Distinct) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: PathElement
        //////////////////////////////////////
        open fun transformPathElement(node: PartiqlBasic.PathElement): PartiqlBasic.PathElement =
            when(node) {
                is PartiqlBasic.PathElement.PathExpr -> transformPathElementPathExpr(node)
                is PartiqlBasic.PathElement.PathWildcard -> transformPathElementPathWildcard(node)
                is PartiqlBasic.PathElement.PathUnpivot -> transformPathElementPathUnpivot(node)
            }
        // Variant PathElementPathExpr
        open fun transformPathElementPathExpr(node: PartiqlBasic.PathElement.PathExpr): PartiqlBasic.PathElement {
            val new_expr = transformPathElementPathExpr_expr(node)
            val new_metas = transformPathElementPathExpr_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.PathElement.PathExpr(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathElementPathExpr_expr(node: PartiqlBasic.PathElement.PathExpr) =
            transformExpr(node.expr)
        open fun transformPathElementPathExpr_metas(node: PartiqlBasic.PathElement.PathExpr) =
            transformMetas(node.metas)
    
        // Variant PathElementPathWildcard
        open fun transformPathElementPathWildcard(node: PartiqlBasic.PathElement.PathWildcard): PartiqlBasic.PathElement {
            val new_metas = transformPathElementPathWildcard_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.PathElement.PathWildcard(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathElementPathWildcard_metas(node: PartiqlBasic.PathElement.PathWildcard) =
            transformMetas(node.metas)
    
        // Variant PathElementPathUnpivot
        open fun transformPathElementPathUnpivot(node: PartiqlBasic.PathElement.PathUnpivot): PartiqlBasic.PathElement {
            val new_metas = transformPathElementPathUnpivot_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlBasic.PathElement.PathUnpivot(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathElementPathUnpivot_metas(node: PartiqlBasic.PathElement.PathUnpivot) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: PartiqlBasic.Expr): PartiqlBasic.Expr =
            when(node) {
                is PartiqlBasic.Expr.Lit -> transformExprLit(node)
                is PartiqlBasic.Expr.Id -> transformExprId(node)
                is PartiqlBasic.Expr.Parameter -> transformExprParameter(node)
                is PartiqlBasic.Expr.Not -> transformExprNot(node)
                is PartiqlBasic.Expr.Plus -> transformExprPlus(node)
                is PartiqlBasic.Expr.Minus -> transformExprMinus(node)
                is PartiqlBasic.Expr.Times -> transformExprTimes(node)
                is PartiqlBasic.Expr.Divide -> transformExprDivide(node)
                is PartiqlBasic.Expr.Modulo -> transformExprModulo(node)
                is PartiqlBasic.Expr.Concat -> transformExprConcat(node)
                is PartiqlBasic.Expr.Like -> transformExprLike(node)
                is PartiqlBasic.Expr.Between -> transformExprBetween(node)
                is PartiqlBasic.Expr.Path -> transformExprPath(node)
                is PartiqlBasic.Expr.Call -> transformExprCall(node)
                is PartiqlBasic.Expr.CallAgg -> transformExprCallAgg(node)
                is PartiqlBasic.Expr.SimpleCase -> transformExprSimpleCase(node)
                is PartiqlBasic.Expr.SearchedCase -> transformExprSearchedCase(node)
                is PartiqlBasic.Expr.Struct -> transformExprStruct(node)
                is PartiqlBasic.Expr.Bag -> transformExprBag(node)
                is PartiqlBasic.Expr.List -> transformExprList(node)
                is PartiqlBasic.Expr.Select -> transformExprSelect(node)
            }
        // Variant ExprLit
        open fun transformExprLit(node: PartiqlBasic.Expr.Lit): PartiqlBasic.Expr {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: PartiqlBasic.Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: PartiqlBasic.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprId
        open fun transformExprId(node: PartiqlBasic.Expr.Id): PartiqlBasic.Expr {
            val new_name = transformExprId_name(node)
            val new_case = transformExprId_case(node)
            val new_scopeQualifier = transformExprId_scopeQualifier(node)
            val new_metas = transformExprId_metas(node)
            return if (
                node.name !== new_name ||
                node.case !== new_case ||
                node.scopeQualifier !== new_scopeQualifier ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Id(
                    name = new_name,
                    case = new_case,
                    scopeQualifier = new_scopeQualifier,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprId_name(node: PartiqlBasic.Expr.Id) =
            transformSymbolPrimitive(node.name)
        open fun transformExprId_case(node: PartiqlBasic.Expr.Id) =
            transformCaseSensitivity(node.case)
        open fun transformExprId_scopeQualifier(node: PartiqlBasic.Expr.Id) =
            transformScopeQualifier(node.scopeQualifier)
        open fun transformExprId_metas(node: PartiqlBasic.Expr.Id) =
            transformMetas(node.metas)
    
        // Variant ExprParameter
        open fun transformExprParameter(node: PartiqlBasic.Expr.Parameter): PartiqlBasic.Expr {
            val new_index = transformExprParameter_index(node)
            val new_metas = transformExprParameter_metas(node)
            return if (
                node.index !== new_index ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Parameter(
                    index = new_index,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprParameter_index(node: PartiqlBasic.Expr.Parameter) =
            transformLongPrimitive(node.index)
        open fun transformExprParameter_metas(node: PartiqlBasic.Expr.Parameter) =
            transformMetas(node.metas)
    
        // Variant ExprNot
        open fun transformExprNot(node: PartiqlBasic.Expr.Not): PartiqlBasic.Expr {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNot_expr(node: PartiqlBasic.Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: PartiqlBasic.Expr.Not) =
            transformMetas(node.metas)
    
        // Variant ExprPlus
        open fun transformExprPlus(node: PartiqlBasic.Expr.Plus): PartiqlBasic.Expr {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPlus_operands(node: PartiqlBasic.Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: PartiqlBasic.Expr.Plus) =
            transformMetas(node.metas)
    
        // Variant ExprMinus
        open fun transformExprMinus(node: PartiqlBasic.Expr.Minus): PartiqlBasic.Expr {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprMinus_operands(node: PartiqlBasic.Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: PartiqlBasic.Expr.Minus) =
            transformMetas(node.metas)
    
        // Variant ExprTimes
        open fun transformExprTimes(node: PartiqlBasic.Expr.Times): PartiqlBasic.Expr {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprTimes_operands(node: PartiqlBasic.Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: PartiqlBasic.Expr.Times) =
            transformMetas(node.metas)
    
        // Variant ExprDivide
        open fun transformExprDivide(node: PartiqlBasic.Expr.Divide): PartiqlBasic.Expr {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprDivide_operands(node: PartiqlBasic.Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: PartiqlBasic.Expr.Divide) =
            transformMetas(node.metas)
    
        // Variant ExprModulo
        open fun transformExprModulo(node: PartiqlBasic.Expr.Modulo): PartiqlBasic.Expr {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprModulo_operands(node: PartiqlBasic.Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: PartiqlBasic.Expr.Modulo) =
            transformMetas(node.metas)
    
        // Variant ExprConcat
        open fun transformExprConcat(node: PartiqlBasic.Expr.Concat): PartiqlBasic.Expr {
            val new_operands = transformExprConcat_operands(node)
            val new_metas = transformExprConcat_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Concat(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprConcat_operands(node: PartiqlBasic.Expr.Concat) =
            node.operands.map { transformExpr(it) }
        open fun transformExprConcat_metas(node: PartiqlBasic.Expr.Concat) =
            transformMetas(node.metas)
    
        // Variant ExprLike
        open fun transformExprLike(node: PartiqlBasic.Expr.Like): PartiqlBasic.Expr {
            val new_left = transformExprLike_left(node)
            val new_right = transformExprLike_right(node)
            val new_escape = transformExprLike_escape(node)
            val new_metas = transformExprLike_metas(node)
            return if (
                node.left !== new_left ||
                node.right !== new_right ||
                node.escape !== new_escape ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Like(
                    left = new_left,
                    right = new_right,
                    escape = new_escape,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLike_left(node: PartiqlBasic.Expr.Like) =
            transformExpr(node.left)
        open fun transformExprLike_right(node: PartiqlBasic.Expr.Like) =
            transformExpr(node.right)
        open fun transformExprLike_escape(node: PartiqlBasic.Expr.Like) =
            transformExpr(node.escape)
        open fun transformExprLike_metas(node: PartiqlBasic.Expr.Like) =
            transformMetas(node.metas)
    
        // Variant ExprBetween
        open fun transformExprBetween(node: PartiqlBasic.Expr.Between): PartiqlBasic.Expr {
            val new_value = transformExprBetween_value(node)
            val new_from = transformExprBetween_from(node)
            val new_to = transformExprBetween_to(node)
            val new_metas = transformExprBetween_metas(node)
            return if (
                node.value !== new_value ||
                node.from !== new_from ||
                node.to !== new_to ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Between(
                    value = new_value,
                    from = new_from,
                    to = new_to,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBetween_value(node: PartiqlBasic.Expr.Between) =
            transformExpr(node.value)
        open fun transformExprBetween_from(node: PartiqlBasic.Expr.Between) =
            transformExpr(node.from)
        open fun transformExprBetween_to(node: PartiqlBasic.Expr.Between) =
            transformExpr(node.to)
        open fun transformExprBetween_metas(node: PartiqlBasic.Expr.Between) =
            transformMetas(node.metas)
    
        // Variant ExprPath
        open fun transformExprPath(node: PartiqlBasic.Expr.Path): PartiqlBasic.Expr {
            val new_root = transformExprPath_root(node)
            val new_elements = transformExprPath_elements(node)
            val new_metas = transformExprPath_metas(node)
            return if (
                node.root !== new_root ||
                node.elements !== new_elements ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Path(
                    root = new_root,
                    elements = new_elements,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPath_root(node: PartiqlBasic.Expr.Path) =
            transformExpr(node.root)
        open fun transformExprPath_elements(node: PartiqlBasic.Expr.Path) =
            node.elements.map { transformPathElement(it) }
        open fun transformExprPath_metas(node: PartiqlBasic.Expr.Path) =
            transformMetas(node.metas)
    
        // Variant ExprCall
        open fun transformExprCall(node: PartiqlBasic.Expr.Call): PartiqlBasic.Expr {
            val new_name = transformExprCall_name(node)
            val new_args = transformExprCall_args(node)
            val new_metas = transformExprCall_metas(node)
            return if (
                node.name !== new_name ||
                node.args !== new_args ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Call(
                    name = new_name,
                    args = new_args,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCall_name(node: PartiqlBasic.Expr.Call) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCall_args(node: PartiqlBasic.Expr.Call) =
            node.args.map { transformExpr(it) }
        open fun transformExprCall_metas(node: PartiqlBasic.Expr.Call) =
            transformMetas(node.metas)
    
        // Variant ExprCallAgg
        open fun transformExprCallAgg(node: PartiqlBasic.Expr.CallAgg): PartiqlBasic.Expr {
            val new_name = transformExprCallAgg_name(node)
            val new_setQuantifier = transformExprCallAgg_setQuantifier(node)
            val new_arg = transformExprCallAgg_arg(node)
            val new_metas = transformExprCallAgg_metas(node)
            return if (
                node.name !== new_name ||
                node.setQuantifier !== new_setQuantifier ||
                node.arg !== new_arg ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.CallAgg(
                    name = new_name,
                    setQuantifier = new_setQuantifier,
                    arg = new_arg,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCallAgg_name(node: PartiqlBasic.Expr.CallAgg) =
            transformSymbolPrimitive(node.name)
        open fun transformExprCallAgg_setQuantifier(node: PartiqlBasic.Expr.CallAgg) =
            transformSetQuantifier(node.setQuantifier)
        open fun transformExprCallAgg_arg(node: PartiqlBasic.Expr.CallAgg) =
            transformExpr(node.arg)
        open fun transformExprCallAgg_metas(node: PartiqlBasic.Expr.CallAgg) =
            transformMetas(node.metas)
    
        // Variant ExprSimpleCase
        open fun transformExprSimpleCase(node: PartiqlBasic.Expr.SimpleCase): PartiqlBasic.Expr {
            val new_value = transformExprSimpleCase_value(node)
            val new_branches = transformExprSimpleCase_branches(node)
            val new_metas = transformExprSimpleCase_metas(node)
            return if (
                node.value !== new_value ||
                node.branches !== new_branches ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.SimpleCase(
                    value = new_value,
                    branches = new_branches,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSimpleCase_value(node: PartiqlBasic.Expr.SimpleCase) =
            transformExpr(node.value)
        open fun transformExprSimpleCase_branches(node: PartiqlBasic.Expr.SimpleCase) =
            node.branches.map { transformExprPair(it) }
        open fun transformExprSimpleCase_metas(node: PartiqlBasic.Expr.SimpleCase) =
            transformMetas(node.metas)
    
        // Variant ExprSearchedCase
        open fun transformExprSearchedCase(node: PartiqlBasic.Expr.SearchedCase): PartiqlBasic.Expr {
            val new_branches = transformExprSearchedCase_branches(node)
            val new_metas = transformExprSearchedCase_metas(node)
            return if (
                node.branches !== new_branches ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.SearchedCase(
                    branches = new_branches,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSearchedCase_branches(node: PartiqlBasic.Expr.SearchedCase) =
            node.branches.map { transformExprPair(it) }
        open fun transformExprSearchedCase_metas(node: PartiqlBasic.Expr.SearchedCase) =
            transformMetas(node.metas)
    
        // Variant ExprStruct
        open fun transformExprStruct(node: PartiqlBasic.Expr.Struct): PartiqlBasic.Expr {
            val new_fields = transformExprStruct_fields(node)
            val new_metas = transformExprStruct_metas(node)
            return if (
                node.fields !== new_fields ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Struct(
                    fields = new_fields,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprStruct_fields(node: PartiqlBasic.Expr.Struct) =
            node.fields.map { transformExprPair(it) }
        open fun transformExprStruct_metas(node: PartiqlBasic.Expr.Struct) =
            transformMetas(node.metas)
    
        // Variant ExprBag
        open fun transformExprBag(node: PartiqlBasic.Expr.Bag): PartiqlBasic.Expr {
            val new_values = transformExprBag_values(node)
            val new_metas = transformExprBag_metas(node)
            return if (
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Bag(
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBag_values(node: PartiqlBasic.Expr.Bag) =
            node.values.map { transformExpr(it) }
        open fun transformExprBag_metas(node: PartiqlBasic.Expr.Bag) =
            transformMetas(node.metas)
    
        // Variant ExprList
        open fun transformExprList(node: PartiqlBasic.Expr.List): PartiqlBasic.Expr {
            val new_values = transformExprList_values(node)
            val new_metas = transformExprList_metas(node)
            return if (
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.List(
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprList_values(node: PartiqlBasic.Expr.List) =
            node.values.map { transformExpr(it) }
        open fun transformExprList_metas(node: PartiqlBasic.Expr.List) =
            transformMetas(node.metas)
    
        // Variant ExprSelect
        open fun transformExprSelect(node: PartiqlBasic.Expr.Select): PartiqlBasic.Expr {
            val new_setq = transformExprSelect_setq(node)
            val new_project = transformExprSelect_project(node)
            val new_from = transformExprSelect_from(node)
            val new_where = transformExprSelect_where(node)
            val new_group = transformExprSelect_group(node)
            val new_having = transformExprSelect_having(node)
            val new_limit = transformExprSelect_limit(node)
            val new_metas = transformExprSelect_metas(node)
            return if (
                node.setq !== new_setq ||
                node.project !== new_project ||
                node.from !== new_from ||
                node.where !== new_where ||
                node.group !== new_group ||
                node.having !== new_having ||
                node.limit !== new_limit ||
                node.metas !== new_metas
            ) {
                PartiqlBasic.Expr.Select(
                    setq = new_setq,
                    project = new_project,
                    from = new_from,
                    where = new_where,
                    group = new_group,
                    having = new_having,
                    limit = new_limit,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSelect_setq(node: PartiqlBasic.Expr.Select) =
            node.setq?.let { transformSetQuantifier(it) }
        open fun transformExprSelect_project(node: PartiqlBasic.Expr.Select) =
            transformProjection(node.project)
        open fun transformExprSelect_from(node: PartiqlBasic.Expr.Select) =
            transformFromSource(node.from)
        open fun transformExprSelect_where(node: PartiqlBasic.Expr.Select) =
            node.where?.let { transformExpr(it) }
        open fun transformExprSelect_group(node: PartiqlBasic.Expr.Select) =
            node.group?.let { transformGroupBy(it) }
        open fun transformExprSelect_having(node: PartiqlBasic.Expr.Select) =
            node.having?.let { transformExpr(it) }
        open fun transformExprSelect_limit(node: PartiqlBasic.Expr.Select) =
            node.limit?.let { transformExpr(it) }
        open fun transformExprSelect_metas(node: PartiqlBasic.Expr.Select) =
            transformMetas(node.metas)
    
    }
}

