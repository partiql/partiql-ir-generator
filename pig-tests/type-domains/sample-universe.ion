

/*
    `test_domain` covers all of the following equivalence classes and is included to test the serializers and
    domain builders.

    - Sums, products and records with:
        - int
        - symbol
        - ion (tests should include some combination of: scalar, collections, null, typed nulls, etc)
        - other user defined types
            - sum
            - variant

    - Products...
        - Product with no fields (definitely possible for sum variants--possible with top-level products too?)- with only required fields
        - with only optional fields
        - with only a variadic field
        - with required and optional field
        - with required and variadic fields.  (TODO:  not supported yet)
        - Note:  products cannot have both optional and variadic fields.
    - Sum variants...
        - product variant (repeat as above)
        - Records with more than one required, optional and variadic field.
 */

 (define test_domain
    (domain
        (product int_pair int int)
        (product symbol_pair symbol symbol)
        (product ion_pair ion ion)

        (product int_symbol_pair int symbol)
        (product symbol_int_pair symbol int)
        (product ion_int_pair ion int)
        (product ion_symbol_pair ion ion)

        (product int_pair_pair int_pair int_pair)
        (product symbol_pair_pair symbol_pair symbol_pair)
        (product ion_pair_pair ion_pair ion_pair)

        (product recursive_pair int (? recursive_pair))

        (sum answer (no) (yes))

        (product answer_pair answer answer)
        (product answer_int_pair answer int)
        (product int_answer_pair int answer)
        (product symbol_answer_pair symbol answer)
        (product answer_symbol_pair answer symbol)

        (product variadic_min_0 (* int 0 ))
        (product variadic_min_1 (* int 1 ))
        (product element_variadic symbol (* int 0 ))

        (product optional_1 (? int))
        (product optional_2 (? int) (? int))

        (record domain_level_record
            (some_field int)
            (another_field symbol)
            (optional_field (? int)))

        (sum entity
            // Slugs are not uniquely identified.
            (slug)
            // Androids are identified by serial number.
            (android int)

            // Uniquely identifying humans a bit more is complex and requires a record.
            (human (first_name symbol)          // required
                   //TODO: variadic record fields are not currently supported in records.
                   // (middle_names (* symbol 0))  // variadic
                   (last_name symbol)           // required
                   (title (? symbol))           // optional
                   (parent (? entity))))        // recursive

        (product entity_pair entity entity)
    ))

// This is an "AST" for a simple hypothetical language named "Toy".
// Toy has literals, variables, basic arithmetic and functions that accept a single argument.

(define toy_lang
 (domain
   (sum expr
    (lit ion)
    (variable symbol)
    (not expr)
    (plus (* expr 2))
    (minus (* expr 2))
    (times (* expr 2))
    (divide (* expr 2))
    (modulo (* expr 2))
    (call symbol expr)
    (let symbol expr expr)
    (function symbol expr))))

// Define another type domain which extends "toy_lang" by removing named variables and adding DeBruijn indices:

(define toy_lang_nameless
  (permute_domain toy_lang
    (with expr
      (exclude variable let)
      (include
        (variable int)
        (let int expr expr)))))

// This is an incomplete AST definition for PartiQL to show what a more complex domain definition will look like.
// Other than being incomplete, this differs from the V0 AST:  the names/tags are *unique* as outlined in Pig's
// README.md

(define partiql_basic
  (domain
    (sum projection
      (project_list (* project_item 1))
      (project_value expr))

    (sum project_item
      (project_all)
      (project_expr expr (? symbol)))

    (sum join_type
      (inner)
      (left)
      (right)
      (outer))

    (sum from_source
      (scan expr (? symbol) (? symbol) (? symbol))
      (join join_type from_source from_source (? expr)))

    (product expr_pair expr expr)

    (product group_by_item expr (? symbol))

    (product group_by_list
      (* group_by_item 1))

    (product group_by
      group_by_list
      (? symbol))  // group as alias

    (sum case_sensitivity
      (case_sensitive)
      (case_insensitive))

    (sum scope_qualifier
      (unqualified)
      (qualified))

    (sum set_quantifier
      (all)
      (distinct))

    (sum path_element
      (path_expr expr)
      (path_wildcard)
      (path_unpivot))

    (sum expr
      // Basic Expressions
      (lit ion)
      (id symbol case_sensitivity scope_qualifier)
      (parameter int)
      (not expr)
      (plus (* expr 2))
      (minus (* expr 2))
      (times (* expr 2))
      (divide (* expr 2))
      (modulo (* expr 2))
      (concat (* expr 2))
      (like expr expr expr)
      (between expr expr expr)
      (path expr (* path_element 1))
      (call symbol (* expr 1))
      (call_agg symbol set_quantifier expr)

     // Case Statements
      (simple_case expr (* expr_pair 1))
      (searched_case (* expr_pair 1))

     // Value Constructors
      (struct (* expr_pair 0))
      (bag (* expr 0))
      (list (* expr 0))

     (select
      (setq (? set_quantifier))
      (project projection)
      (from from_source)
      (where (? expr))        // where
      (group (? group_by))
      (having (? expr))        // having
      (limit (? expr))))       // limit
    ) // end domain
 ) // end define

(define partiql_algebra
  (permute_domain partiql_basic
    (exclude projection project_item)
    (include
      (product tuple_field symbol))
    (with expr
      (exclude select)
      (include
       (filter expr expr)
       (construct_value from_source)
       (construct_tuple from_source (* tuple_field 1))
     ))))

(define partiql_basic_nameless
  (permute_domain partiql_algebra
    (with expr
      (exclude id)
      (include (id int)))))

