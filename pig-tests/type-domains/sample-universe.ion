
/*
    `test_domain` covers all of the following equivalence classes and is included to test the serializers and
    domain builders.

    - Sums, products and records with:
        - int
        - symbol
        - ion (tests should include some combination of: scalar, collections, null, typed nulls, etc)
        - other user defined types
            - sum
            - variant

    - Products...
        - Product with no fields (definitely possible for sum variants--possible with top-level products too?)- with only required fields
        - with only optional fields
        - with only a variadic field
        - with required and optional field
        - with required and variadic fields.  (TODO:  not supported yet)
        - Note:  products cannot have both optional and variadic fields.
    - Sum variants...
        - product variant (repeat as above)
        - Records with more than one required, optional and variadic field.
 */

 (define test_domain
    (domain
        (product int_pair first::int second::int)
        (product symbol_pair first::symbol second::symbol)
        (product ion_pair first::ion second::ion)

        (product int_symbol_pair first::int second::symbol)
        (product symbol_int_pair first::symbol second::int)
        (product ion_int_pair first::ion second::int)
        (product ion_symbol_pair first::ion second::ion)

        (product int_pair_pair first::int_pair second::int_pair)
        (product symbol_pair_pair first::symbol_pair second::symbol_pair)
        (product ion_pair_pair first::ion_pair second::ion_pair)

        (product recursive_pair first::int second::(? recursive_pair))

        (sum answer (no) (yes))

        (product answer_pair first::answer second::answer)
        (product answer_int_pair first::answer second::int)
        (product int_answer_pair first::int second::answer)
        (product symbol_answer_pair first::symbol second::answer)
        (product answer_symbol_pair first::answer second::symbol)

        (product variadic_min_0 ints::(* int 0 ))
        (product variadic_min_1 ints::(* int 1 ))
        (product element_variadic name::symbol ints::(* int 0 ))

        (product optional_1 value::(? int))
        (product optional_2 first::(? int) second::(? int))

        (record domain_level_record
            (some_field int)
            (another_field symbol)
            (optional_field (? int)))

        (product product_with_record value::int dlr::domain_level_record)
        (sum sum_with_record
            (variant_with_record value::int dlr::domain_level_record))

        (sum test_sum
            (one a::int)
            (two a::int b::int)
            (three a::int b::int c::int))

        (product test_sum_triplet a::test_sum b::test_sum c::test_sum)

        (sum entity
            // Slugs are not uniquely identified.
            (slug)
            // Androids are identified by serial number.
            (android id::int)

            // Uniquely identifying humans a bit more is complex and requires a record.
            (human (first_name symbol)          // required
                   //TODO: variadic record fields are not currently supported in records.
                   // (middle_names (* symbol 0))  // variadic
                   (last_name symbol)           // required
                   (title (? symbol))           // optional
                   (parent (? entity))))        // recursive

        (product entity_pair first::entity second::entity)
    ))


// A domain where every identifier is contains multiple words to excercise
// naming convention conversion code.  Mainly, this is to test to make sure
// the resulting code compiles.  All the variations of required, optional and
// variadic fields *should* make sure we get better branch coverage in
// KTypeDomainConverter.
(define multi_word_domain
    (domain
        (product aaa_aaa)
        (product aaa_aab d_field::(? int))
        (product aaa_aac d_field::(? int) e_field::(? symbol))
        (product aaa_aad d_field::(* int 0))
        (product aaa_aae d_field::(* int 2))

        (product aab_aaa b_field::int c_field::symbol)
        (product aab_aab b_field::int c_field::symbol d_field::(? int))
        (product aab_aac b_field::int c_field::symbol d_field::(? int) e_field::(? symbol))
        (product aab_aad b_field::int c_field::symbol d_field::(* int 0))
        (product aab_aae b_field::int c_field::symbol d_field::(* int 2))

        (sum sss_ttt
            (lll u_field::int)
            (mmm v_field::symbol))

        (record rrr
            (a_field int)
            bbb_field::(b_field int))

))
