[#ftl]
[#-- @ftlvariable name="universe" type="org.partiql.pig.generator.kotlin.KTypeUniverse" --]
[#-- @ftlvariable name="namespace" type="java.lang.String" --]
[#-- @ftlvariable name="generatedDate" type="java.time.OffsetDateTime" --]
[#-- Helpful links documenting Apache Freemarker:

Note:  the documentation shows directives wrapped in < > but we've configured it to use [ ] instead since
that seems cleaner when generating Kotlin code.

https://freemarker.apache.org/docs/dgui_template_overallstructure.html
https://freemarker.apache.org/docs/index.html

https://freemarker.apache.org/docs/dgui_misc_whitespace.html
--]
[#-- Generates a parameter list not including (). --]
[#macro parameter_list params]
[#list params as param]
[#if param.variadic]vararg [/#if]${param.name}: ${param.type}[#if param.defaultValue??] = ${param.defaultValue}[/#if],
[/#list]
metas: MetaContainer = emptyMetaContainer()
[/#macro]

[#-- Template to generate a tuple type class. --]
[#macro tuple t index]
class ${t.name}(
    [#list t.properties as p]
    val ${p.name}: ${p.type},
    [/#list]
    override val metas: MetaContainer = emptyMetaContainer()
): ${t.superClass}() {

    override fun withMeta(key: String, value: Any): ${t.name} =
        ${t.name}(
            [#list t.properties as p]
            ${p.name} = ${p.name},
            [/#list]
            metas = metas + metaContainerOf(key to value))

[#if t.record]
    override fun toIonElement(): IonElement {

        val elements = listOfNotNull(
            ionSymbol("${t.name}"),
        [#list t.properties as p]
            ${p.name}?.let { ionSexpOf(ionSymbol("${p.name}"), it.toIonElement()) }[#sep],[/#sep]
        [/#list]
        )

        return ionSexpOf(elements, metas)
    }
[#else]
    override fun toIonElement(): IonElement {
        val elements = ionSexpOf(
            ionSymbol("${t.name}")[#rt]
[#list t.properties as p],
    [#if p.variadic]
            *${p.name}.map { it.toIonElement() }.toTypedArray()[#rt]
    [#else]
        [#if p.nullable]
            ${p.name}?.toIonElement() ?: ionNull()[#rt]
        [#else]
            ${p.name}.toIonElement()[#rt]
        [/#if][#rt]
    [/#if]
[/#list],
            metas = metas)
        return elements
    }
[/#if]

    override fun equals(other: Any?): Boolean {
        if (other == null) return false
        if (this === other) return true
        if (other.javaClass != ${t.name}::class.java) return false

        [#list t.properties]
        other as ${t.name}
        [#items as p]
        if (${p.name} != other.${p.name}) return false
        [/#items]
        [/#list]
        return true
    }

    [#list t.properties]
    private val myHashCode by lazy(LazyThreadSafetyMode.NONE) {
        [#items as p]
        [#if p?index == 0]var hc = [#else]hc = 31 * hc + [/#if]${p.name}.hashCode()
        [/#items]
        hc
    }

    override fun hashCode(): Int = myHashCode
    [#else]
    override fun hashCode(): Int = ${index?c}
    [/#list]
}

[/#macro]

[#--Emits builder functions that wraps the constructors of domain type. --]
[#macro builder_constructor_fun t ret_type ret_value_cons]
[#list t.builderFunctions as bf]
fun ${bf.name}(
    [@indent count=4]
        [@parameter_list bf.parameters/]
    [/@indent]
): ${ret_type} =
    ${ret_value_cons}(
    [#list bf.constructorArguments as p]
        ${p.name} = ${p.value},
    [/#list]
        metas = metas)

[/#list]
[/#macro]

[#---------------------------------------------------------------------------
    Template output starts here
 ----------------------------------------------------------------------------]
/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  [#-- Unless you're editing the template, of course! --]
 */
@file:Suppress("unused", "FunctionName", "ClassName", "MemberVisibilityCanBePrivate", "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL", "LocalVariableName", "USELESS_ELVIS")


package ${namespace}

import javax.annotation.*
import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

[#list universe.domains as domain]
class ${domain.name} private constructor() {
[@indent count = 4]
/////////////////////////////////////////////////////////////////////////////
// Builder
/////////////////////////////////////////////////////////////////////////////
companion object {
    fun <T: ${domain.name}_node> build(block: builder.() -> T) =
        builder.block()

    fun transform(element: IonElement): ${domain.name}_node =
        Transformer().transform(element)
}

object builder {
    [@indent count = 4]
        [#if domain.tuples?size > 0]
        // Tuples
        [#list domain.tuples as tuple]
        [@builder_constructor_fun tuple tuple.name "${domain.name}.${tuple.name}"/]

        [/#list]
        [/#if]
        [#list domain.sums as s]
        [#-- Not sure why the [#lt] below is needed to emit the correct indentation. --]
        // Variants for Sum: ${s.name} [#lt]
        [#list s.variants as tuple]
        [@builder_constructor_fun tuple s.name "${s.name}.${tuple.name}"/]

        [/#list]
        [/#list]
    [/@indent]
}

/** Base class for all ${domain.name} types. */
abstract class ${domain.name}_node : DomainNode {
    override fun toString() = toIonElement().toString()
    abstract override fun withMeta(key: String, value: Any): ${domain.name}_node
}


[#if domain.tuples?size > 0]
/////////////////////////////////////////////////////////////////////////////
// Tuple Types
/////////////////////////////////////////////////////////////////////////////
[#list domain.tuples as p]
[@tuple p p?index /]
[/#list]
[/#if]

/////////////////////////////////////////////////////////////////////////////
// Sum Types
/////////////////////////////////////////////////////////////////////////////
[#list domain.sums as s]

sealed class ${s.name} : ${s.superClass}() {

[#list s.variants as v]
[@indent count=4]
    [@tuple t = v index = ((s?index + 1) * 1000 + v?index) /]
[/@indent]

[/#list]
}
[/#list]

/////////////////////////////////////////////////////////////////////////////
// Transformer
/////////////////////////////////////////////////////////////////////////////

[#macro transformer_case tuple]
    "${tuple.name}" -> {
    [#if tuple.record]
        val ir = sexp.transformToIntermediateRecord()
        [#-- TODO:  support variadic fields --]

        [#list tuple.properties as p]
        val ${p.name} = ${p.transformExpr}
        [/#list]

        ir.malformedIfAnyUnprocessedFieldsRemain()

        ${tuple.constructorName}([#list tuple.properties as cp]${cp.name}, [/#list]metas = sexp.metas)
    [#else]
        sexp.requireArityOrMalformed(IntRange(#{tuple.arity.first}, #{tuple.arity.last}))
        [#list tuple.properties as p]
        val ${p.name} = ${p.transformExpr}
        [/#list]
        ${tuple.constructorName}(
            [#list tuple.properties as p]
            ${p.name},
            [/#list]
            metas = sexp.metas)
    [/#if]
    }
[/#macro]

private class Transformer : IonElementTransformerBase<${domain.name}_node>() {

    override fun innerTransform(maybeSexp: IonElement): ${domain.name}_node {
        val sexp = maybeSexp.sexpValue
        return when(sexp.tag) {
[#if domain.tuples?size > 0]
            //////////////////////////////////////
            // Tuple Types
            //////////////////////////////////////
[#list domain.tuples as p]
[@indent count = 8]
[@transformer_case p /]
[/@indent]
[/#list]
[/#if]
[#list domain.sums as s]
            //////////////////////////////////////
            // Variants for Sum Type '${s.name}'
            //////////////////////////////////////
[#list s.variants as v]
[@indent count = 8]
[@transformer_case v /]
[/@indent]
[/#list]
[/#list]
            else -> errMalformed(sexp.head.metas.location, "Unknown tag '${r"${sexp.tag}"}' for domain '${domain.name}'")
        }
    }
}

[/@indent]
}

[/#list]