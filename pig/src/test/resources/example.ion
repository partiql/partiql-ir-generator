    // `statement` encompasses within it all possible PartiQL statements and expressions.
    //  Note that DDL and DML statements are not expressions and cannot be used in the context where an expression
    //  is required.  (For example, `1 + (DROP TABLE foo)`)
    (sum statement
        // any expression that can be used in a context that requires a result.
        (query expr::expr)

        // Data manipulation operations cannot be composed with other `expr` nodes, although they may
        // contain `expr` nodes themselves.
        // TODO:  The `dml` variant and `dml_op` sum type closely mirrors the historical `V0` AST. The disadvantage
        // of this approach is that different DML operations allow or require different combinations of FROM source
        // and WHERE predicate. For instance, DELETE requires FROM source while REMOVE does not. It may be
        // necessary to check the validity of these nodes during compilation or another phase.  In the future, we
        // should consider changing the modeling of these so such validity checks are not needed.
        (dml
            (operations ops::dml_op_list)
            (from from::( from_source))
            (where where::( expr))
            (returning returning::( returning_expr)))

        // Data definition operations also cannot be composed with other `expr` nodes.
        (ddl op::ddl_op)

        // Stored procedure calls are only allowed at the top level of a query and cannot be used as an expression
        // Currently supports stored procedure calls with the unnamed argument syntax:
        //     EXEC <symbol> [<expr>.*]
        (exec procedure_name::symbol args::(list expr ))

        // Explain Statement
        (explain target::explain_target)
    )

    (sum explain_target
         (domain
             statement::statement
             type::( symbol)
             format::( symbol)
         )
    )

    // The expressions that can result in values.
    (sum expr
        // SQL Session Keywords (CURRENT_USER, CURRENT_ROLE, etc.)
        (session_attribute value::symbol)

        // The literal missing value.
        (missing)

        // A literal value.  Can be a literal in the PartiQL syntax or a back-tick quoted Ion literal.
        // Also represents a literal NULL value (i.e. `(lit null)`.)
        (lit value::ion)

        // A variable reference
        (id name::symbol case::case_sensitivity qualifier::scope_qualifier)

        // A parameter, i.e. `?`
        (parameter index::int)

        // Unary operators
        (not expr::expr)
        (pos expr::expr) // +
        (neg expr::expr) // -

        // Applies to all variants with a single (list expr ) element below: https://github.com/partiql/partiql-lang-kotlin/issues/241
        // Arithmetic operators
        (plus operands::(list expr ))
        (minus operands::(list expr ))
        (times operands::(list expr ))
        (divide operands::(list expr ))
        (modulo operands::(list expr ))
        (concat operands::(list expr ))
        (bitwise_and operands::(list expr ))

        // Logical operators
        (and operands::(list expr ))
        (or operands::(list expr ))

        // Comparison operators
        (eq operands::(list expr ))
        (ne operands::(list expr ))
        (gt operands::(list expr ))
        (gte operands::(list expr ))
        (lt operands::(list expr ))
        (lte operands::(list expr ))
        (like value::expr pattern::expr escape::( expr))
        (between value::expr from::expr to::expr)
        // The PartiQL `IN` operator cannot be named `in` since that is a Kotlin keyword.
        (in_collection operands::(list expr ))
        // The PartiQL `IS` operator  cannot be named `is` since that is a Kotlin keyword.
        (is_type value::expr type::type)

        // CASE <expr> [ WHEN <expr> THEN <expr> ]... [ ELSE <expr> ] END
        (simple_case expr::expr cases::expr_pair_list default::( expr))

        // CASE [ WHEN <expr> THEN <expr> ]... [ ELSE <expr> ] END
        (searched_case cases::expr_pair_list default::( expr))

        // Constructors
        (struct fields::(list expr_pair ))
        // https://github.com/partiql/partiql-lang-kotlin/issues/239
        (bag values::(list expr ))
        (list values::(list expr ))
        (sexp values::(list expr ))

        // Constructors for DateTime types
        (date year::int month::int day::int)
        (lit_time value::time_value)
        (timestamp value::timestamp_value)

        // Bag operators
        (bag_op op::bag_op_type quantifier::set_quantifier operands::(list expr ))

        // GPML graph pattern match:  <expr> MATCH <gpml_pattern>
        (graph_match expr::expr gpml_pattern::gpml_pattern)

        // Other expression types
        (path root::expr steps::(list path_step ))
        (call func_name::symbol args::(list expr ))
        (call_agg setq::set_quantifier func_name::symbol arg::expr)
        // TODO: In the feature, when we allow use of aggregation function as window function, we need to consider incorporate in setq
        (call_window func_name::symbol over::over args::(list expr ))
        (cast value::expr as_type::type)
        (can_cast value::expr as_type::type)
        (can_lossless_cast value::expr as_type::type)
        (null_if expr1::expr expr2::expr)
        (coalesce args::(list expr ))

        // `SELECT` and its parts.
        // Once variadic record element support is added (https://github.com/partiql/partiql-ir-generator/issues/4),
        // the let clauses may be modeled directly using let_binding.
        (select
            (setq ( set_quantifier))
            (project projection)
            (exclude_clause ( exclude_op))
            (from from_source)
            (from_let ( let))
            (where ( expr))
            (group ( group_by))
            (having ( expr))
            (order ( order_by))
            (limit ( expr))
            (offset ( expr))))
    // end of sum expr

    // Time
    (product time_value hour::int minute::int second::int nano::int precision::int with_time_zone::bool tz_minutes::( int))

    // Timestamp
    (product timestamp_value year::int month::int day::int hour::int minute::int second::ion timezone::( timezone) precision::( int) )

    (sum timezone
         // Unknown time zone -00:00
         (unknown_timezone)
         // UTC offset ex: -01:30 -> tz_hour = -1, tz_minutes = -30, total offset minutes = -90
         // tz_hour is in [-23, 23], timezone minutes is in [-59,59]
         // we only need total offset minutes to model this property
         (utc_offset offset_minutes::int)
         // TODO: Timezone ID not support yet. Ex: US/Pacific
    )

    // A "step" within a path expression; that is the components of the expression following the root.
    (sum path_step
        // `someRoot[<expr>]`, or `someRoot.someField` which is equivalent to `someRoot['someField']`.
        (path_expr index::expr case::case_sensitivity)
        // `someRoot[*]`
        (path_wildcard)
        // `someRoot.*`
        (path_unpivot))

    // Indicates the type of projection in a SFW query.
    (sum projection
        // SELECT *
        (project_star)
        // SELECT <project_item>... (SQL-92 style select list with optional AS aliases or <expr>.*)
        (project_list project_items::(list project_item ))
        // PIVOT <id> AT <id>
        (project_pivot value::expr key::expr)
        // SELECT VALUE <expr>
        (project_value value::expr))

    // An item to be projected in a `SELECT`-list.
    (sum project_item
        // For `.*` in SELECT list
        (project_all expr::expr)
        // For `<expr> [AS <id>]`
        (project_expr expr::expr as_alias::( symbol)))

    // EXCLUDE clause
    (product exclude_op exprs::(list exclude_expr ))

    (product exclude_expr root::identifier steps::(list exclude_step ))

    (sum exclude_step
        // `someRoot.someField` case sensitivity depends on if `someField` is quoted
        // `someRoot[<string literal>] is equivalent to `someRoot."<string literal>"` (case-sensitive)
        (exclude_tuple_attr attr::identifier)
        // `someRoot[<int literal>]`
        (exclude_collection_index index::int)
        // `someRoot[*]`]
        (exclude_tuple_wildcard)
        // `someRoot.*`
        (exclude_collection_wildcard))

    // A list of LET bindings
    (product let let_bindings::(list let_binding ))

    // A LET binding
    (product let_binding expr::expr name::symbol)

    // Models the FROM clause of an SFW query
    // Note that modeling `scan` and `unpivot` separately is effectively re-introducing the same problem described
    // here: https://github.com/partiql/partiql-lang-kotlin/issues/39 . We should consider removing both the `scan`
    // and `unpivot` nodes and replacing them with `from_let` node that has an element indicating if it is a `scan
    // or from ``and add another element to scan to indicate if this `scan` or `unpivot`. Something along the lines of:
    // https://github.com/partiql/partiql-lang-kotlin/issues/242
    //     (sum from_let_type (scan) (unpivot))
    //     (sum from_source
    //          (from_let expr from_let_type ( symbol) ( symbol) ( symbol))
    //          (join ...))
    (sum from_source
        // <expr> [AS <id>] [AT <id>] [BY <id>]
        (scan expr::expr as_alias::( symbol) at_alias::( symbol) by_alias::( symbol))

        // UNPIVOT <expr> [AS <id>] [AT <id>] [BY <id>]
        (unpivot expr::expr as_alias::( symbol) at_alias::( symbol) by_alias::( symbol))

        // <from_source> JOIN [INNER | LEFT | RIGHT | FULL] <from_source> ON <expr>
        (join type::join_type left::from_source right::from_source predicate::( expr))
    )

    // Indicates the logical type of join.
    (sum join_type (inner) (left) (right) (full))

    // The direction of an edge
    // | Orientation               | Edge pattern | Abbreviation |
    // |---------------------------+--------------+--------------|
    // | Pointing left             | <−[ spec ]−  | <−           |
    // | Undirected                | ~[ spec ]~   | ~            |
    // | Pointing right            | −[ spec ]−>  | −>           |
    // | Left or undirected        | <~[ spec ]~  | <~           |
    // | Undirected or right       | ~[ spec ]~>  | ~>           |
    // | Left or right             | <−[ spec ]−> | <−>          |
    // | Left, undirected or right | −[ spec ]−   | −            |
    //
    // Fig. 5. Table of edge patterns:
    // https://arxiv.org/abs/2112.06217
    (sum graph_match_direction
         (edge_left)
         (edge_undirected)
         (edge_right)
         (edge_left_or_undirected)
         (edge_undirected_or_right)
         (edge_left_or_right)
         (edge_left_or_undirected_or_right))

    // A label spec in a node pattern like `MATCH (x : <lab>)` or in an edge pattern like `MATCH −[t : <lab>]−>`
    (sum graph_label_spec
        (graph_label_name name::symbol)                   // as in `MATCH (x:Account)` or `MATCH -[x:Transfer]->`
        (graph_label_wildcard)                            // as in `MATCH (x: %)`
        (graph_label_negation arg::graph_label_spec)      // as in `MATCH (x: !Account)`
        (graph_label_conj lhs::graph_label_spec rhs::graph_label_spec)   // as in `MATCH (x: City&Country)` - Monaco can do
        (graph_label_disj lhs::graph_label_spec rhs::graph_label_spec)   // as in `MATCH (x: City|Country)` - either Paris or Germany will do
    )

    // A part of a graph pattern
    (sum graph_match_pattern_part
         // A single node in a graph pattern.
         (node
             prefilter::( expr)   // an optional node pre-filter, e.g.: `WHERE c.name='Alarm'` in `MATCH (c WHERE c.name='Alarm')`
             variable::( symbol)  // the optional element variable of the node match, e.g.: `x` in `MATCH (x)`
             label::( graph_label_spec))  // the optional label spec to match for the node, e.g.: `Entity` in `MATCH (x:Entity)`

         // A single edge in a graph pattern.
         (edge
             direction::graph_match_direction       // edge direction
             quantifier::( graph_match_quantifier) // an optional quantifier for the entire pattern match, e.g. `{2,5}` in `MATCH (a:Account)−[:Transfer]−>{2,5}(b:Account)`
             prefilter::( expr)   // an optional edge pre-filter, e.g.: `WHERE t.capacity>100` in `MATCH −[t:hasSupply WHERE t.capacity>100]−>`
             variable::( symbol)  // the optional element variable of the edge match, e.g.: `t` in `MATCH −[t]−>`
             label::( graph_label_spec))  // the optional label spec to match for the edge. e.g.: `Target` in `MATCH −[t:Target]−>`

         // A sub-pattern.
         (pattern pattern::graph_match_pattern))

    // A quantifier for graph edges or patterns. (e.g., the `{2,5}` in `MATCH (x)->{2,5}(y)`)
    (product graph_match_quantifier lower::int upper::( int))

    // A path restrictor
    // | Keyword        | Description
    // |----------------+--------------
    // | TRAIL          | No repeated edges.
    // | ACYCLIC        | No repeated nodes.
    // | SIMPLE         | No repeated nodes, except that the ﬁrst and last nodes may be the same.
    //
    // Fig. 7. Table of restrictors:
    // https://arxiv.org/abs/2112.06217
    (sum graph_match_restrictor
         (restrictor_trail)
         (restrictor_acyclic)
         (restrictor_simple))

    // A single graph match pattern.
    (product graph_match_pattern
         restrictor::( graph_match_restrictor)
         prefilter::( expr)    // an optional pattern pre-filter, e.g.: `WHERE a.name=b.name` in `MATCH [(a)->(b) WHERE a.name=b.name]`
         variable::( symbol)   // the optional element variable of the pattern, e.g.: `p` in `MATCH p = (a) −[t]−> (b)`
         quantifier::( graph_match_quantifier) // an optional quantifier for the entire pattern match, e.g. `{2,5}` in `MATCH (a:Account)−[:Transfer]−>{2,5}(b:Account)`
         parts::(list graph_match_pattern_part )) // the ordered pattern parts

    // A path selector
    // | Keyword
    // |------------------
    // | ANY SHORTEST
    // | ALL SHORTEST
    // | ANY
    // | ANY k
    // | SHORTEST k
    // | SHORTEST k GROUP
    //
    // Fig. 8. Table of restrictors:
    // https://arxiv.org/abs/2112.06217
    (sum graph_match_selector
         (selector_any_shortest)
         (selector_all_shortest)
         (selector_any)
         (selector_any_k k::int)
         (selector_shortest_k k::int)
         (selector_shortest_k_group k::int))

    // A graph pattern as defined in GPML
    // See https://arxiv.org/abs/2112.06217
    (product gpml_pattern
             selector::( graph_match_selector)
             patterns::(list graph_match_pattern ))


    // A generic pair of expressions.  Used in the `struct`, `searched_case` and `simple_case` expr variants above.
    (product expr_pair first::expr second::expr)

    // A list of expr_pair. Used in the `struct`, `searched_case` and `simple_case` expr variants above.
    (product expr_pair_list pairs::(list expr_pair ))

    // GROUP BY <grouping_strategy> <group_key_list>... [AS <symbol>]
    (product group_by
        strategy::grouping_strategy
        // Note that `group_key_list` is a separate type instead of a variadic element because of the
        // PIG limitation that product types cannot have both optional and variadic elements.
        key_list::group_key_list
        group_as_alias::( symbol))  // `GROUP AS` alias

    // Desired grouping qualifier:  ALL or PARTIAL.  Note: the `group_` prefix is needed to avoid naming clashes.
    (sum grouping_strategy
        (group_full)
        (group_partial))

    // <group_key>[, <group_key>]...
    (product group_key_list keys::(list group_key ))

    // <expr> [AS <symbol>]
    (product group_key expr::expr as_alias::( symbol))

    // ORDER BY <sort_spec>...
    (product order_by sort_specs::(list sort_spec ))

    // <expr> [ASC | DESC] [NULLS FIRST | NULLS LAST]
    (product sort_spec expr::expr ordering_spec::( ordering_spec) nulls_spec::( nulls_spec))

    // Desired ordering spec: ASC or DESC
    (sum ordering_spec
        (asc)
        (desc)
    )

    // Desired null/missing ordering spec: NULLS FIRST or NULLS LAST
    (sum nulls_spec
         (nulls_first)
         (nulls_last)
    )

    // Over clause of a window function.
    // OVER ([PARTITION BY <expr> [, <expr>]... ] [ORDER BY <sort_spec> [, <sort_spec>]... ])
    // TODO: In the future, we need to add support for custom declared frame clause
    // TODO: Remove from experimental once https://github.com/partiql/partiql-docs/issues/31 is resolved and a RFC is approved
    (product over partition_by::( window_partition_list ) order_by::( window_sort_spec_list ) )

    // <expr>[, <expr>]...
    (product window_partition_list exprs::(list expr 1 ))

    // <sort_spec>[, <sort_spec>]...
    (product window_sort_spec_list sort_specs::(list sort_spec 1 ))

    // Indicates if variable lookup should be case-sensitive or not.
    (sum case_sensitivity (case_sensitive) (case_insensitive))

    // Indicates scope search order when resolving variables.  Has no effect except within `FROM` sources.
    (sum scope_qualifier
        // Use the default search order.
        (unqualified)
        // Skip the globals first check within FROM sources and resolve starting with the local scope.
        (locals_first))

    // Indicates if a set should be reduced to its distinct elements or not.
    (sum set_quantifier (all) (distinct))

    (sum bag_op_type (union) (intersect) (except) (outer_union) (outer_intersect) (outer_except))

    // A Data Manipulation Operation.
    // TODO:  domain of `expr` is too broad for several elements below: https://github.com/partiql/partiql-lang-kotlin/issues/243
    (product dml_op_list ops::(list dml_op ))

    (sum dml_op
        // See the following RFC for more details:
        // https://github.com/partiql/partiql-docs/blob/main/RFCs/0011-partiql-insert.md
        (insert target::expr as_alias::( symbol) values::expr conflict_action::( conflict_action))

        // `INSERT INTO <expr> VALUE <expr> [AT <expr>]` [ON CONFLICT WHERE <expr> DO NOTHING]`
        (insert_value target::expr value::expr index::( expr) on_conflict::( on_conflict))

        // `SET <assignment>...`
        (set assignment::assignment)

        // `REMOVE <expr>`
        (remove target::expr)

        // DELETE
        (delete)
     )

    // `ON CONFLICT WHERE <expr> <conflict_action>`
    (product on_conflict expr::expr conflict_action::conflict_action)

    // `CONFLICT_ACTION <action>`
    (sum conflict_action
        (do_replace value::on_conflict_value condition::( expr))
        (do_update value::on_conflict_value condition::( expr))
        (do_nothing))

    (sum on_conflict_value
        (excluded))

    // A data definition operation.
    (sum ddl_op
        // `CREATE TABLE <symbol> ( <table_def> )?`
        (create_table table_name::symbol def::( table_def))

        // `DROP TABLE <identifier>`
        (drop_table table_name::identifier)

        // `CREATE INDEX ON <identifier> (<expr> [, <expr>]...)`
        // TODO: add optional table name
        (create_index index_name::identifier fields::(list expr ))

        // DROP INDEX <identifier> ON <identifier>
        // In Statement, first <identifier> represents keys, second represents table
        (drop_index
            (table identifier)
            (keys identifier)))

    (product table_def parts::(list table_def_part ))

    (sum table_def_part
        // `<column_name> <type> <column_constraint>*`
        (column_declaration name::symbol type::type constraints::(list column_constraint )))

    // `( CONSTRAINT <column_constraint_name> )?  <column_constraint_def>`
    (product column_constraint name::( symbol) def::column_constraint_def)

    //  `NULL | NOT NULL | CHECK ( <expr> )`
    (sum column_constraint_def
        (column_notnull)
        (column_null))

    // `RETURNING (<returning_elem> [, <returning_elem>]...)`
    (product returning_expr elems::(list returning_elem ))

    // `<returning mapping> (<expr> [, <expr>]...)`
    (product returning_elem mapping::returning_mapping column::column_component)

    (sum column_component
        (returning_wildcard)
        (returning_column expr::expr)
    )

    // ( MODIFIED | ALL ) ( NEW | OLD )
    (sum returning_mapping
        (modified_new)
        (modified_old)
        (all_new)
        (all_old)
    )

    // `identifier` can be used for names that need to be looked up with a notion of case-sensitivity.

    // For both `create_index` and `create_table`, there is no notion of case-sensitivity
    // for table identifiers since they are *defining* new identifiers.  However, for `drop_index` and
    // `drop_table` *do* have the notion of case sensitivity since they are referring to existing names.
    // Identifiers with case-sensitivity is already modeled with the `id` variant of `expr`,
    // but there is no way to specify to PIG that we want to only allow a single variant of a sum as
    // an element of a type.  (Even though in the Kotlin code each varaint is its own type.)  Hence, we
    // define an `identifier` type above which can be used without opening up an element's domain to all of
    // `expr`.
    (product identifier name::symbol case::case_sensitivity)

    // Represents `<expr> = <expr>` in a DML SET operation.  Note that in this case, `=` is representing
    // an assignment operation and *not* the equality operator.
    (product assignment target::expr value::expr)

    // Represents all possible PartiQL data types. (`_type` suffixes below prevent naming clashes.)
    (sum type

        // SQL-92 types
        // `NULL`
        (null_type)

        // `BOOL`
        (boolean_type)

        // `SMALLINT`
        (smallint_type)

        // `INT4` 4-byte integer
        (integer4_type)

        // `INT8` 8-byte integer
        (integer8_type)

        // `INT`
        (integer_type)

        // `FLOAT`
        (float_type precision::( int))

        // `REAL`
        (real_type)

        // `DOUBLE_PRECISION`
        (double_precision_type)

        // `DECIMAL[(<int> [, int])]`.  Elements are precision then scale.
        (decimal_type precision::( int) scale::( int))

        // `NUMERIC[(<int> [, int])]`.  Elements are precision then scale.
        (numeric_type precision::( int) scale::( int))

        // `CHAR(<int>)`
        (character_type length::( int))

        // `VARCHAR`
        (character_varying_type length::( int))

        // PartiQL types.
        (missing_type)
        (string_type)
        (symbol_type)
        (blob_type)
        (clob_type)
        (date_type)

        // TIME : timezoneSpecified is 1 if time zone is specified else 0
        //        precision is defaulted to the length of the mantissa of the second's value if the precision is not specified.
        // Note: This logic is implemented in SqlParser.
        (time_type precision::( int))
        (time_with_time_zone_type precision::( int))
        (timestamp_type precision::( int))
        (timestamp_with_time_zone_type precision::( int))

        (struct_type)
        (tuple_type)
        (list_type)
        (sexp_type)
        (bag_type)

        // Special types
        (any_type)

        (custom_type name::symbol)
    )
